main.py
# === Импорты ===
from aiogram.filters import ExceptionTypeFilter
from aiogram.types import Message
from aiogram_dialog.api.exceptions import UnknownIntent, UnknownState
from apscheduler.schedulers.asyncio import AsyncIOScheduler
import asyncio
from aiogram import Dispatcher
from app.db.database import init_db
from app.dependencies import bot, ON_SCHEDULE
from apscheduler.events import EVENT_JOB_ERROR, EVENT_JOB_MISSED, EVENT_JOB_EXECUTED
from app.dialogs.bot_menu.states import BotMenu
from app.handlers import (
    start_handler, affiliate_program, admin_handler, bot_handler,
    get_email_handler, receive_sms_handler, rent_number_handler, report
)
from app.handlers.health_check_router import health_check_router
from app.services.keyboards import start_kb
from app.services.notify_admins import notify_wakeup_bot
from app.services.onlinesim.service_updater import add_services
from app.services.periodic_tasks import (
    check_sms, check_email, check_payment_lava, check_mail_expiration_and_notify,
    check_payment_freekassa, check_payment_yoomoney, check_payment_anypay, check_payment_streampay,
    check_payment_ckassa, check_rent_sms, rents_ending_soon, close_rent,
    checking_inactive_rent, auto_renewal_of_rent, send_coder, check_payment_cryptomus, notify_week_expiration
)
from app.services.ping_scheduler import userbot_ping
from app.services.set_bot_commands import set_default_commands
from app.services import stars_pay
from logger_config import logger
from app.scheduler_instance import scheduler
from app.services import bot_texts as bt

import signal
import logging

# Версия для отображения/отладки
msg_text = "Версия 01.06.2025"


# === Обработчики исключений Dialog Manager ===
async def on_unknown_intent(message: Message):
    logger.bind(user_id=message.from_user.id).log("USER_ACTION", "Неизвестный intent – возврат в главное меню")
    await message.answer(text=bt.MAIN_MENU, reply_markup=start_kb())


async def on_unknown_state(message: Message):
    logger.bind(user_id=message.from_user.id).log("USER_ACTION", "Неизвестный state – возврат в главное меню")
    await message.answer(text=bt.MAIN_MENU, reply_markup=start_kb())


# === Слушатель задач планировщика ===
def job_listener(event):
    """
    Listener для обработки ошибок, выполнения и пропусков задач.
    """
    pass
    # if event.code == EVENT_JOB_ERROR:
    #     logger.error(f"Задача {event.job_id} вызвала исключение: {event.exception}")
    # elif event.code == EVENT_JOB_MISSED:
    #     logger.warning(f"Задача {event.job_id} была пропущена в {event.scheduled_run_time}")
    # elif event.code == EVENT_JOB_EXECUTED:
    #     logger.log("SUCCESS", f"Задача {event.job_id} успешно выполнена в {event.scheduled_run_time}")


# === Основной запуск бота ===
async def main(dp: Dispatcher):
    """
    Основная функция запуска бота и планировщика.
    """
    logger.success("Запуск Telegram-бота")

    main_routers = [
        admin_handler.router,
        report.router,
        start_handler.router,
        affiliate_program.router,
        health_check_router,
        get_email_handler.router,
        receive_sms_handler.router,
        rent_number_handler.router,
    ]

    # Регистрация глобальных обработчиков ошибок
    dp.errors.register(on_unknown_intent, ExceptionTypeFilter(UnknownIntent))
    dp.errors.register(on_unknown_state, ExceptionTypeFilter(UnknownState))

    # Подключение диалогов и роутеров
    from app.dialogs import setup_dialogs
    dp.include_routers(bot_handler.router, *main_routers)
    logger.success("Роутеры и диалоги зарегистрированы")

    setup_dialogs(dp)

    # Команды для Telegram-бота
    await set_default_commands(bot)
    logger.success("Установлены команды по умолчанию")

    # Инициализация базы данных
    await init_db()
    logger.success("Инициализация базы данных завершена")

    # Уведомление администратора о запуске
    await notify_wakeup_bot(bot)
    logger.success("Бот сообщил о пробуждении")

    # Регистрация обработчика оплаты
    dp.pre_checkout_query.register(stars_pay.pre_checkout_handler)

    # Планировщик задач
    set_scheduled_jobs(scheduler)
    scheduler.add_listener(job_listener, EVENT_JOB_ERROR | EVENT_JOB_MISSED | EVENT_JOB_EXECUTED)
    if not scheduler.running:
        scheduler.start()
        logger.info("Планировщик задач запущен")

    # Прочие задачи перед polling
    await userbot_ping()
    await send_coder(msg_text)

    # Старт polling
    await dp.start_polling(bot)


# === Планировщик задач ===
def set_scheduled_jobs(scheduler):
    try:
        if ON_SCHEDULE:
            # Проверка SMS
            scheduler.add_job(check_sms, "interval", seconds=10, max_instances=10)
            # Проверка Email
            scheduler.add_job(check_email, "interval", seconds=30, max_instances=3)
            # Проверка платежей через CKassa
            scheduler.add_job(check_payment_ckassa, "interval", seconds=25, max_instances=10)
            # Проверка платежей через Streampay
            scheduler.add_job(check_payment_streampay, "interval", seconds=28, max_instances=10)
            # Проверка платежей через FreeKassa
            scheduler.add_job(check_payment_freekassa, "interval", seconds=33, max_instances=10)
            # Проверка платежей через Anypay
            scheduler.add_job(check_payment_anypay, "interval", seconds=45, max_instances=10)
            # Проверка платежей через cryptomus
            scheduler.add_job(check_payment_cryptomus, "interval", seconds=50, max_instances=10)
            # Добавление\обновление сервисов
            scheduler.add_job(add_services, "cron", hour=3, minute=0)
            # Пинг userbot
            scheduler.add_job(userbot_ping, "interval", seconds=300, max_instances=3)
            # Проверка истечения срока почты и уведомления
            scheduler.add_job(check_mail_expiration_and_notify, "interval", minutes=20, max_instances=3)
            # Проверка истечения срока почты арендованной на неделю
            scheduler.add_job(notify_week_expiration, "interval", minutes=10)
            # Проверка арендованных SMS
            scheduler.add_job(check_rent_sms, "interval", seconds=35, max_instances=10)
            # Уведомление об аренде, которая скоро завершится
            scheduler.add_job(rents_ending_soon, "interval", minutes=1, max_instances=3)
            # Автопродление аренды за 2 часа до окончания
            scheduler.add_job(auto_renewal_of_rent, "interval", minutes=1, max_instances=3)
            # Завершение аренды
            scheduler.add_job(close_rent, "interval", minutes=1, max_instances=3)
            # Проверка незавершенных аренд
            scheduler.add_job(checking_inactive_rent, "interval", minutes=20, max_instances=3)
        else:
            logger.info(f'ON_SCHEDULE выключен ({ON_SCHEDULE})')
    except Exception as e:
        logger.opt(exception=e).error("Ошибка при добавлении задач в планировщик")


# === Фильтры для подавления лишних логов apscheduler ===
class SkipSpecificLogFilter(logging.Filter):
    def filter(self, record):
        return not (
            "Execution of job" in record.getMessage() and
            "skipped: maximum number of running instances reached" in record.getMessage()
        )


class MissedJobLogFilter(logging.Filter):
    def filter(self, record):
        return "Job" not in record.getMessage() or "was missed" not in record.getMessage()


# === Обработка SIGTERM ===
def shutdown_scheduler(scheduler):
    logger.info("Остановка планировщика...")
    scheduler.shutdown()


signal.signal(signal.SIGTERM, lambda *args: shutdown_scheduler(scheduler))


# === Точка входа ===
if __name__ == '__main__':
    try:
        from app.dependencies import dp
        logger.success("=== Старт main.py ===")

        # Подавление лишних логов apscheduler
        aps_logger = logging.getLogger('apscheduler')
        aps_logger.setLevel(logging.WARNING)
        logging.getLogger('apscheduler.executors.default').setLevel(logging.WARNING)
        handler = logging.StreamHandler()
        handler.addFilter(SkipSpecificLogFilter())
        handler.addFilter(MissedJobLogFilter())
        aps_logger.addHandler(handler)

        asyncio.run(main(dp))

    except Exception as e:
        logger.opt(exception=e).critical(f'Критическая ошибка в main: {e}')


app\dependencies.py
from pathlib import Path
import yaml
from aiogram import Bot, Dispatcher
from aiogram.fsm.storage.memory import MemoryStorage
from aiogram.client.bot import DefaultBotProperties


def read_config(path, default={}):
    if path.exists() is False:
        # print(f"WARNING: {path} not found")
        return default
    else:
        with path.open('r') as ymlfile:
            return yaml.safe_load(ymlfile)


BAS_DIR = Path(__file__).parent
config = read_config(BAS_DIR / 'config.yaml')

# Database
DB_USER = config.get("DB_USER")
DB_PASS = config.get("DB_PASS")
DB_HOST = config.get("DB_HOST")
DB_PORT = config.get("DB_PORT")
DB_NAME = config.get("DB_NAME")

SMS_ACTIVATE_KEY = config.get("SMS_ACTIVATE_KEY")
REF_BONUS = config.get("REF_BONUS")
WITHDRAW_CHAT_ID = config.get("WITHDRAW_CHAT_ID")
SUPPORT_URL = config.get("SUPPORT_URL")
CHANNEL_ID = config.get("CHANNEL_ID")

DATABASE_DATA = f"{DB_USER}:{DB_PASS}@{DB_HOST}:{DB_PORT}/{DB_NAME}"
DATABASE_URL = f'postgresql+asyncpg://{DATABASE_DATA}'
DATABASE_URL_SYNC = f'postgresql://{DATABASE_DATA}'

DB_CONFIG = {
    'connections': {
        'default': {
            'engine': 'tortoise.backends.asyncpg',
            'credentials': {
                'host': f'{DB_HOST}',
                'port': f'{DB_PORT}',
                'user': f'{DB_USER}',
                'password': f'{DB_PASS}',
                'database': f'{DB_NAME}',
            },
        },
    },
    'apps': {
        'models': {
            'models': ['app.db.models', 'aerich.models'],
            'default_connection': 'default',
        },
    },
}

with open("aerich.ini", "r") as aerich_file:
    aerich_config = aerich_file.read()

aerich_config = aerich_config.replace("%(db_url)s", DATABASE_URL)

with open("aerich.ini", "w") as aerich_file:
    aerich_file.write(aerich_config)

API_TOKEN = config.get('API_TOKEN')
ADMINS = config.get('ADMINS', [])
CODER = config.get('CODER')
USER_BOT = config.get('USER_BOT')


LAVA_SHOP_ID = config.get('LAVA_SHOP_ID')
LAVA_SECRET_KEY = config.get('LAVA_SECRET_KEY')

FK_SHOP_ID = config.get('FK_SHOP_ID')
FK_SECRET_KEY = config.get('FK_SECRET_KEY')
FK_FK_API_KEY = config.get('FK_API_KEY')

YOOMONEY_ID = config.get('YOOMONEY_ID')
YOOMONEY_TOKEN = config.get('YOOMONEY_TOKEN')
YOOMONEY_RECEIVER = config.get('YOOMONEY_RECEIVER')


ANY_PAY_ID = config.get('ANY_PAY_ID')
ANY_PAY_API_KEY = config.get('ANY_PAY_API_KEY')
ANY_PAY_PROJECT_ID = config.get('ANY_PAY_PROJECT_ID')

STORE_ID = config.get('STORE_ID')
PUBLIC_KEY = config.get('PUBLIC_KEY')
PRIVATE_KEY = config.get('PRIVATE_KEY')
API_URL = config.get('API_URL')

API_LOGIN_CKASSA = config.get('API_LOGIN_CKASSA')
API_KEY_CKASSA = config.get('API_KEY_CKASSA')
SERV_CODE_CKASSA = config.get('SERV_CODE_CKASSA')

CRYPTOMUS_API_KEY = config.get('CRYPTOMUS_API_KEY')
CRYPTOMUS_API_KEY_PAYOUT = config.get('CRYPTOMUS_API_KEY_PAYOUT')
CRYPTOMUS_MERCHANT_ID = config.get('CRYPTOMUS_MERCHANT_ID')

API_KEY_ONLINESIM = config.get('API_KEY_ONLINESIM')

ON_SCHEDULE = config.get('ON_SCHEDULE')

CHECK_CHANNEL = config.get('CHECK_CHANNEL')

bot = Bot(
    token=API_TOKEN,
    default=DefaultBotProperties(parse_mode='HTML', link_preview_is_disabled=True)
)
storage = MemoryStorage()
dp = Dispatcher(storage=storage)


app\scheduler_instance.py
from apscheduler.schedulers.asyncio import AsyncIOScheduler

scheduler = AsyncIOScheduler()


app\__init__.py


app\db\database.py
from tortoise import Tortoise
from app import dependencies


async def init_db():
    await Tortoise.init(dependencies.DB_CONFIG, use_tz=True, timezone='Europe/Moscow')
    await Tortoise.generate_schemas()


async def close_db():
    await Tortoise.close_connections()


app\db\models.py
from datetime import datetime, timedelta, timezone
from enum import Enum, IntEnum
import pytz
from aiogram import types
from tortoise.models import Model
from tortoise import fields, timezone
from loguru import logger

class StatusResponse(IntEnum):
    STATUS_WAIT_CODE = 1
    STATUS_WAIT_RETRY = 2
    STATUS_WAIT_RESEND = 3
    STATUS_CANCEL = 4
    STATUS_OK = 5
    STATUS_HZ = 6


class ActivationResponse(Enum):
    ACCESS_READY = 1
    ACCESS_RETRY_GET = 2
    ACCESS_ACTIVATION = 3
    ACCESS_CANCEL = 4


class ActivationCode(Enum):
    SUCCESS = 1
    RETRY_GET = 3
    FINISH = 6
    CANCEL = 8


class PaymentMethod(Enum):
    LAVA = 'lava'
    PAYOK = 'payok'
    FREEKASSA = 'freekassa'
    YOOMONEY = 'yoomoney'
    ANYPAY = 'anypay'
    STREAMPAY = 'streampay'
    CKASSA = 'ckassa'
    CRYPTOMUS = 'cryptomus'
    STARS = 'stars'


class User(Model):
    class Meta:
        table = "users"
        table_description = "Users"
        ordering = ["id"]

    id: int = fields.BigIntField(pk=True)
    telegram_id: int = fields.BigIntField(unique=True)
    full_name: str = fields.CharField(max_length=128)
    username: str = fields.CharField(max_length=64, null=True)
    mention: str = fields.CharField(max_length=64, null=True)
    balance: float = fields.FloatField(default=0)
    ref_balance: float = fields.FloatField(default=0)
    total_ref_earnings: float = fields.FloatField(default=0)
    refer_id: int = fields.BigIntField(null=True)
    bonus_end_at: datetime = fields.DatetimeField(null=True)
    in_channel: bool = fields.BooleanField(default=False)
    last_check_in: datetime = fields.DatetimeField(null=True)
    created_at: datetime = fields.DatetimeField(auto_now_add=True)
    discount_used: bool = fields.BooleanField(null=True)
    last_request_time: datetime = fields.DatetimeField(null=False)
    disable_ref_notifications: bool = fields.BooleanField(default=False)

    @classmethod
    async def add_user(cls, user: types.User, refer: types.User = None):
        """
        Добавляет нового пользователя в базу данных.

        :param user: Объект пользователя из aiogram.
        :param refer: Объект пользователя, который пригласил нового пользователя (опционально).
        :return: Созданный объект пользователя.
        """
        current_time = datetime.now()  # Получаем текущее время в UTC
        new_user = await cls.create(
            telegram_id=user.id,
            full_name=user.full_name,
            username=user.username,
            mention=f'@{user.username}' if user.username else user.full_name,
            refer_id=refer.id if refer else None,
            last_request_time=current_time  # Устанавливаем текущее время в last_request_time
        )
        return new_user

    @classmethod
    async def get_user(cls, telegram_id: int):
        """
        Получает пользователя по его Telegram ID.

        :param telegram_id: Telegram ID пользователя.
        :return: Объект пользователя или None, если пользователь не найден.
        """
        return await cls.get_or_none(telegram_id=telegram_id)

    def __str__(self):
        return self.mention



class CountriesSmsActivate(Model):
    class Meta:
        table = "countries_sms_activate"
        table_description = "Countries"
        ordering = ["id"]

    id: int = fields.IntField(pk=True)
    country_id: int = fields.IntField(unique=True, index=True)
    name: str = fields.CharField(max_length=128, unique=True)

    def to_dict(self):
        """
        Преобразует объект страны в словарь.

        :return: Словарь с данными страны.
        """
        return {
            'country_id': self.country_id,
            'name': self.name
        }

    @classmethod
    async def add_country(cls, country_id: int, name: str):
        """
        Добавляет новую страну в базу данных.

        :param country_id: Уникальный идентификатор страны.
        :param name: Название страны.
        :return: Созданный объект страны.
        """
        country = await cls.create(
            country_id=country_id,
            name=name
        )
        return country

    @classmethod
    async def get_country_id_by_name(cls, name: str) -> int:
        """
        Получает уникальный идентификатор страны по её названию.

        :param name: Название страны.
        :return: Уникальный идентификатор страны или None, если страна не найдена.
        """
        country = await cls.get_or_none(name=name)
        if country:
            return country.country_id
        return 0

    @classmethod
    async def get_country_by_id(cls, country_id: int):
        """
        Получает страну по её уникальному идентификатору.

        :param country_id: Уникальный идентификатор страны.
        :return: Объект страны или None, если страна не найдена.
        """
        return await cls.get_or_none(country_id=country_id)

    @classmethod
    async def get_country_name_mapping(cls):
        """
        Получает словарь, где ключами являются идентификаторы стран, а значениями — их имена.

        :return: Словарь с идентификаторами стран в качестве ключей и именами стран в качестве значений.
        """
        countries = await cls.all()
        country_name_mapping = {country.country_id: country.name for country in countries}
        return country_name_mapping

    @classmethod
    async def get_country_id_list(cls):
        """
        Получает список всех идентификаторов стран.

        :return: Список идентификаторов стран.
        """
        return await cls.all().values_list('country_id', flat=True)

    @classmethod
    async def search_countries(cls, search_name: str):
        """
        Ищет страны по части названия.

        :param search_name: Часть названия страны для поиска.
        :return: Список имен стран, соответствующих поисковому запросу.
        """
        countries = await cls.filter(name__icontains=search_name).all()
        country_names = [country.name for country in countries]
        return country_names

    def __str__(self):
        return self.name


class CountriesOnlinesim(Model):
    class Meta:
        table = "countries_onlinesim"
        table_description = "Countries for Onlinesim"
        ordering = ["id"]

    id: int = fields.IntField(pk=True)
    country_id: int = fields.IntField(unique=True, index=True)
    name: str = fields.CharField(max_length=128, unique=True)

    @classmethod
    async def get_country_id_by_name(cls, name: str) -> int:
        """
        Получает уникальный идентификатор страны по её названию.

        :param name: Название страны.
        :return: Уникальный идентификатор страны или None, если страна не найдена.
        """
        country = await cls.get_or_none(name=name)
        if country:
            return country.country_id
        return 0

    @classmethod
    async def get_country_by_id(cls, country_id: int):
        """
        Получает страну по её уникальному идентификатору.

        :param country_id: Уникальный идентификатор страны.
        :return: Объект страны или None, если страна не найдена.
        """
        return await cls.get_or_none(country_id=country_id)

    @classmethod
    async def get_country_from_country_by_id(cls, country_id: int):
        """
        Получает страну по её уникальному идентификатору из CountryOnlinesim.

        :param country_id: Уникальный идентификатор страны.
        :return: Объект модели Country или None, если страна не найдена.
        """
        country_onlinesim = await cls.get_or_none(country_id=country_id)
        if not country_onlinesim:
            return None  # Страна не найдена в CountryOnlinesim

        # Ищем страну по имени в таблице Country
        country = await CountriesSmsActivate.get_or_none(name=country_onlinesim.name)
        return country

    @classmethod
    async def get_country_onlinesim(cls, country_id: int):
        """
        Получает страну по её уникальному идентификатору из CountryOnlinesim.

        :param country_id: Уникальный идентификатор страны.
        :return: Объект модели CountryOnlinesim или None, если страна не найдена.
        """
        country_onlinesim = await cls.get_or_none(country_id=country_id)
        if not country_onlinesim:
            return None  # Страна не найдена в CountryOnlinesim

        return country_onlinesim

    @classmethod
    async def get_country_name_mapping(cls):
        """
        Получает словарь, где ключами являются идентификаторы стран, а значениями — их имена.

        :return: Словарь с идентификаторами стран в качестве ключей и именами стран в качестве значений.
        """
        countries = await cls.all()
        country_name_mapping = {country.country_id: country.name for country in countries}
        return country_name_mapping

    @classmethod
    async def get_country_id_list(cls):
        """
        Получает список всех идентификаторов стран.

        :return: Список идентификаторов стран.
        """
        return await cls.all().values_list('country_id', flat=True)

    @classmethod
    async def search_countries(cls, search_name: str):
        """
        Ищет страны по части названия.

        :param search_name: Часть названия страны для поиска.
        :return: Список имен стран, соответствующих поисковому запросу.
        """
        countries = await cls.filter(name__icontains=search_name).all()
        country_names = [country.name for country in countries]
        return country_names

    def __str__(self):
        return self.name


class PriceOnlinesim(Model):
    class Meta:
        table = "price_onlinesim"
        table_description = "Services by Country for Onlinesim"
        ordering = []

    id = fields.IntField(pk=True)  # ID сервиса
    country = fields.IntField(max_length=255, null=False)  # Название страны без связи
    price = fields.DecimalField(max_digits=10, decimal_places=2)  # Цена сервиса
    name = fields.CharField(max_length=255, null=False)  # Название сервиса
    code = fields.CharField(max_length=50, null=False)  # Короткое название сервиса

    @classmethod
    async def add_service(cls, country: int, price: float, name: str, code: str):
        service = await cls.create(
            country=country,
            price=price,
            name=name,
            code=code
        )
        return service

    @classmethod
    async def get_services_by_name(cls, name: str):
        return await cls.select().where(cls.name == name).dicts()

    @classmethod
    async def get_code_by_service_name(cls, name: str):
        service = await cls.get_or_none(name=name)
        return service.code if service else None

    @classmethod
    async def update_service(cls, country: str, name: str, price: float):
        service = await cls.get_or_none(name=name, country=country)
        if service:
            service.price = price
            await service.save()

    @classmethod
    async def get_price_by_country_and_service(cls, country: str, name: str):
        service = await cls.get_or_none(country=country, name=name)
        return service.price if service else None

    @classmethod
    async def get_service_data(cls, code: str) -> dict:
        services = await cls.filter(code=code).all()
        country_name_mapping = await CountriesOnlinesim.get_country_name_mapping()
        result = {}
        for service in services:
            country_name = country_name_mapping.get(service.country)
            if country_name:
                result[country_name] = service.price
        return result

    @classmethod
    async def get_service(cls, service_code: str, country_id: int):
        return await cls.get_or_none(code=service_code, country=country_id)

    @classmethod
    async def get_all_service_names(cls):
        return await cls.all().distinct().values_list("name", flat=True)

    @classmethod
    async def get_all_services(cls):
        services = await cls.all().order_by().distinct().values("code", "name")
        return {"services": list(services)}




class ServicesSmsActivate(Model):
    class Meta:
        table = "services_sms_activate"
        table_description = "Services"
        ordering = ["id"]

    id: int = fields.IntField(pk=True)
    code: str = fields.CharField(max_length=128, unique=True, index=True)
    name: str = fields.CharField(max_length=128, null=True)
    search_names: str = fields.TextField(null=True)
    used_count: int = fields.IntField(default=0)

    @classmethod
    async def add_service(cls, code: str, name: str, search_names: str):
        """
        Добавляет новый сервис в базу данных.

        :param code: Уникальный код сервиса.
        :param name: Название сервиса.
        :param search_names: Поисковые названия сервиса.
        :return: Созданный объект сервиса.
        """
        service = await cls.create(
            code=code,
            name=name,
            search_names=search_names
        )
        return service

    @classmethod
    async def get_service(cls, code: str):
        """
        Получает сервис по его уникальному коду.

        :param code: Уникальный код сервиса.
        :return: Объект сервиса или None, если сервис не найден.
        """
        return await cls.get_or_none(code=code)

    @classmethod
    async def search_service(cls, search_name: str):
        """
        Ищет сервисы по части названия.

        :param search_name: Часть названия сервиса для поиска.
        :return: Список объектов сервисов, соответствующих поисковому запросу.
        """
        return await cls.filter(search_names__icontains=search_name).all()

    @classmethod
    async def get_codes_list(cls):
        """
        Получает список всех кодов сервисов.

        :return: Список кодов сервисов.
        """
        return await cls.all().values_list('code', flat=True)

    @classmethod
    async def get_services(cls):
        """
        Получает список всех названий сервисов.

        :return: Список названий сервисов.
        """
        services = await cls.all().values('code', 'name')
        return {"services": list(services)}

    @classmethod
    async def get_all_services_data(cls):
        """
        Получает все данные по всем сервисам.

        :return: Список словарей с данными всех сервисов.
        """
        services = await cls.all().values('id', 'code', 'name', 'search_names')
        return {"services": list(services)}

    @classmethod
    async def normalize_search_names(cls):
        """
        Приводит все строки search_names к нижнему регистру и записывает обратно в базу данных.
        """
        services = await cls.all()
        for service in services:
            if service.search_names:
                normalized_search_names = service.search_names.lower()
                service.search_names = normalized_search_names
                await service.save()

    @classmethod
    async def update_services(cls, services_data: list):
        """
        Обновляет сервисы в базе данных на основе предоставленного списка данных.

        :param services_data: Список словарей с данными для обновления сервисов.
        :return: Список обновленных объектов сервисов и список id объектов, которые не были найдены.
        """
        updated_services = []

        for data in services_data:
            # Проверяем, существует ли сервис с таким code
            existing_service = await cls.get_or_none(code=data['code'])

            if existing_service:
                # Обновляем существующий сервис
                existing_service.name = data['name']
                existing_service.search_names = data['search_names']
                await existing_service.save()
                updated_services.append(existing_service)
            else:
                # Создаем новый объект сервиса, если code не найден
                new_service = cls(
                    code=data['code'],
                    name=data['name'],
                    search_names=data['search_names'],
                )
                await new_service.save()

    @classmethod
    async def get_code_by_name(cls, name: str):
        """
        Получает уникальный код сервиса по его имени.

        :param name: Название сервиса для поиска.
        :return: Код сервиса или None, если сервис не найден.
        """
        service = await cls.get_or_none(name=name)
        if service:
            return service.code
        return None

    @classmethod
    async def get_service_by_id(cls, service_id: int):
        """
        Получает строку всех значений по-указанному id.

        :param service_id: ID сервиса.
        :return: Строка со всеми значениями сервиса или None, если сервис не найден.
        """
        service = await cls.get_or_none(id=service_id)
        if service:
            return f"ID: {service.id}, Code: {service.code}, Name: {service.name}, Search Names: {service.search_names}"
        return None

    @classmethod
    async def get_service_name_by_id(cls, service_id: int):
        """
        Получает название сервиса по его ID.

        :param service_id: ID сервиса.
        :return: Название сервиса или None, если сервис не найден.
        """
        service = await cls.get_or_none(id=service_id)
        if service:
            return service.name
        return None


class ServicesOnlinesim(Model):
    class Meta:
        table = "services_onlinesim"
        table_description = "Services for Onlinesim"
        ordering = ["id"]

    id: int = fields.IntField(pk=True)
    code: str = fields.CharField(max_length=128, unique=True, index=True)
    name: str = fields.CharField(max_length=128, null=True)
    search_names: str = fields.TextField(null=True)

    @classmethod
    async def add_service(cls, code: str, name: str, search_names: str):
        """
        Добавляет новый сервис в базу данных.

        :param code: Уникальный идентификатор сервиса.
        :param name: Название сервиса.
        :param search_names: Поисковые названия сервиса.
        :return: Созданный объект сервиса.
        """
        service = await cls.create(
            code=code,
            name=name,
            search_names=search_names
        )
        return service

    @classmethod
    async def get_service(cls, code: str):
        """
        Получает сервис по его уникальному идентификатору.

        :param code: Уникальный идентификатор сервиса.
        :return: Объект сервиса или None, если сервис не найден.
        """
        return await cls.get_or_none(code=code)

    @classmethod
    async def search_service(cls, search_name: str):
        """
        Ищет сервисы по части названия.

        :param search_name: Часть названия сервиса для поиска.
        :return: Список объектов сервисов, соответствующих поисковому запросу.
        """
        return await cls.filter(search_names__icontains=search_name).all()

    @classmethod
    async def get_codes_list(cls):
        """
        Получает список всех идентификаторов сервисов.

        :return: Список идентификаторов сервисов.
        """
        return await cls.all().values_list('code', flat=True)

    @classmethod
    async def get_services(cls):
        """
        Получает список всех названий сервисов.

        :return: Список названий сервисов.
        """
        services = await cls.all().values('code', 'name')
        return {"services": list(services)}

    @classmethod
    async def get_all_services_data(cls):
        """
        Получает все данные по всем сервисам.

        :return: Список словарей с данными всех сервисов.
        """
        services = await cls.all().values('id', 'code', 'name', 'search_names')
        return {"services": list(services)}

    @classmethod
    async def normalize_search_names(cls):
        """
        Приводит все строки search_names к нижнему регистру и записывает обратно в базу данных.
        """
        services = await cls.all()
        for service in services:
            if service.search_names:
                normalized_search_names = service.search_names.lower()
                service.search_names = normalized_search_names
                await service.save()

    @classmethod
    async def update_services(cls, services_data: list):
        """
        Обновляет сервисы в базе данных на основе предоставленного списка данных.

        :param services_data: Список словарей с данными для обновления сервисов.
        """
        updated_services = []

        for data in services_data:
            # Проверяем, существует ли сервис с таким code
            existing_service = await cls.get_or_none(code=data['code'])

            if existing_service:
                # Обновляем существующий сервис
                existing_service.name = data['name']
                existing_service.search_names = data['search_names']
                await existing_service.save()
                updated_services.append(existing_service)
            else:
                # Создаем новый объект сервиса, если code не найден
                new_service = cls(
                    code=data['code'],
                    name=data['name'],
                    search_names=data['search_names'],
                )
                await new_service.save()

    @classmethod
    async def get_code_by_name(cls, name: str):
        """
        Получает уникальный идентификатор сервиса по его имени.

        :param name: Название сервиса для поиска.
        :return: Идентификатор сервиса или None, если сервис не найден.
        """
        service = await cls.get_or_none(name=name)
        if service:
            return service.code
        return None

    @classmethod
    async def get_service_by_id(cls, service_id: int):
        """
        Получает строку всех значений по указанному id.

        :param service_id: ID сервиса.
        :return: Строка со всеми значениями сервиса или None, если сервис не найден.
        """
        service = await cls.get_or_none(id=service_id)
        if service:
            return f"ID: {service.id}, Code: {service.code}, Name: {service.name}, Search Names: {service.search_names}"
        return None

    @classmethod
    async def get_service_name_by_id(cls, service_id: int):
        """
        Получает название сервиса по его ID.

        :param service_id: ID сервиса.
        :return: Название сервиса или None, если сервис не найден.
        """
        service = await cls.get_or_none(id=service_id)
        if service:
            return service.name
        return None



class Mail(Model):
    class Meta:
        table = "mails"
        table_description = "Mails"
        ordering = ["id"]

    id: int = fields.BigIntField(pk=True)
    user: User = fields.ForeignKeyField('models.User', related_name='mails')
    email: str = fields.CharField(max_length=128, unique=True, index=True)
    old_messages_id: list = fields.JSONField(default=[])
    is_paid_mail: bool = fields.BooleanField(default=False)
    is_active: bool = fields.BooleanField(default=True)
    created_at: datetime = fields.DatetimeField(auto_now_add=True)
    expire_at: datetime = fields.DatetimeField()
    notification_sent: bool = fields.BooleanField(default=False)
    token: str = fields.CharField(max_length=512, null=True)
    is_free_week = fields.BooleanField(default=False)
    days = fields.IntField(default=0)  # Длительность аренды в днях

    @classmethod
    async def add_mail(cls, user: User, email: str, token: str = None):
        """
        Добавляет новую почту в базу данных.

        :param user: Объект пользователя, которому принадлежит почта.
        :param email: Адрес электронной почты.
        :param token: Токен для почты (по умолчанию None).
        :return: Созданный объект почты.
        """
        expire_at = timezone.now() + timedelta(minutes=30)
        mail = await cls.create(
            user=user,
            email=email,
            expire_at=expire_at,
            token=token
        )
        return mail


    @classmethod
    async def get_mail(cls, mail_id: str):
        """
        Получает почту по её уникальному идентификатору.

        :param mail_id: Уникальный идентификатор почты.
        :return: Объект почты или None, если почта не найдена.
        """
        return await cls.get_or_none(id=mail_id)

    @classmethod
    async def get_user_mails(cls, user: User):
        """
        Получает все почты пользователя.

        :param user: Объект пользователя.
        :return: Список объектов почт, принадлежащих пользователю.
        """
        return await cls.filter(user=user).all()

    @classmethod
    async def get_expired_mails(cls):
        """
        Получает все истекшие почты.

        :return: Список объектов истекших почт.
        """
        return await cls.filter(expire_at__lte=timezone.now(), is_active=True).all()


class Letter(Model):
    class Meta:
        table = "letters"
        table_description = "Letters"
        ordering = ["id"]

    id: int = fields.BigIntField(pk=True)
    user: User = fields.ForeignKeyField('models.User', related_name='letters')
    mail: Mail = fields.ForeignKeyField('models.Mail', related_name='letters')
    text: str = fields.TextField()
    created_at: datetime = fields.DatetimeField(auto_now_add=True)

    @classmethod
    async def add_letter(cls, user: User, mail: Mail, text: str):
        """
        Добавляет новое письмо в базу данных.

                :param user: Объект пользователя, который отправил письмо.
                :param mail: Объект почты, к которой относится письмо.
                :param text: Текст письма.
                :return: Созданный объект письма.
                """
        letter = await cls.create(
            user=user,
            mail=mail,
            text=text
        )
        return letter

    @classmethod
    async def get_letter(cls, letter_id: int):
        """
        Получает письмо по его уникальному идентификатору.

        :param letter_id: Уникальный идентификатор письма.
        :return: Объект письма или None, если письмо не найдено.
        """
        return await cls.get_or_none(id=letter_id)

    @classmethod
    async def get_user_letters(cls, user: User):
        """
        Получает все письма пользователя.

        :param user: Объект пользователя.
        :return: Список объектов писем, принадлежащих пользователю.
        """
        return await cls.filter(user=user).all()


class Activation(Model):
    class Meta:
        table = "activations"
        table_description = "Activations"
        ordering = ["id"]

    id: int = fields.BigIntField(pk=True)
    user: User = fields.ForeignKeyField('models.User', related_name='activations')
    activation_id: int = fields.BigIntField(unique=True, index=True)
    country: CountriesSmsActivate = fields.ForeignKeyField('models.CountriesSmsActivate', related_name='activations')
    service: ServicesSmsActivate = fields.ForeignKeyField('models.ServicesSmsActivate', related_name='activations', null=True)
    service_2: ServicesOnlinesim = fields.ForeignKeyField('models.ServicesOnlinesim', related_name='activations', null=True)
    cost: float = fields.FloatField()
    phone_number: str = fields.CharField(max_length=32)
    sms_text: str = fields.TextField(null=True)
    status: StatusResponse = fields.IntEnumField(StatusResponse, default=StatusResponse.STATUS_WAIT_CODE)
    created_at: datetime = fields.DatetimeField(auto_now_add=True)
    activation_expire_at: datetime = fields.DatetimeField(null=True)

    @classmethod
    async def add_activation_sms_activate(cls, user: User, activation_id: int, country: CountriesSmsActivate, cost: float,
                                          service: ServicesSmsActivate, phone_number: str, activation_expire_at: datetime):
        """
        Добавляет новую активацию в базу данных.

        :param user: Объект пользователя, который инициировал активацию.
        :param activation_id: Уникальный идентификатор активации.
        :param country: Объект страны, связанной с активацией.
        :param cost: Стоимость активации.
        :param service: Объект сервиса, связанного с активацией.
        :param phone_number: Номер телефона, используемый для активации.
        :param activation_expire_at: Время истечения активации.
        :return: Созданный объект активации.
        """
        activation = await cls.create(
            user=user,
            activation_id=activation_id,
            country=country,
            service=service,
            cost=cost,
            phone_number=phone_number,
            activation_expire_at=activation_expire_at
        )
        return activation

    @classmethod
    async def add_activation_onlinesim(cls, user: User, activation_id: int, country: CountriesSmsActivate,
                                          cost: float,
                                          service_2: ServicesOnlinesim, phone_number: str,
                                          activation_expire_at: datetime):
        activation = await cls.create(
            user=user,
            activation_id=activation_id,
            country=country,
            service_2=service_2,
            cost=cost,
            phone_number=phone_number,
            activation_expire_at=activation_expire_at
        )
        return activation


    @classmethod
    async def get_activation(cls, activation_id: int):
        """
        Получает активацию по её уникальному идентификатору.

        :param activation_id: Уникальный идентификатор активации.
        :return: Объект активации или None, если активация не найдена.
        """
        return await cls.get_or_none(activation_id=activation_id)

    @classmethod
    async def get_user_activations(cls, user: User):
        """
        Получает все активации пользователя.

        :param user: Объект пользователя.
        :return: Список объектов активаций, принадлежащих пользователю.
        """
        return await cls.filter(user=user).all()

    @classmethod
    async def get_expired_activations(cls):
        """
        Получает все истекшие активации (аренды, чей срок истек).

        :return: Список объектов истекших аренд.
        """
        utc_now = datetime.now(pytz.timezone("Europe/Moscow"))
        return await cls.filter(activation_expire_at__lte=utc_now, status=StatusResponse.STATUS_WAIT_CODE).all().prefetch_related('user')

    @classmethod
    async def get_active_activations(cls):
        """
        Получает все активные активации.

        :return: Список объектов активных активаций.
        """
        # return await cls.filter(activation_expire_at__gt=timezone.now()).all()

        return await cls.filter(activation_expire_at__gt=timezone.now()).select_related("service_2").all()

    @classmethod
    async def get_active_activation(cls, user_id: int):
        """
        Получает активную активацию пользователя по его user_id, если она активна.

        :param user_id: Идентификатор пользователя.
        :return: Объект активации пользователя, если она активна, или None, если активация не найдена или истекла.
        """
        # Получаем текущее время в UTC
        utc_now = datetime.now(pytz.timezone("Europe/Moscow"))

        # Получаем все активные активации пользователя
        active_activations = await cls.filter(user_id=user_id, activation_expire_at__gt=utc_now).all()

        # Если есть активные активации, возвращаем их
        if active_activations:
            return active_activations[-1]

        # Если активных активаций нет, возвращаем None
        return None

    @classmethod
    async def delete_user_activations(cls, user_id: int):
        """
        Удаляет все активации пользователя по его user_id.

        :param user_id: Идентификатор пользователя.
        :return: Количество удалённых записей.
        """
        deleted_count = await cls.filter(user_id=user_id).delete()
        return deleted_count

    async def get_service_2_name(self) -> str | None:
        """
        Получает имя сервиса из ServicesOnlinesim.

        :return: Название сервиса или None, если сервис отсутствует.
        """
        await self.refresh_from_db()  # Перегружаем объект из БД
        await self.fetch_related("service_2")  # Загружаем связь

        return self.service_2.name if isinstance(self.service_2, ServicesOnlinesim) else None

    @classmethod
    async def get_last_rented_info(cls, user_id: int):
        """
        Получает последнюю аренду пользователя, включая номер, дату аренды, имя сервиса и страну.

        :param user_id: Идентификатор пользователя.
        :return: Кортеж с последней арендой: (номер телефона, дата аренды, имя сервиса, название страны) или None, если аренда не найдена.
        """

        # Получаем все активные активации пользователя, отсортированные по дате окончания активации (по убыванию)
        active_activations = await cls.filter(user_id=user_id, status=StatusResponse.STATUS_OK).all()

        # Если есть активные активации, берем первую (самую последнюю)
        if active_activations:
            last_activation = active_activations[-1]

            await last_activation.fetch_related('country', 'service', 'service_2')

            country_name = last_activation.country.name

            try:
                service_name = last_activation.service.name
            except Exception:
                service_name = last_activation.service_2.name

            # Форматируем дату аренды в нужный формат
            formatted_date = last_activation.activation_expire_at.strftime("%Y-%m-%d %H:%M")

            return last_activation.phone_number, formatted_date, service_name, country_name

        # Если нет активных арендуемых данных
        return None

class Payment(Model):
    class Meta:
        # Метаданные для модели Payment
        table = "payments"  # Название таблицы в базе данных
        table_description = "Payments"  # Описание таблицы
        ordering = ["id"]  # Поле для сортировки записей по умолчанию

    # Поля модели Payment
    id: int = fields.BigIntField(pk=True)  # Уникальный идентификатор платежа (первичный ключ)
    user: User = fields.ForeignKeyField('models.User', related_name='payments')  # Связь с моделью User (внешний ключ)
    method: PaymentMethod = fields.CharEnumField(PaymentMethod, max_length=16)  # Метод оплаты (перечисление)
    amount: float = fields.FloatField()  # Сумма платежа
    order_id: str = fields.CharField(max_length=128, unique=True, index=True,
                                     null=True)  # Идентификатор заказа (уникальный)
    invoice_id: str = fields.CharField(max_length=128, unique=True, index=True,
                                       null=True)  # Идентификатор счета (уникальный)
    continue_data: dict = fields.JSONField(null=True)  # Дополнительные данные для продолжения платежа (JSON)
    is_success: bool = fields.BooleanField(default=False)  # Флаг успешности платежа
    created_at: datetime = fields.DatetimeField(
        auto_now_add=True)  # Дата и время создания записи (автоматически устанавливается при создании)

    @classmethod
    async def create_payment(cls, user: User, method: PaymentMethod, amount: float, continue_data: dict = None):
        """
        Создает новый платеж в базе данных.

        :param user: Объект пользователя, который инициировал платеж.
        :param method: Метод оплаты.
        :param amount: Сумма платежа.
        :param continue_data: Дополнительные данные для продолжения платежа (опционально).
        :return: Созданный объект платежа.
        """
        payment = await cls.create(
            user=user,
            method=method,
            amount=amount,
            continue_data=continue_data
        )
        return payment

    @classmethod
    async def get_last_payment_amount(cls, user_id: int) -> float:
        """
        Возвращает сумму последнего платежа для пользователя по его user_id.

        :param user_id: ID пользователя.
        :return: Сумма последнего платежа или None, если платежей нет.
        """
        last_payment = await cls.filter(user_id=user_id).order_by('-created_at').first()
        return last_payment.amount if last_payment else None

    @classmethod
    async def get_payments(cls, method, hours=5):
        """
        Получает все платежи, выполненные через указанный метод, которые не были успешными и были созданы в последние 'hours' часов.

        :param method: Метод платежной системы (PaymentMethod.LAVA, PaymentMethod.FREEKASSA, PaymentMethod.YOOMONEY)
        :param hours: Количество часов в прошлом, за которые нужно получить платежи (по умолчанию 5)
        :return: Список объектов платежей.
        """
        return await cls.filter(
            method=method,
            is_success=False,
            created_at__gt=timezone.now() - timedelta(hours=hours)
        ).all().prefetch_related('user')

    @classmethod
    async def get_lava_payments(cls):
        """
        Получает все платежи, выполненные через метод LAVA, которые не были успешными и были созданы в последние 5 часов

        :return: Список объектов платежей.
        """
        return await cls.filter(method=PaymentMethod.LAVA, is_success=False,
                                created_at__gt=timezone.now() - timedelta(hours=5),
                                order_id__isnull=False).all().prefetch_related('user')

    @classmethod
    async def get_freekassa_payments(cls):
        """
        Получает все платежи, выполненные через метод FREEKASSA, которые не были успешными и были созданы в последние 5 часов

        :return: Список объектов платежей.
        """
        return await cls.filter(method=PaymentMethod.FREEKASSA, is_success=False,
                                created_at__gt=timezone.now() - timedelta(hours=5)).all().prefetch_related('user')

    @classmethod
    async def get_yoomoney_payments(cls):
        """
        Получает все платежи, выполненные через метод YOOMONEY, которые не были успешными и были созданы в последние 5 часов

        :return: Список объектов платежей.
        """
        return await cls.filter(method=PaymentMethod.YOOMONEY, is_success=False,
                                created_at__gt=timezone.now() - timedelta(hours=5)).all().prefetch_related('user')

    @classmethod
    async def get_anypay_payments(cls):
        """
        Получает все платежи, выполненные через метод ANYPAY, которые не были успешными и были созданы в последние 5 часов

        :return: Список объектов платежей.
        """
        return await cls.filter(method=PaymentMethod.ANYPAY, is_success=False,
                                created_at__gt=timezone.now() - timedelta(hours=5)).all().prefetch_related('user')

    @classmethod
    async def get_cryptomus_payments(cls):
        """
        Получает все платежи, выполненные через метод cryptomus, которые не были успешными и были созданы в последние 1 час

        :return: Список объектов платежей.
        """
        return await cls.filter(method=PaymentMethod.CRYPTOMUS, is_success=False,
                                created_at__gt=timezone.now() - timedelta(hours=1)).all().prefetch_related('user')

    @classmethod
    async def get_streampay_payments(cls):
        """
        Получает все платежи, выполненные через метод STREAMPAY, которые не были успешными и были созданы в последние 5 часов

        :return: Список объектов платежей.
        """
        return await cls.filter(method=PaymentMethod.STREAMPAY, is_success=False,
                                created_at__gt=timezone.now() - timedelta(hours=5)).all().prefetch_related('user')

    @classmethod
    async def get_ckassa_payments(cls):
        """
        Получает все платежи, выполненные через метод CKASSA, которые не были успешными и были созданы в последние 5 часов

        :return: Список объектов платежей.
        """
        return await cls.filter(method=PaymentMethod.CKASSA, is_success=False,
                                created_at__gt=timezone.now() - timedelta(hours=5)).all().prefetch_related('user')


class Withdraw(Model):
    class Meta:
        table = "withdraws"
        table_description = "Withdraws"
        ordering = ["id"]

    id: int = fields.BigIntField(pk=True)
    user: User = fields.ForeignKeyField('models.User', related_name='withdraws')
    requisites: str = fields.TextField()
    amount: float = fields.FloatField()
    is_success: bool = fields.BooleanField(null=True)
    created_at: datetime = fields.DatetimeField(auto_now_add=True)

    @classmethod
    async def add_withdraw(cls, user: User, requisites: str, amount: float):
        """
        Добавляет новый запрос на вывод средств в базу данных.

        :param user: Объект пользователя, который инициировал запрос на вывод средств.
        :param requisites: Реквизиты для вывода средств.
        :param amount: Сумма для вывода.
        :return: Созданный объект запроса на вывод средств.
        """
        withdraw = await cls.create(
            user=user,
            requisites=requisites,
            amount=amount
        )
        return withdraw

    @classmethod
    async def get_withdraw(cls, withdraw_id: int):
        """
        Получает запрос на вывод средств по его уникальному идентификатору.

        :param withdraw_id: Уникальный идентификатор запроса на вывод средств.
        :return: Объект запроса на вывод средств или None, если запрос не найден.
        """
        return await cls.get_or_none(id=withdraw_id)


class PaymentLink(Model):
    class Meta:
        table = "payment_links"
        table_description = "PaymentLinks"
        ordering = ["id"]

    id: int = fields.BigIntField(pk=True)
    payment_link_id: str = fields.CharField(max_length=32, unique=True, index=True)
    user_id_list: list = fields.JSONField(default=[])
    amount: float = fields.FloatField()
    limit: int = fields.IntField()
    created_at: datetime = fields.DatetimeField(auto_now_add=True)

    @classmethod
    async def add_payment_link(cls, amount: float, limit: int, payment_link_id: str):
        """
        Добавляет новую ссылку на оплату в базу данных.

        :param amount: Сумма для оплаты.
        :param limit: Лимит использования ссылки.
        :param payment_link_id: Уникальный идентификатор ссылки на оплату.
        :return: Созданный объект ссылки на оплату.
        """
        payment_link = await cls.create(
            amount=amount,
            limit=limit,
            payment_link_id=payment_link_id
        )
        return payment_link

    @classmethod
    async def get_payment_link(cls, payment_link_id: str):
        """
        Получает ссылку на оплату по её уникальному идентификатору.

        :param payment_link_id: Уникальный идентификатор ссылки на оплату.
        :return: Объект ссылки на оплату или None, если ссылка не найдена.
        """
        return await cls.get_or_none(payment_link_id=payment_link_id)

    @classmethod
    async def get_payment_links(cls):
        """
        Получает все ссылки на оплату.

        :return: Список объектов ссылок на оплату.
        """
        return await cls.all()


class Rent(Model):
    class Meta:
        table = "rents"
        table_description = "Rents"
        ordering = ["id"]

    id: int = fields.BigIntField(pk=True)
    user: "User" = fields.ForeignKeyField('models.User', related_name='rents')
    rent_id: int = fields.BigIntField(unique=True, index=True)
    country: "CountriesOnlinesim" = fields.ForeignKeyField("models.CountriesOnlinesim", related_name='rents')
    cost: float = fields.FloatField()
    phone_number: str = fields.CharField(max_length=32)
    sms_text: str = fields.TextField(null=True)
    status: StatusResponse = fields.IntEnumField(StatusResponse, default=StatusResponse.STATUS_WAIT_CODE)
    created_at: datetime = fields.DatetimeField(auto_now_add=True)
    rent_expire_at: datetime = fields.DatetimeField(null=True)
    autorenew: bool = fields.BooleanField(default=False)  # Поле для автопродления
    is_canceled: bool = fields.BooleanField(default=False)  # Поле для отслеживания отмены аренды
    is_notified: bool = fields.BooleanField(default=False)  # Поле для отслеживания отправки уведомления
    days: int = fields.IntField(default=0)  # Поле для отслеживания количества дней аренды
    purchase_count: int = fields.IntField(default=0)  # Поле для отслеживания количества покупок
    refund_processed = fields.BooleanField(default=False)

    @classmethod
    async def add_rent(cls, user: "User", rent_id: int, country: "CountriesOnlinesim", cost: float,
                       phone_number: str, rent_expire_at: datetime, sms_text: str = "",
                       autorenew: bool = False, is_canceled: bool = False, is_notified: bool = False, days: int = 0,
                       purchase_count: int = 0):
        """
        Добавляет новую аренду в базу данных.

        :param user: Объект пользователя, который инициировал аренду.
        :param rent_id: Уникальный идентификатор аренды.
        :param country: Объект страны, связанной с арендой.
        :param cost: Стоимость аренды.
        :param phone_number: Номер телефона, используемый для аренды.
        :param sms_text: СМС сообщение.
        :param rent_expire_at: Время истечения аренды.
        :param autorenew: Статус автопродления (по умолчанию False).
        :param is_canceled: Статус отмены аренды (по умолчанию False).
        :param is_notified: Статус уведомления (по умолчанию False).
        :param days: Количество дней аренды (по умолчанию 0).
        :param purchase_count: Счетчик покупок (по умолчанию 0).
        :return: Созданный объект аренды.
        """
        rent, created = await cls.update_or_create(
            rent_id=rent_id,  # Параметр для поиска аренды
            defaults={  # Параметры для обновления или создания аренды
                "user": user,
                "country": country,
                "cost": cost,
                "phone_number": phone_number,
                "sms_text": sms_text,
                "rent_expire_at": rent_expire_at,
                "autorenew": autorenew,
                "is_canceled": is_canceled,
                "is_notified": is_notified,
                "days": days,  # Устанавливаем значение нового поля
                "purchase_count": purchase_count,  # Устанавливаем значение счетчика покупок
            }
        )
        return rent


    @classmethod
    async def get_rent(cls, id: int):
        """
        Получает аренду по её уникальному идентификатору.

        :param id: Уникальный идентификатор аренды.
        :return: Объект аренды или None, если аренда не найдена.
        """
        return await cls.get_or_none(id=id).select_related('country')

    @classmethod
    async def get_user_rents(cls, user: "User"):
        """
        Получает все аренды пользователя.

        :param user: Объект пользователя.
        :return: Список объектов аренд, принадлежащих пользователю.
        """
        return await cls.filter(user=user).all()

    @classmethod
    async def get_expired_rents(cls):
        """
        Получает все истекшие аренды.

        :return: Список объектов истекших аренд.
        """
        utc_now = datetime.now(pytz.timezone("Europe/Moscow"))
        return await cls.filter(rent_expire_at__lte=utc_now,
                                status=StatusResponse.STATUS_WAIT_CODE).all().prefetch_related('user')

    @classmethod
    async def get_active_rent(cls, user_id: int):
        """
        Получает активные аренды пользователя по его user_id, если она активна и не отменена.

        :param user_id: Идентификатор пользователя.
        :return: Объекты аренды пользователя, если она активна и не отменена, или None, если аренда не найдена, истекла или отменена.
        """

        # Фильтруем аренды по user_id, дате окончания аренды и статусу отмены
        utc_now = datetime.now(pytz.timezone("Europe/Moscow"))
        active_rents = await cls.filter(user_id=user_id, rent_expire_at__gt=utc_now, is_canceled=False).all()

        if active_rents:
            return active_rents
        return None

    @classmethod
    async def delete_user_rents(cls, user_id: int):
        """
        Удаляет все аренды пользователя по его user_id.

        :param user_id: Идентификатор пользователя.
        :return: Количество удалённых записей.
        """
        deleted_count = await cls.filter(user_id=user_id).delete()
        return deleted_count

    @classmethod
    async def is_autorenew_enabled(cls, rent_id: int) -> bool:
        """
        Проверяет, включено ли автопродление для указанной аренды.

        :param rent_id: Уникальный идентификатор аренды.
        :return: True, если автопродление включено, иначе False.
        """
        rent = await cls.get_or_none(rent_id=rent_id)
        if rent:
            return rent.autorenew
        return False

    @classmethod
    async def get_country_by_rent(cls, id: int) -> "CountriesOnlinesim":
        """
        Получает объект CountryOnlinesim, связанный с указанной арендой.

        :param id: Уникальный идентификатор аренды.
        :return: Объект CountryOnlinesim, связанный с арендой, или None, если аренда не найдена.
        """
        rent = await cls.get_or_none(id=id).prefetch_related('country')
        return rent.country if rent else None

    @classmethod
    async def get_all_active_rents(cls):
        """
        Получает список всех активных аренд.

        :return: Список объектов активных аренд.
        """
        utc_now = datetime.now(pytz.timezone("Europe/Moscow"))
        return await cls.filter(rent_expire_at__gte=utc_now).all().prefetch_related('user')

    @classmethod
    async def get_expired_activations(cls):
        """
        Получает все истекшие активации.

        :return: Список объектов истекших активаций.
        """
        utc_now = datetime.now(pytz.timezone("Europe/Moscow"))
        return await cls.filter(rent_expire_at__lt=utc_now, status=StatusResponse.STATUS_WAIT_CODE).all().prefetch_related('user')

    @classmethod
    async def is_waiting_code(cls, rent_id: int) -> bool:
        """
        Проверяет, находится ли аренда в статусе STATUS_WAIT_CODE.

        :param rent_id: ID аренды.
        :return: True, если статус STATUS_WAIT_CODE, иначе False.
        """
        rent = await cls.get_or_none(rent_id=rent_id)
        if rent and rent.status == StatusResponse.STATUS_WAIT_CODE:
            return True
        return False

    @classmethod
    async def get_rents_ending_soon(cls):
        """
        Получает список аренд, для которых срок истекает ровно через 5 часов,
        и уведомление еще не было отправлено.
        """
        utc_now = datetime.now(pytz.timezone("Europe/Moscow"))
        target_time = utc_now + timedelta(hours=5)

        # Фильтруем аренды, срок действия которых заканчивается через 5 часов, и уведомление еще не отправлено
        return await cls.filter(
            rent_expire_at__lte=target_time,
            rent_expire_at__gt=utc_now,
            is_canceled=False,
            is_notified=False,
            sms_text__isnull=False
        ).exclude(
            sms_text=""
        ).all().prefetch_related("user", "country")

    @classmethod
    async def get_rents_expire(cls):
        """
        Получает список аренд, для которых срок истекает ровно через 2 часа,
        и уведомление еще не было отправлено.
        """
        utc_now = datetime.now(pytz.timezone("Europe/Moscow"))
        target_time = utc_now + timedelta(hours=2)

        # Фильтруем аренды, срок действия которых заканчивается через 5 часов, и уведомление еще не отправлено
        return await cls.filter(
            rent_expire_at__lte=target_time,
            rent_expire_at__gt=utc_now,
            is_canceled=False,
            sms_text__isnull=False
        ).exclude(
            sms_text=""
        ).all().prefetch_related("user", "country")


    @classmethod
    async def close_rent_before_end(cls):
        """
        Получает список аренд, для которых срок истекает ровно через 5 минут
        """
        utc_now = datetime.now(pytz.timezone("Europe/Moscow"))
        target_time = utc_now + timedelta(minutes=5)

        # Фильтруем аренды, срок действия которых заканчивается через 5 минут, и уведомление еще не отправлено
        return await cls.filter(
            rent_expire_at__lte=target_time,
            rent_expire_at__gt=utc_now,
            is_canceled=False,
            autorenew=False,
            sms_text__isnull=False
        ).exclude(
            sms_text=""
        ).all().prefetch_related("user", "country")


    @classmethod
    async def inactive_rent(cls, tzid: int):
        """
        Получает аренду по её уникальному идентификатору tzid.

        :param tzid: Уникальный идентификатор аренды.
        :return: Объект аренды или None, если аренда не найдена.
        """
        return await cls.filter(rent_id=tzid, is_canceled=True, status=StatusResponse.STATUS_WAIT_CODE).first()


class PayOut(Model):
    class Meta:
        # Метаданные для модели Payment
        table = "payout"  # Название таблицы в базе данных
        table_description = "Payout"  # Описание таблицы
        ordering = ["id"]  # Поле для сортировки записей по умолчанию

    # Поля модели PayOut
    id: int = fields.BigIntField(pk=True)  # Уникальный идентификатор платежа (первичный ключ)
    user: User = fields.ForeignKeyField('models.User', related_name='payouts')  # Связь с моделью User (внешний ключ)
    amount: float = fields.FloatField()  # Сумма выплаты
    currency: str = fields.CharField(max_length=10)
    address: str = fields.TextField()  # Адрес кошелька получателя
    network:str = fields.TextField()  # Код блокчейн-сети (например, TRON, BTC)
    created_at: datetime = fields.DatetimeField(
        auto_now_add=True)  # Дата и время создания записи (автоматически устанавливается при создании)

    @classmethod
    async def create_payout(cls, user: User, amount: float, currency: str, address: str, network:str):
        """
        Создает новый платеж в базе данных.

        :param user: Объект пользователя, который инициировал платеж.
        :param amount: Сумма платежа.
        :param currency: Валюта выплаты (в виде строки)
        :param address: Адрес кошелька получателя
        :param network: Код блокчейн-сети (например, TRON, BTC).
        :return: Созданный объект платежа.
        """
        payment = await cls.create(
            user=user,
            amount=amount,
            currency=currency,
            address=address,
            network=network,
        )
        return payment


class AdminSettings(Model):
    class Meta:
        table = "admin_settings"
        table_description = "Настройки администратора"
        ordering = ["id"]

    id: int = fields.IntField(pk=True)
    name_setting: str = fields.CharField(max_length=255, unique=True)
    value_setting: str = fields.CharField(max_length=255)

    def to_dict(self):
        """
        Преобразует объект настройки в словарь.

        :return: Словарь с настройкой.
        """
        return {
            'name_setting': self.name_setting,
            'value_setting': self.value_setting
        }

    @classmethod
    async def add_setting(cls, name_setting: str, value_setting: str):
        """
        Добавляет новую настройку в базу данных.

        :param name_setting: Название настройки.
        :param value_setting: Значение настройки.
        :return: Созданный объект настройки.
        """
        setting, created = await cls.get_or_create(
            name_setting=name_setting,
            defaults={'value_setting': value_setting}
        )
        if not created:
            return None  # Настройка уже существует
        return setting

    @classmethod
    async def update_setting(cls, name_setting: str, value_setting: str):
        """
        Обновляет значение настройки.

        :param name_setting: Название настройки.
        :param value_setting: Новое значение настройки.
        :return: Обновленный объект настройки или None, если настройка не найдена.
        """
        setting = await cls.get_or_none(name_setting=name_setting)
        if setting:
            setting.value_setting = value_setting
            await setting.save()
            return setting
        return None

    @classmethod
    async def get_setting_value(cls, name_setting: str) -> str:
        """
        Получает значение настройки.

        :param name_setting: Название настройки.
        :return: Значение настройки или None, если настройка не найдена.
        """
        setting = await cls.get_or_none(name_setting=name_setting)
        return setting.value_setting if setting else None

    @classmethod
    async def get_all_settings(cls):
        """
        Получает все настройки в виде списка словарей.

        :return: Список всех настроек.
        """
        settings = await cls.all()
        return [setting.to_dict() for setting in settings]

    @classmethod
    async def delete_setting(cls, name_setting: str):
        """
        Удаляет настройку из базы данных.

        :param name_setting: Название настройки.
        :return: True, если настройка была удалена, иначе False.
        """
        setting = await cls.get_or_none(name_setting=name_setting)
        if setting:
            await setting.delete()
            return True
        return False

    def __str__(self):
        return f"{self.name_setting}: {self.value_setting}"



class BroadcastCampaign(Model):
    """ Таблица для хранения информации о рассылках """
    id = fields.IntField(pk=True)
    message_id = fields.BigIntField(null=True)  # ID оригинального сообщения (если копируем)
    message_text = fields.TextField(null=True)  # Текст сообщения (если текстовая рассылка)
    sent_by_admin_id = fields.BigIntField(null=True)  # ID администратора, отправившего сообщение
    created_at = fields.DatetimeField(auto_now_add=True, timezone=True)  # Учитываем часовой пояс

    class Meta:
        table = "broadcast_campaigns"




class Broadcast(Model):
    """ Таблица для хранения отправленных сообщений в рамках рассылки """
    id = fields.IntField(pk=True)
    campaign = fields.ForeignKeyField("models.BroadcastCampaign", related_name="broadcasts", on_delete=fields.CASCADE)
    sent_to = fields.BigIntField()  # Telegram ID пользователя
    created_at = fields.DatetimeField(auto_now_add=True, timezone=True)  # Учитываем часовой пояс

    class Meta:
        table = "broadcasts"


app\db\__init__.py


app\dialogs\__init__.py
from aiogram import Dispatcher
from aiogram_dialog import setup_dialogs as sd

from . import bot_menu
from . import receive_sms
from . import rent_sms
from . import receive_email
from . import personal_cabinet


def setup_dialogs(dp: Dispatcher):
    for dialog in [
        *bot_menu.bot_menu_dialogs(),
        *receive_sms.select_countries_dialogs(),
        *receive_sms.select_services_dialogs(),
        *rent_sms.select_rent_dialogs(),
        *receive_email.receive_email_dialogs(),
        *personal_cabinet.personal_cabinet_dialogs()

    ]:
        dp.include_router(dialog)

    sd(dp)



app\dialogs\bot_menu\getters.py
from aiogram_dialog import DialogManager
from app.db import models


# async def get_categories(dialog_manager: DialogManager, **middleware_data):
#     db_categories = await models.Categories.get_all_categories()
#     data = {
#         "categories": db_categories
#     }
#     return data


app\dialogs\bot_menu\keyboards.py
import operator

from aiogram_dialog.widgets.kbd import ScrollingGroup, Select
from aiogram_dialog.widgets.text import Format

# def paginated_categories(on_click):
#     return ScrollingGroup(
#         Select(
#             Format('{item.name}'),
#             id='s_scroll_categories',
#             item_id_getter=operator.attrgetter('id'),
#             items='categories',
#             on_click=on_click
#         ),
#         id='categories_ids',
#         width=1, height=SCROLLING_HEIGHT
#     )


app\dialogs\bot_menu\selected.py
from aiogram import types
from aiogram_dialog import DialogManager
from aiogram_dialog.widgets.kbd import Select, Button
from app.dialogs.receive_sms.states import CountryMenu
from app.dialogs.personal_cabinet.states import PersonalMenu
from app.handlers.affiliate_program import send_affiliate_message


async def on_receive_sms(c: types.CallbackQuery, widget: Button, manager: DialogManager):
    await manager.start(CountryMenu.select_country)


# async def on_receive_email(c: types.CallbackQuery, widget: Button, manager: DialogManager):
#     await c.message.edit_text(text=bt.CREATING_EMAIL)
#     user = await models.User.get_user(c.from_user.id)
#     if not user:
#         return
#
#     mails = await models.Mail.get_user_mails(user)
#     if len(mails) > 0:
#         mail = mails[0]
#
#     else:
#         tm = MailTm()
#         try:
#             account = await tm.create_account()
#         except Exception:
#             await c.answer(text='Ошибка, повторите попытку через пару секунд', show_alert=True)
#             return
#
#         mail = await models.Mail.add_mail(user, account.id_, account.address, account.password)
#
#     await manager.start(ReceiveEmailMenu.receive_email,
#                         data={"mail_id": mail.id})


async def on_personal_cabinet(c: types.CallbackQuery, widget: Button, manager: DialogManager):
    await manager.start(PersonalMenu.user_info)


async def on_affiliate_program(c: types.CallbackQuery, widget: Button, manager: DialogManager):
    await manager.reset_stack(remove_keyboard=False)
    await send_affiliate_message(c)


app\dialogs\bot_menu\states.py
from aiogram.fsm.state import StatesGroup, State


class BotMenu(StatesGroup):
    start = State()


app\dialogs\bot_menu\windows.py
from aiogram_dialog import Window, DialogManager, Data
from aiogram_dialog.widgets.kbd import Cancel, Back, Button, Row
from aiogram_dialog.widgets.text import Const, Format

from app.dialogs.bot_menu import states
from app.dialogs.bot_menu.selected import on_receive_sms, on_personal_cabinet, on_affiliate_program
from app.services import bot_texts as bt


def main_menu_window():
    return Window(
        Const(bt.MAIN_MENU),
        Row(Button(Const(bt.RECEIVE_SMS_BTN), id='receive_sms', on_click=on_receive_sms)),

        Button(Const(bt.PERSONAL_CABINET_BTN), id='personal_cabinet', on_click=on_personal_cabinet),
        Button(Const(bt.AFFILIATE_PROGRAM_BTN), id='affiliate_program', on_click=on_affiliate_program),
        state=states.BotMenu.start
    )

# async def on_process_result(data: Data, result: dict, manager: DialogManager):
#     if result:
#         switch_to_window = result.get('switch_to_window')
#         if switch_to_window == SwitchToWindow.SelectProducts:
#             await manager.switch_to(states.BotMenu.select_products)


app\dialogs\bot_menu\__init__.py
from aiogram_dialog import Dialog

from app.dialogs.bot_menu import windows


def bot_menu_dialogs():
    return [
        Dialog(
            windows.main_menu_window()
        )
    ]


app\dialogs\partner\getters.py
from aiogram_dialog import DialogManager
from app.db import models
from app.services.sms_receive import SmsReceive
from app.services import bot_texts as bt


async def get_user_info(dialog_manager: DialogManager, **middleware_data):
    user = await models.User.get_user(dialog_manager.event.from_user.id)
    if not user:
        return

    return {
        'user_id': user.telegram_id,
        'balance': user.balance,
        'ref_balance': user.ref_balance,
    }


async def get_deposit_prices(dialog_manager: DialogManager, **middleware_data):
    return {
        'prices': bt.prices_data
    }


app\dialogs\partner\keyboards.py
import operator

from aiogram_dialog.widgets.kbd import Group, Button, Select
from aiogram_dialog.widgets.text import Const, Format
from app.services import bot_texts as bt


def prices_kb(on_click):
    return Group(
        Select(
            Format('{item[price]}₽'),
            id='prices_kb',
            item_id_getter=operator.itemgetter('id'),
            items="prices",
            on_click=on_click,
        ),
        width=2
    )


app\dialogs\partner\selected.py
from aiogram import types
from aiogram_dialog import DialogManager
from aiogram_dialog.widgets.input import TextInput
from aiogram_dialog.widgets.kbd import Select, Button

from app.db import models
from app.dialogs.personal_cabinet.states import PersonalMenu
from app.services import bot_texts as bt


async def on_deposit(c: types.CallbackQuery, widget: Button, manager: DialogManager):
    await manager.switch_to(PersonalMenu.deposit)


async def on_deposit_price(c: types.CallbackQuery, widget: Select, manager: DialogManager, price_id: str):
    price = bt.prices_data[int(price_id)]
    await c.answer(text='В разработке', show_alert=True)


async def on_other_price(c: types.CallbackQuery, widget: Button, manager: DialogManager):
    await c.answer(text='В разработке', show_alert=True)


app\dialogs\partner\states.py
from aiogram.fsm.state import StatesGroup, State


class PersonalMenu(StatesGroup):
    user_info = State()
    deposit = State()
    enter_amount = State()



app\dialogs\partner\windows.py
from aiogram_dialog import Window
from aiogram_dialog.widgets.kbd import Cancel, Back, Button
from aiogram_dialog.widgets.text import Const, Format

from app.dialogs.personal_cabinet import states, keyboards
from app.dialogs.personal_cabinet.getters import get_user_info, get_deposit_prices
from app.dialogs.personal_cabinet.selected import on_deposit_price, on_other_price, on_deposit
from app.services import bot_texts as bt


def personal_cabinet_window():
    return Window(
        Format(bt.PERSONAL_CABINET),
        Button(Const(bt.DEPOSIT_BTN), id='deposit', on_click=on_deposit),
        Cancel(Const(bt.BACK_BTN)),
        state=states.PersonalMenu.user_info,
        getter=get_user_info
    )


def deposit_window():
    return Window(
        Const(bt.SELECT_DEPOSIT_PRICE),
        keyboards.prices_kb(on_deposit_price),
        Button(Const(bt.OTHER_DEPOSIT_PRICE_BTN), id='other_price', on_click=on_other_price),
        Back(Const(bt.BACK_BTN)),
        state=states.PersonalMenu.deposit,
        getter=get_deposit_prices
    )


app\dialogs\partner\__init__.py
from aiogram_dialog import Dialog

from app.dialogs.personal_cabinet import windows


def personal_cabinet_dialogs():
    return [
        Dialog(
            windows.personal_cabinet_window(),
            windows.deposit_window()
        )
    ]



app\dialogs\personal_cabinet\getters.py
from aiogram_dialog import DialogManager
from tortoise import timezone

from app.db import models
from app.services.sms_receive import SmsReceive
from app.services import bot_texts as bt
from loguru import logger


async def get_user_info(dialog_manager: DialogManager, **middleware_data):
    """
    Получает информацию о пользователе для отображения в интерфейсе.
    :param dialog_manager: Объект DialogManager.
    :param middleware_data: Дополнительные данные из middleware.
    """
    try:
        user_id = dialog_manager.event.from_user.id
        logger.bind(user_id=user_id, action='get_user_info').log(
            "USER_ACTION",
            "Запрос информации о пользователе"
        )

        user = await models.User.get_user(user_id)
        if not user:
            logger.bind(user_id=user_id, action='get_user_info').log(
                "USER_ACTION",
                "Пользователь не найден"
            )
            return {}

        logger.bind(user_id=user_id, action='get_user_info').log(
            "USER_ACTION",
            f"Информация о пользователе получена: баланс={user.balance}, ref_balance={user.ref_balance}"
        )
        return {
            'user_id': user.telegram_id,
            'balance': user.balance,
            'ref_balance': int(user.ref_balance),
        }
    except Exception as e:
        logger.opt(exception=e).error(f"Ошибка в get_user_info: {e}")
        return {}


async def get_deposit_prices(dialog_manager: DialogManager, **middleware_data):
    """
    Получает список доступных сумм пополнения и проверяет наличие бонуса у пользователя.
    :param dialog_manager: Объект DialogManager.
    :param middleware_data: Дополнительные данные из middleware.
    """
    try:
        user_id = dialog_manager.event.from_user.id
        if user_id is None:
            user_id = dialog_manager.start_data.get("user_id")

        logger.bind(user_id=user_id, action='get_deposit_prices').log(
            "USER_ACTION",
            "Запрос списка цен на пополнение"
        )

        user = await models.User.get_user(user_id)

        bonus_active = False
        if user and user.bonus_end_at and user.bonus_end_at > timezone.now():
            bonus_active = True
            logger.bind(user_id=user_id, action='get_deposit_prices').log(
                "USER_ACTION",
                f"Бонус активен до {user.bonus_end_at}"
            )

        logger.bind(user_id=user_id, action='get_deposit_prices').log(
            "USER_ACTION",
            "Список цен успешно подготовлен"
        )
        return {
            'prices': bt.prices_data,
            'bonus': bonus_active
        }
    except Exception as e:
        logger.opt(exception=e).error(f"Ошибка в get_deposit_prices: {e}")
        return {}

app\dialogs\personal_cabinet\keyboards.py
import operator

from aiogram import F
from aiogram_dialog.widgets.kbd import Group, Button, Select
from aiogram_dialog.widgets.text import Const, Format
from app.services import bot_texts as bt


def prices_kb(on_click):
    return Group(
        Select(
            Format('{item[price]}₽'),
            id='prices_kb',
            item_id_getter=operator.itemgetter('id'),
            items="prices",
            on_click=on_click,
            when=~F['bonus']
        ),
        Select(
            Format('{item[price]}₽ (+10%)'),
            id='prices_kb',
            item_id_getter=operator.itemgetter('id'),
            items="prices",
            on_click=on_click,
            when=F['bonus']
        ),
        width=2
    )


def prices_sale_kb(on_click):
    return Group(
        Select(
            Format('{item[price]}₽ (+10%)'),
            id='prices_kb',
            item_id_getter=operator.itemgetter('id'),
            items="prices",
            on_click=on_click,
        ),
        width=2
    )


app\dialogs\personal_cabinet\selected.py
from typing import Union
from aiogram import types
from aiogram.types import InlineKeyboardButton, InlineKeyboardMarkup
from aiogram_dialog import DialogManager, StartMode
from aiogram_dialog.widgets.input import TextInput
from aiogram_dialog.widgets.kbd import Select, Button
import re
from app.db import models
from app.dialogs.personal_cabinet.states import PersonalMenu
from app.dialogs.receive_sms.scheduler_balance import start_balance_check
from app.dialogs.receive_sms.states import CountryMenu
from app.dialogs.rent_sms.scheduler_balance import start_balance_check_rent
from app.dialogs.rent_sms.selected import rent_number_in_days
from app.dialogs.rent_sms.states import RentCountryMenu
from app.handlers.affiliate_program import send_affiliate_message
from app.services import bot_texts as bt
from app.services.payments.anypay import AnypayAPI
from app.services.bot_texts import FOLLOW_THE_LINK_TO_PAY
from app.services.payments.ckassa import create_invoice_ckassa
from app.services.payments.cryptomus import link_to_cryptomus
from app.services.payments.freekassa import generate_fk_link
from app.services.payments.lava import LavaApi
from app.services.payments.streampay import create_payment_streampay
from loguru import logger


async def on_deposit(c: types.CallbackQuery, widget: Button, manager: DialogManager):
    """
    Обработчик для кнопки "Пополнить баланс".
    Переключает состояние диалога на меню пополнения баланса.
    :param c: Объект CallbackQuery.
    :param widget: Объект Button.
    :param manager: Объект DialogManager.
    """
    try:
        user_id = c.from_user.id
        logger.bind(user_id=user_id, action='on_deposit').log("USER_ACTION", "Переход к пополнению баланса")
        await manager.done()
        await manager.start(PersonalMenu.deposit)
    except Exception as e:
        logger.opt(exception=e).error(f"Ошибка в on_deposit: {e}")


async def affiliate(c: types.CallbackQuery, widget: Button, manager: DialogManager):
    """
    Обработчик кнопки "Партнерская программа".
    Вызывает функцию send_affiliate_message с передачей сообщения из CallbackQuery.
    :param c: Объект CallbackQuery.
    :param widget: Объект Button.
    :param manager: Объект DialogManager.
    """
    try:
        user_id = c.from_user.id
        logger.bind(user_id=user_id, action='affiliate').log("USER_ACTION", "Открытие партнерской программы")
        await send_affiliate_message(m=c.message, user_id=user_id)
        await c.answer()
    except Exception as e:
        logger.opt(exception=e).error(f"Ошибка в Открытие партнерской программы: {e}")


async def on_payment_method(c: types.CallbackQuery, widget: Button, manager: DialogManager):
    try:
        user_id = c.from_user.id
        logger.bind(user_id=user_id, action='on_payment_method').log("USER_ACTION", "Выбор способа оплаты")
        await send_payment_keyboard(c, manager=manager)
    except Exception as e:
        logger.opt(exception=e).error(f"Ошибка в on_payment_method: {e}")


async def on_deposit_new(c: types.CallbackQuery, widget: Button, manager: DialogManager):
    """
    Обработчик для кнопки "Новое пополнение".
    Переключает состояние диалога на меню пополнения баланса с сохранением текущих данных.
    :param c: Объект CallbackQuery.
    :param widget: Объект Button.
    :param manager: Объект DialogManager.
    """
    try:
        user_id = c.from_user.id
        logger.bind(user_id=user_id, action='on_deposit_new').log("USER_ACTION", "Запуск нового пополнения")
        ctx = manager.current_context()
        await manager.start(PersonalMenu.deposit, data=ctx.dialog_data)
    except Exception as e:
        logger.opt(exception=e).error(f"Ошибка в on_deposit_new: {e}")


async def on_deposit_state(c: types.CallbackQuery, widget: Button, manager: DialogManager):
    """
    Обработчик для кнопки "пополнение с установленным значением".
    Переключает состояние диалога на меню пополнения баланса с сохранением текущих данных.
    :param c: Объект CallbackQuery.
    :param widget: Объект Button.
    :param manager: Объект DialogManager.
    """
    try:
        user_id = c.from_user.id
        logger.bind(user_id=user_id, action='on_deposit_state').log("USER_ACTION", "Выбрана фиксированная сумма")
        ctx = manager.current_context()
        price = ctx.dialog_data['cost']
        ctx.dialog_data['price'] = price
        await send_payment_keyboard(c, manager=manager)
    except Exception as e:
        logger.opt(exception=e).error(f"Ошибка в on_deposit_state: {e}")


async def on_deposit_price(c: types.CallbackQuery, widget: Select, manager: DialogManager, price_id: str):
    """
    Обработчик для выбора суммы пополнения.
    Отправляет клавиатуру для выбора способа оплаты.
    :param c: Объект CallbackQuery.
    :param widget: Объект Select.
    :param manager: Объект DialogManager.
    :param price_id: Идентификатор выбранной суммы.
    """
    try:
        user_id = c.from_user.id
        logger.bind(user_id=user_id, action='on_deposit_price').log("USER_ACTION", f"Выбрана сумма: {price_id}")
        await c.message.delete()
        price = bt.prices_data[int(price_id) - 1]['price']
        ctx = manager.current_context()
        ctx.dialog_data['price'] = price
        await send_payment_keyboard(c, manager=manager, price=price)
    except Exception as e:
        logger.opt(exception=e).error(f"Ошибка в on_deposit_price: {e}")


async def on_other_price(c: types.CallbackQuery, widget: Button, manager: DialogManager):
    """
    Обработчик для кнопки "Другая сумма".
    Переключает состояние диалога на ввод суммы пополнения.
    :param c: Объект CallbackQuery.
    :param widget: Объект Button.
    :param manager: Объект DialogManager.
    """
    try:
        user_id = c.from_user.id
        logger.bind(user_id=user_id, action='on_other_price').log("USER_ACTION", "Выбрана произвольная сумма")
        await switch_state(manager)
    except Exception as e:
        logger.opt(exception=e).error(f"Ошибка в on_other_price: {e}")


async def switch_state(manager: DialogManager):
    # Получаем название группы состояний
    state = manager.current_context().state
    # Проверяем группу состояний и переключаемся на нужное состояние
    if state == 'PersonalMenu:deposit':
        await manager.switch_to(PersonalMenu.enter_amount)
    elif state == 'CountryMenu:deposit':
        await manager.switch_to(CountryMenu.enter_amount)
    elif state == 'RentCountryMenu:deposit':
        await manager.switch_to(RentCountryMenu.enter_amount)


async def on_enter_other_price(m: types.Message, widget: TextInput, manager: DialogManager, price_text: str):
    """
    Обработчик для ввода другой суммы пополнения.
    Проверяет корректность введенной суммы и отправляет клавиатуру для выбора способа оплаты.
    :param m: Объект Message.
    :param widget: Объект TextInput.
    :param manager: Объект DialogManager.
    :param price_text: Введенная сумма пополнения.
    """
    try:
        user_id = m.from_user.id
        logger.bind(user_id=user_id, action='on_enter_other_price').log("USER_ACTION", f"Введена сумма: {price_text}")

        if not price_text.isdigit():
            await m.answer(text='Сумма должна быть числом')
            await switch_state(manager)
            return
        price = int(price_text)
        if price < 50:
            await m.answer(text='Минимальная сумма - 50₽')
            await switch_state(manager)
            return
        ctx = manager.current_context()
        ctx.dialog_data['price'] = price
        await send_payment_keyboard(m, manager=manager, price=price)
    except Exception as e:
        logger.opt(exception=e).error(f"Ошибка в on_enter_other_price: {e}")


async def send_payment_keyboard(m: Union[types.Message, types.CallbackQuery], manager: DialogManager = None,
                                price: float = None):
    """
    Отправляет клавиатуру для выбора способа оплаты.
    :param m: Объект Message или CallbackQuery.
    :param manager: Объект DialogManager.
    :param price: Сумма пополнения.
    """

    user_id = m.from_user.id
    logger.bind(user_id=user_id, action='send_payment_keyboard').log("USER_ACTION", f"Формирование платежной ссылки")

    if manager:
        ctx = manager.current_context()
        price = float(ctx.dialog_data['price'])
        continue_data = ctx.start_data
    else:
        ctx = None
        continue_data = None

    user = await models.User.get_user(user_id)

    # формируем ссылку на оплату Lava
    try:
        lava = LavaApi()
        lava_payment = await models.Payment.create_payment(
            user=user,
            method=models.PaymentMethod.LAVA,
            amount=price,
            continue_data=continue_data
        )
        order_id = f'sms_email_:{lava_payment.id}'
        response = await lava.create_invoice(price, order_id=order_id)
        invoice_id = response['data']['id']
        lava_payment.invoice_id = invoice_id
        lava_payment.order_id = order_id
        await lava_payment.save()
        lava_url = response['data']['url']
    except Exception:
        lava_url = None

    payment_freekassa = await models.Payment.create_payment(
        user=user,
        method=models.PaymentMethod.FREEKASSA,
        amount=price,
        continue_data=continue_data
    )
    # формируем ссылку на оплату freekassa
    other_url = generate_fk_link(price, payment_freekassa.id)

    payment_cryptomus = await models.Payment.create_payment(
        user=user,
        method=models.PaymentMethod.CRYPTOMUS,
        amount=price,
        continue_data=continue_data
    )
    # формируем ссылку на оплату cryptomus
    cryptomus_url = link_to_cryptomus(price, payment_cryptomus.id)

    # payment_yoomoney = await models.Payment.create_payment(
    #     user=user,
    #     method=models.PaymentMethod.YOOMONEY,
    #     amount=price,
    #     continue_data=continue_data
    # )


    # формируем ссылку на оплату api_yoomoney
    # yoomoney_url = await create_yoomoney_url(price, payment_yoomoney.id)

    if price >= 300:
        payment_streampay = await models.Payment.create_payment(
            user=user,
            method=models.PaymentMethod.STREAMPAY,
            amount=price,
            continue_data=continue_data
        )

        # формируем ссылку на оплату
        payment_streampay.invoice_id, streampay_url = await create_payment_streampay(price, str(payment_streampay.user.telegram_id))
        await payment_streampay.save()
    else:
        streampay_url = ''

    if price >= 50:
        payment_ckassa = await models.Payment.create_payment(
            user=user,
            method=models.PaymentMethod.CKASSA,
            amount=price,
            continue_data=continue_data
        )

        # формируем ссылку на оплату ckassa_url
        payment_ckassa.invoice_id, ckassa_url = await create_invoice_ckassa(price, str(payment_ckassa.user.telegram_id))
        await payment_ckassa.save()
    else:
        ckassa_url = ''

    state = manager.current_context().state.group.__name__

    # Передаем URL-адреса в контекстное состояние
    country_id = ''
    service_code = ''
    service_price = ''
    rent_country_code = ''
    selected_country = ''
    day_index = ''
    retail_price = ''

    if state == 'CountryMenu':
        country_id = ctx.dialog_data['country_id']
        service_code = ctx.dialog_data['service_code']
        service_price = ctx.dialog_data['service_price']
        retail_price = ctx.dialog_data['retail_price']
        if price >= 300:
            await manager.start(CountryMenu.payment_method, mode=StartMode.NORMAL, data={})
        else:
            await manager.start(CountryMenu.payment_method_minimum_pay, mode=StartMode.NORMAL, data={})
    elif state == 'RentCountryMenu':
        if ctx and 'rent_country_code' in ctx.dialog_data:
            rent_country_code = ctx.dialog_data['rent_country_code']
            selected_country = ctx.dialog_data.get('selected_country', '')
            day_index = ctx.dialog_data.get('day_index', '')
        else:
            rent_country_code = ''
            selected_country = ''
            day_index = ''
        if price >= 300:
            await manager.start(RentCountryMenu.payment_method, mode=StartMode.NORMAL, data={})
        else:
            await manager.start(RentCountryMenu.payment_method_minimum_pay, mode=StartMode.NORMAL, data={})
    else:
        if price >= 300:
            await manager.start(PersonalMenu.payment_method, mode=StartMode.NORMAL, data={})
        else:
            await manager.start(PersonalMenu.payment_method_minimum_pay, mode=StartMode.NORMAL, data={})
    # Получаем текущий контекст и обновляем dialog_data
    ctx = manager.current_context()
    ctx.dialog_data.update({
        'ckassa_url': ckassa_url,
        'bank_card_url': streampay_url,
        'SBP': lava_url if lava_url is not None else other_url,
        'yoomoney_url': other_url,
        'stars': price,
        'crypto_url': cryptomus_url,
        'other_url': other_url,
        'price': price,
        'country_id': country_id,
        'rent_country_code': rent_country_code,
        'service_code': service_code,
        'selected_country': selected_country,
        'day_index': day_index,
        'retail_price': retail_price,
        'service_price': service_price
    })

    # await create_payment_keyboard(m, price, lava_url, sbp_url, other_url)


async def switch_to_payment(c: types.CallbackQuery, button: Button, manager: DialogManager):

    user_id = c.from_user.id

    current_context = manager.current_context()
    url_key = f"{button.widget_id}_url"
    url = current_context.dialog_data.get(url_key)
    url_pattern = re.compile(r'https?://[^\s]+')

    logger.bind(user_id=user_id, action='switch_to_payment').log("USER_ACTION", f"Переход к оплате {url}")

    if not url or not url_pattern.match(url):
        await c.answer(text=bt.ERROR_PAYMENT_METHOD, show_alert=True)
        return

    # Если URL корректный, продолжаем обработку
    web_app = types.WebAppInfo(url=url)
    price = current_context.dialog_data.get('price')

    # Создаем кнопку, которая откроет веб-приложение
    web_app_button = InlineKeyboardButton(text=f"Оплатить {price}₽", web_app=web_app)

    # Создаем экземпляр клавиатуры с кнопкой
    keyboard = InlineKeyboardMarkup(inline_keyboard=[[web_app_button]])

    if manager.current_context().state.group.__name__ == 'CountryMenu':
        country_id = current_context.dialog_data.get('country_id')
        service_code = current_context.dialog_data.get('service_code')
        service_price = current_context.dialog_data.get('service_price')
        free_price_map = current_context.dialog_data.get('free_price_map')
        retail_price = current_context.dialog_data.get('retail_price')

        # Запускаем проверку баланса
        await start_balance_check(c.from_user.id, service_price, retail_price, free_price_map, country_id, service_code,
                                  c, manager)

    if manager.current_context().state.group.__name__ == 'RentCountryMenu':
        day_index = current_context.dialog_data.get('day_index')
        selected_country = current_context.dialog_data.get('selected_country')

        await start_balance_check_rent(c.from_user.id, price, day_index, selected_country, c, manager)

    if manager:
        await manager.reset_stack()

    # Отправляем сообщение с клавиатурой или редактируем существующее сообщение
    await c.message.edit_text(text=FOLLOW_THE_LINK_TO_PAY, reply_markup=keyboard)


async def send_payment_keyboard_anypay(c: types.CallbackQuery, button: Button, manager: DialogManager):
    """
        Отправляет клавиатуру для выбора способа оплаты.

        :param m: Объект Message или CallbackQuery.
        :param manager: Объект DialogManager.
        :param price: Сумма пополнения.
        """

    try:
        user_id = c.from_user.id
        logger.bind(user_id=user_id, action='send_payment_keyboard_anypay').log("USER_ACTION", "Формирование AnyPay-ссылки")

        ctx = manager.current_context()
        price = float(ctx.dialog_data['price']) if manager else 0
        continue_data = ctx.start_data if manager else None

        user = await models.User.get_user(c.from_user.id)
        payment_anypay = await models.Payment.create_payment(
            user=user,
            method=models.PaymentMethod.ANYPAY,
            amount=price,
            continue_data=continue_data
        )

        api = AnypayAPI()
        url_card = await api.create_payment(amount=price, desc=payment_anypay.id, method='card')
        url_sbp = await api.create_payment(amount=price, desc=payment_anypay.id, method='sbp')
        url_btc = await api.create_payment(amount=price, desc=payment_anypay.id, method='btc')

        state = manager.current_context().state.group.__name__
        ctx = manager.current_context()

        country_id = ''
        service_code = ''
        service_price = ''
        url_pattern = re.compile(r'https?://[^\s]+')

        if state == 'CountryMenu':
            country_id = ctx.dialog_data['country_id']
            service_code = ctx.dialog_data['service_code']
            service_price = ctx.dialog_data['service_price']
            if url_pattern.match(url_sbp):
                await manager.start(CountryMenu.payment_method_anypay, mode=StartMode.NORMAL, data={})
            else:
                await manager.start(CountryMenu.payment_method_anypay_min, mode=StartMode.NORMAL, data={})
        elif state == 'RentCountryMenu':
            if url_pattern.match(url_sbp):
                await manager.start(RentCountryMenu.payment_method_anypay, mode=StartMode.NORMAL, data={})
            else:
                await manager.start(RentCountryMenu.payment_method_anypay_min, mode=StartMode.NORMAL, data={})
        else:
            if url_pattern.match(url_sbp):
                await manager.start(PersonalMenu.payment_method_anypay, mode=StartMode.NORMAL, data={})
            else:
                await manager.start(PersonalMenu.payment_method_anypay_min, mode=StartMode.NORMAL, data={})

        ctx.dialog_data.update({
            'card_url': url_card,
            'sbp_url': url_sbp,
            'btc_url': url_btc,
            'price': price,
            'country_id': country_id,
            'service_code': service_code,
            'service_price': service_price
        })
    except Exception as e:
        logger.opt(exception=e).error(f"Ошибка в send_payment_keyboard_anypay: {e}")

app\dialogs\personal_cabinet\states.py
from aiogram.fsm.state import StatesGroup, State


class PersonalMenu(StatesGroup):
    user_info = State()
    deposit = State()
    payment_method = State()
    payment_method_anypay = State()
    payment_method_minimum_pay = State()
    payment_method_anypay_min = State()
    deposit_choose_method = State()
    enter_amount = State()




app\dialogs\personal_cabinet\windows.py
from aiogram import F
from aiogram_dialog import Window
from aiogram_dialog.widgets.input import TextInput
from aiogram_dialog.widgets.kbd import Back, Button, Url
from aiogram_dialog.widgets.text import Const, Format
from app import dependencies
from app.dialogs.personal_cabinet import states, keyboards
from app.dialogs.personal_cabinet.getters import get_user_info, get_deposit_prices
from app.dialogs.personal_cabinet.selected import on_deposit_price, on_other_price, on_deposit, on_enter_other_price, \
    switch_to_payment, send_payment_keyboard_anypay, on_payment_method, affiliate
from app.handlers.affiliate_program import affiliate_program
from app.services import bot_texts as bt
from app.services.bot_texts import LINK_TO_BUTTON
from app.services.stars_pay import send_invoice_handler_stars


def personal_cabinet_window():
    return Window(
        Format(bt.PERSONAL_CABINET),
        Button(Const(bt.DEPOSIT_BTN), id='deposit', on_click=on_deposit),
        Button(Const(bt.AFFILIATE_PROGRAM_BTN), id='affiliate', on_click=affiliate),
        Url(Const(bt.INSTRUCTIONS), url=Const(LINK_TO_BUTTON)),
        Url(Const(bt.SUPPORT_BTN), url=Const(dependencies.SUPPORT_URL)),
        state=states.PersonalMenu.user_info,
        getter=get_user_info
    )


def deposit_window():
    return Window(
        Const(bt.SELECT_DEPOSIT_PRICE),
        keyboards.prices_kb(on_deposit_price),
        Button(Const(bt.OTHER_DEPOSIT_PRICE_BTN), id='other_price', on_click=on_other_price, when=~F['bonus']),
        Button(Const(bt.OTHER_DEPOSIT_PRICE_BTN + ' (+10%)'), id='other_price', on_click=on_other_price,
               when=F['bonus']),
        Back(Const(bt.BACK_BTN)),
        state=states.PersonalMenu.deposit,
        getter=get_deposit_prices
    )


def enter_amount_window():
    return Window(
        Const(bt.ENTER_DEPOSIT_AMOUNT),
        TextInput(id='enter_deposit_amount', on_success=on_enter_other_price),
        Back(Const(bt.BACK_BTN)),
        state=states.PersonalMenu.enter_amount
    )


# Функция для нового окна выбора метода оплаты
def payment_method_window():
    return Window(
        Const(bt.SELECT_DEPOSIT_METHOD),
        Button(Const(bt.METHOD_CKASSA), id='ckassa', on_click=switch_to_payment),
        Button(Const(bt.METHOD_STREAMPAY), id='bank_card', on_click=switch_to_payment),
        # Button(Const(bt.METHOD_LAVA), id='SBP', on_click=switch_to_payment),
        # Button(Const(bt.METHOD_ANYPAY), id='anypay', on_click=send_payment_keyboard_anypay),
        Button(Const(bt.METHOD_STARS_BTN), id='stars', on_click=send_invoice_handler_stars),
        Button(Const(bt.METHOD_CRYPTO_BTN), id='crypto', on_click=switch_to_payment),
        Button(Const(bt.METHOD_OTHER_BTN), id='other', on_click=switch_to_payment),
        Button(Const(bt.BACK_BTN), id='back', on_click=on_deposit),
        state=states.PersonalMenu.payment_method
    )

# Функция для выбора метода оплаты с платежем менее 300 руб
def payment_method_window_minimum_pay():
    return Window(
        Const(bt.SELECT_DEPOSIT_METHOD),
        Button(Const(bt.METHOD_CKASSA), id='ckassa', on_click=switch_to_payment),
        Button(Const(bt.METHOD_STARS_BTN), id='stars', on_click=send_invoice_handler_stars),
        Button(Const(bt.METHOD_CRYPTO_BTN), id='crypto', on_click=switch_to_payment),
        Button(Const(bt.METHOD_OTHER_BTN), id='other', on_click=switch_to_payment),
        Button(Const(bt.BACK_BTN), id='back', on_click=on_deposit),
        state=states.PersonalMenu.payment_method_minimum_pay
    )


# Функция для нового окна выбора метода оплаты AnyPay
def payment_method_window_anypay():
    return Window(
        Const(bt.SELECT_DEPOSIT_METHOD),
        Button(Const(bt.METHOD_BANK_CARD), id='card', on_click=switch_to_payment),
        Button(Const(bt.METHOD_BANK_SBP), id='sbp', on_click=switch_to_payment),
        Button(Const(bt.METHOD_BANK_CRYPTOCURRENCY), id='btc', on_click=switch_to_payment),
        Button(Const(bt.BACK_BTN), id='back', on_click=on_payment_method),
        state=states.PersonalMenu.payment_method_anypay
    )

# Функция для нового окна выбора метода оплаты AnyPay
def payment_method_window_anypay_min():
    return Window(
        Const(bt.SELECT_DEPOSIT_METHOD),
        Button(Const(bt.METHOD_BANK_CRYPTOCURRENCY), id='btc', on_click=switch_to_payment),
        Button(Const(bt.BACK_BTN), id='back', on_click=on_payment_method),
        state=states.PersonalMenu.payment_method_anypay_min
    )


app\dialogs\personal_cabinet\__init__.py
from aiogram_dialog import Dialog

from app.dialogs.personal_cabinet import windows


def personal_cabinet_dialogs():
    return [
        Dialog(
            windows.personal_cabinet_window(),
            windows.deposit_window(),
            windows.enter_amount_window(),
            windows.payment_method_window(),
            windows.payment_method_window_minimum_pay(),
            windows.payment_method_window_anypay(),
            windows.payment_method_window_anypay_min(),

        )
    ]



app\dialogs\receive_email\getters.py
from datetime import datetime
import pytz
from aiogram_dialog import DialogManager
from app.db import models
from app.dialogs.receive_email.keyboards import rent_email_kb
from app.dialogs.receive_email.selected import on_rent_email_item
from app.services.sms_receive import SmsReceive
from loguru import logger


async def get_email_info(dialog_manager: DialogManager, **middleware_data):
    try:
        user_id = dialog_manager.event.from_user.id
        user = await models.User.get_user(user_id)
        mail = await models.Mail.filter(user=user).order_by('-id').first()

        logger.bind(user_id=user_id, action='get_email_info').log(
            "USER_ACTION",
            "Запрос информации о почтовом ящике"
        )

        ctx = dialog_manager.current_context()
        mail_id = ctx.start_data.get('mail_id')
        if not mail_id:
            logger.bind(user_id=user_id, action='get_email_info').log(
                "USER_ACTION",
                "ID почты не передан"
            )
            return {}

        ctx.dialog_data['mail_id'] = mail_id
        mail = await models.Mail.get_mail(mail_id)
        if not mail:
            logger.bind(user_id=user_id, action='get_email_info').log(
                "USER_ACTION",
                f"Почта с ID={mail_id} не найдена"
            )
            return {}

        paid_mails_count = await models.Mail.filter(is_active=True, is_paid_mail=True).count()

        tz = pytz.timezone('Europe/Moscow')
        now = datetime.now(pytz.utc).astimezone(tz)

        if mail and mail.is_free_week and mail.expire_at <= now:
            mail.is_free_week = False
            await mail.save(update_fields=["is_free_week"])

        is_free_week = not mail.is_free_week if mail else True

        rent_keyboard = rent_email_kb(on_rent_email_item, is_free_week)

        logger.bind(user_id=user_id, action='get_email_info').log(
            "USER_ACTION",
            f"Информация о почте '{mail.email}' успешно получена"
        )

        return {
            "email": mail.email,
            "is_free_week": not mail.is_free_week,
            "rent_keyboard": rent_email_kb(on_rent_email_item, not mail.is_free_week),
            "paid_mails_count": paid_mails_count
        }

    except Exception as e:
        logger.opt(exception=e).error(f"Ошибка в get_email_info: {e}")
        return {}



async def get_balance(dialog_manager: DialogManager, **middleware_data):
    """
    Получает текущий баланс пользователя и стоимость услуги.
    :param dialog_manager: Объект DialogManager.
    :param middleware_data: Дополнительные данные из middleware.
    """
    try:
        user_id = dialog_manager.event.from_user.id
        logger.bind(user_id=user_id, action='get_balance').log(
            "USER_ACTION",
            "Запрос текущего баланса пользователя"
        )

        ctx = dialog_manager.current_context()
        user = await models.User.get_user(user_id)
        if not user:
            logger.bind(user_id=user_id, action='get_balance').log(
                "USER_ACTION",
                "Пользователь не найден"
            )
            return {}

        logger.bind(user_id=user_id, action='get_balance').log(
            "USER_ACTION",
            f"Текущий баланс: {user.balance}, стоимость услуги: {ctx.dialog_data.get('cost')}"
        )

        return {
            'balance': user.balance,
            'cost': ctx.dialog_data.get('cost')
        }
    except Exception as e:
        logger.opt(exception=e).error(f"Ошибка в get_balance: {e}")
        return {}


async def get_rent_info(dialog_manager: DialogManager, **middleware_data):
    """
    Получает информацию о сроке аренды почтового ящика.
    :param dialog_manager: Объект DialogManager.
    :param middleware_data: Дополнительные данные из middleware.
    """
    try:
        user_id = dialog_manager.event.from_user.id
        logger.bind(user_id=user_id, action='get_rent_info').log(
            "USER_ACTION",
            "Запрос информации о сроке аренды"
        )

        ctx = dialog_manager.current_context()
        rent_days = ctx.dialog_data.get('rent_days')
        cost = ctx.dialog_data.get('cost')

        logger.bind(user_id=user_id, action='get_rent_info').log(
            "USER_ACTION",
            f"Срок аренды: {rent_days} дней, стоимость: {cost}₽"
        )

        return {
            'rent_days': rent_days,
            'cost': cost
        }
    except Exception as e:
        logger.opt(exception=e).error(f"Ошибка в get_rent_info: {e}")
        return {}

app\dialogs\receive_email\keyboards.py
from aiogram_dialog.widgets.kbd import Group, Button
from aiogram_dialog.widgets.text import Const
from app.services import bot_texts as bt

def rent_email_kb(on_click, is_free_week: bool):
    buttons = []
    # Только если бесплатная неделя ещё не использована
    if not is_free_week:
        buttons.append(Button(Const(bt.RENT_EMAIL_WEEK_BTN), id='rent_email_week', on_click=on_click))

    buttons.extend([
        Button(Const(bt.RENT_EMAIL_MONTH_BTN), id='rent_email_month', on_click=on_click),
        Button(Const(bt.RENT_EMAIL_SIX_MONTHS_BTN), id='rent_email_six_months', on_click=on_click),
        Button(Const(bt.RENT_EMAIL_YEAR_BTN), id='rent_email_year', on_click=on_click),
    ])

    return Group(*buttons)



def rent_email_discount_kb(on_click):
    return Group(
        Button(Const(bt.RENT_EMAIL_WEEK_BTN_DISCOUNT), id='rent_email_week_discount', on_click=on_click),
        Button(Const(bt.RENT_EMAIL_MONTH_BTN_DISCOUNT), id='rent_email_month_discount', on_click=on_click),
        Button(Const(bt.RENT_EMAIL_SIX_MONTHS_BTN_DISCOUNT), id='rent_email_six_months_discount', on_click=on_click),
        Button(Const(bt.RENT_EMAIL_YEAR_BTN_DISCOUNT), id='rent_email_year_discount', on_click=on_click),
        id='rent_email_discount_kb',
        width=1
    )

app\dialogs\receive_email\selected.py
from datetime import timedelta
import asyncio
from aiogram import types
from aiogram.utils.keyboard import InlineKeyboardBuilder
from aiogram_dialog import DialogManager, StartMode
from aiogram_dialog.widgets.kbd import Button
from tortoise import timezone
from loguru import logger
from app.db import models
from app.dialogs.receive_email.states import ReceiveEmailMenu
from app.services.bot_texts import RENT_DATA, RENT_DATA_DISCOUNT
from app.services.low_balance import check_low_balance, send_low_balance_alert
from app.services.mail.temp_mail_tm import create_mail
from app.services.temp_mail import TempMail
from app.services import bot_texts as bt


async def on_back_mail(c: types.CallbackQuery, widget: Button, manager: DialogManager):
    """
    Обработчик для кнопки "Назад" в меню почтовых ящиков.
    Переключает состояние диалога на основное меню почтовых ящиков.

    :param c: Объект CallbackQuery.
    :param widget: Объект Button.
    :param manager: Объект DialogManager.
    """
    try:
        user_id = c.from_user.id
        logger.bind(user_id=user_id, action='on_back_mail').log("USER_ACTION", "Возврат к меню почтовых ящиков")

        user = await models.User.get_user(user_id)
        if not user:
            return

        await manager.switch_to(ReceiveEmailMenu.receive_email)
    except Exception as e:
        logger.opt(exception=e).error(f"Ошибка в on_back_mail: {e}")


async def on_change_email(c: types.CallbackQuery, widget: Button, manager: DialogManager):
    """
    Обработчик для кнопки "Изменить почтовый ящик".
    Генерирует новый почтовый ящик и сохраняет его в базе данных.

    :param c: Объект CallbackQuery.
    :param widget: Объект Button.
    :param manager: Объект DialogManager.
    """
    try:
        user_id = c.from_user.id
        logger.bind(user_id=user_id, action='on_change_email').log("USER_ACTION", "Запрос на смену почтового ящика")

        ctx = manager.current_context()
        mail_id = ctx.dialog_data.get('mail_id')
        if not mail_id:
            logger.bind(user_id=user_id, action='on_change_email').log("USER_ACTION", "ID почты не найден")
            await c.answer("Не найден идентификатор почты.", show_alert=True)
            return

        mail = await models.Mail.get_mail(mail_id)
        if mail:
            mail.is_active = False
            await mail.save(update_fields=['is_active'])

        user = await models.User.get_user(user_id)
        email, token = await create_mail()

        if not email or not token:
            logger.bind(user_id=user_id, action='on_change_email').log("USER_ACTION", "Ошибка при создании почты")
            await c.answer("Ошибка при создании почтового ящика. Попробуйте позже.", show_alert=True)
            return

        mail = await models.Mail.add_mail(user, email, token)
        ctx.start_data['mail_id'] = mail.id
        ctx.dialog_data['mail_id'] = mail.id

        logger.bind(user_id=user_id, action='on_change_email').log("USER_ACTION", f"Создана новая почта: {email}")

        await manager.start(
            ReceiveEmailMenu.receive_email,
            data={"mail_id": mail.id},
            mode=StartMode.RESET_STACK
        )
    except Exception as e:
        logger.opt(exception=e).error(f"Ошибка в on_change_email: {e}")


async def on_rent_email(c: types.CallbackQuery, widget: Button, manager: DialogManager):
    """
    Обработчик для кнопки "Арендовать почтовый ящик".
    Переключает состояние диалога на меню аренды почтового ящика,
    выбирая нужное окно в зависимости от доступности бесплатной недели.

    :param c: Объект CallbackQuery.
    :param widget: Объект Button.
    :param manager: Объект DialogManager.
    """
    try:
        user_id = c.from_user.id
        logger.bind(user_id=user_id, action='on_rent_email').log("USER_ACTION", "Переход к аренде почты")

        user = await models.User.get_user(user_id)
        mail = await models.Mail.filter(user=user).order_by('-id').first()

        if not mail:
            logger.bind(user_id=user_id, action='on_rent_email').log(
                "USER_ACTION", "Не найдена почта, связанная с пользователем"
            )
            await c.answer("Не удалось найти почтовый ящик", show_alert=True)
            return

        # Проверка флага бесплатной недели
        if mail.is_free_week:
            await manager.switch_to(ReceiveEmailMenu.rent_email_no_free_week)
            logger.bind(user_id=user_id, action='on_rent_email').log(
                "USER_ACTION", "Открыто окно аренды без бесплатной недели"
            )
        else:
            await manager.switch_to(ReceiveEmailMenu.rent_email)
            logger.bind(user_id=user_id, action='on_rent_email').log(
                "USER_ACTION", "Открыто окно аренды с бесплатной неделей"
            )

    except Exception as e:
        logger.opt(exception=e).error(f"Ошибка в on_rent_email: {e}")



async def on_rent_email_item(c: types.CallbackQuery, widget: Button, manager: DialogManager):
    """
    Обработчик для выбора периода аренды почтового ящика.
    Проверяет баланс пользователя и переключает состояние диалога на подтверждение аренды
    или уведомление о недостаточном балансе.

    :param c: Объект CallbackQuery.
    :param widget: Объект Button.
    :param manager: Объект DialogManager.
    """
    try:
        user_id = c.from_user.id
        logger.bind(user_id=user_id, action='on_rent_email_item').log("USER_ACTION", "Выбран период аренды")

        from app.dialogs.personal_cabinet.selected import on_deposit_state
        widget_id = widget.widget_id

        user = await models.User.get_user(user_id)

        ctx = manager.current_context()
        ctx.dialog_data['cost'] = RENT_DATA[widget_id][0]
        ctx.dialog_data['rent_days'] = RENT_DATA[widget_id][1]
        ctx.dialog_data['rent_text'] = RENT_DATA[widget_id][2]

        mail = await models.Mail.get_mail(mail_id=ctx.dialog_data['mail_id'])
        if not mail:
            logger.bind(user_id=user_id, action='on_rent_email_item').log(
                "USER_ACTION",
                "Почта не найдена по mail_id"
            )
            return

        # Проверка: если пользователь пытается повторно арендовать бесплатную неделю
        if widget_id == "rent_email_week" and mail.is_free_week:
            logger.bind(user_id=user_id, action='on_rent_email_item').log(
                "USER_ACTION",
                "Попытка повторной аренды бесплатной недели"
            )
            await c.answer("Вы уже использовали бесплатную неделю", show_alert=True)
            return

        ctx.dialog_data['email'] = mail.email

        if user.balance < ctx.dialog_data['cost']:
            logger.bind(user_id=user_id, action='on_rent_email_item').log(
                "USER_ACTION",
                f"Недостаточно средств для аренды: требуется {ctx.dialog_data['cost']}, доступно {user.balance}"
            )
            await on_deposit_state(c=c, widget=widget, manager=manager)
            return

        logger.bind(user_id=user_id, action='on_rent_email_item').log(
            "USER_ACTION",
            f"Аренда почты '{ctx.dialog_data['email']}' на {ctx.dialog_data['rent_text']}"
        )

        await manager.switch_to(ReceiveEmailMenu.rent_email_confirm)

    except Exception as e:
        logger.opt(exception=e).error(f"Ошибка в on_rent_email_item: {e}")



async def on_rent_email_item_discount(c: types.CallbackQuery, widget: Button, manager: DialogManager):
    """
    Обработчик для выбора периода аренды почтового ящика со скидкой.
    Проверяет баланс пользователя и переключает состояние диалога на подтверждение аренды или уведомление о недостаточном балансе.

    :param c: Объект CallbackQuery.
    :param widget: Объект Button.
    :param manager: Объект DialogManager.
    """
    try:
        user_id = c.from_user.id
        logger.bind(user_id=user_id, action='on_rent_email_item_discount').log("USER_ACTION", "Выбор аренды со скидкой")

        from app.dialogs.personal_cabinet.selected import on_deposit_state
        widget_id = widget.widget_id

        user = await models.User.get_user(user_id)
        if user.discount_used is True:
            rent_data = RENT_DATA  # Используем обычные данные аренды
        else:
            rent_data = RENT_DATA_DISCOUNT  # Используем данные аренды со скидкой

        ctx = manager.current_context()

        cost = rent_data[widget_id][0]
        days = rent_data[widget_id][1]
        text = rent_data[widget_id][2]

        ctx.dialog_data.update({'cost': cost, 'rent_days': days, 'rent_text': text})

        mail = await models.Mail.get_mail(mail_id=ctx.start_data['mail_id'])
        if not mail:
            return

        ctx.dialog_data['email'] = mail.email

        if user.balance < cost:
            logger.bind(user_id=user_id, action='on_rent_email_item_discount').log(
                "USER_ACTION",
                f"Недостаточно средств для аренды со скидкой: требуется {cost}, доступно {user.balance}"
            )
            await on_deposit_state(c=c, widget=widget, manager=manager)
            return

        if user.discount_used is not True:
            user.discount_used = True
            await user.save()
            logger.bind(user_id=user_id, action='on_rent_email_item_discount').log(
                "USER_ACTION",
                "Пользователь использовал скидку"
            )

        logger.bind(user_id=user_id, action='on_rent_email_item_discount').log(
            "USER_ACTION",
            f"Аренда почты '{ctx.dialog_data['email']}' на {text} по скидке"
        )

        await manager.switch_to(ReceiveEmailMenu.rent_email_confirm)
    except Exception as e:
        logger.opt(exception=e).error(f"Ошибка в on_rent_email_item_discount: {e}")


async def on_rent_email_check_discount(message: types.Message, manager: DialogManager):
    """
    Проверяет, предлагалась ли пользователю скидка, и переключает на соответствующее окно.

    :param message: Объект Message.
    :param manager: Объект DialogManager.
    """
    try:
        user_id = message.from_user.id
        logger.bind(user_id=user_id, action='on_rent_email_check_discount').log(
            "USER_ACTION",
            "Проверка наличия скидки у пользователя"
        )

        user = await models.User.get(telegram_id=user_id)
        last_mail = await models.Mail.filter(user=user, notification_sent=True).order_by('-id').first()

        if user.discount_used is True:
            logger.bind(user_id=user_id, action='on_rent_email_check_discount').log(
                "USER_ACTION",
                "Скидка уже была использована"
            )
            await manager.start(ReceiveEmailMenu.rent_email_no_discount, data={"mail_id": last_mail.id})
        else:
            logger.bind(user_id=user_id, action='on_rent_email_check_discount').log(
                "USER_ACTION",
                "Скидка ещё не использована"
            )
            await manager.start(ReceiveEmailMenu.rent_email_discount, data={"mail_id": last_mail.id})
    except Exception as e:
        logger.opt(exception=e).error(f"Ошибка в on_rent_email_check_discount: {e}")


async def on_confirm_rent_email(c: types.CallbackQuery, widget: Button, manager: DialogManager):
    """
    Обработчик для подтверждения аренды почтового ящика.
    Обновляет информацию о почтовом ящике и балансе пользователя в базе данных.

    :param c: Объект CallbackQuery.
    :param widget: Объект Button.
    :param manager: Объект DialogManager.
    """
    try:
        user_id = c.from_user.id
        logger.bind(user_id=user_id, action='on_confirm_rent_email').log("USER_ACTION", "Подтверждение аренды почты")

        ctx = manager.current_context()
        if 'email' in ctx.start_data:
            ctx.dialog_data = ctx.start_data

        mail_id = ctx.dialog_data.get('mail_id')
        cost = ctx.dialog_data.get('cost')
        rent_days = ctx.dialog_data.get('rent_days')  # Получаем длительность аренды

        user = await models.User.get_user(user_id)
        if not user:
            return

        if user.balance < cost and cost > 0:
            logger.bind(user_id=user_id, action='on_confirm_rent_email').log(
                "USER_ACTION",
                f"Недостаточно средств для аренды: требуется {cost}, доступно {user.balance}"
            )
            await manager.switch_to(ReceiveEmailMenu.not_enough_balance)
            return

        mail = await models.Mail.get_mail(mail_id)
        if not mail:
            return

        # Устанавливаем флаг бесплатной недели и days только если арендована неделя
        is_free_week = rent_days == 7

        mail.is_paid_mail = True
        mail.expire_at = timezone.now() + timedelta(days=rent_days)
        mail.is_active = True
        mail.days = rent_days  # Устанавливаем длительность аренды
        mail.is_free_week = is_free_week  # Устанавливаем флаг бесплатной недели

        await mail.save(update_fields=['is_paid_mail', 'expire_at', 'is_active', 'days', 'is_free_week'])

        low_balance = await check_low_balance(user, cost)

        # Деньги списываем только если аренда платная
        if cost > 0:
            user.balance -= cost
            await user.save(update_fields=['balance'])

        logger.bind(user_id=user_id, action='on_confirm_rent_email').log(
            "USER_ACTION",
            f"Успешная аренда почты '{mail.email}' на {ctx.dialog_data['rent_days']} дней"
        )

        ctx.dialog_data['email'] = mail.email
        await manager.switch_to(ReceiveEmailMenu.rent_email_success)
        await asyncio.sleep(2)

        if low_balance:
            await send_low_balance_alert(user)
    except Exception as e:
        logger.opt(exception=e).error(f"Ошибка в on_confirm_rent_email: {e}")



async def on_my_rent_emails(c: types.CallbackQuery, widget: Button, manager: DialogManager):
    """
    Обработчик для кнопки "Мои арендованные почтовые ящики".
    Отображает список арендованных почтовых ящиков пользователя.

    :param c: Объект CallbackQuery.
    :param widget: Объект Button.
    :param manager: Объект DialogManager.
    """
    try:
        user_id = c.from_user.id
        logger.bind(user_id=user_id, action='on_my_rent_emails').log("USER_ACTION", "Запрос списка арендованных почт")

        user = await models.User.get_user(user_id)
        if not user:
            return

        mails = await models.Mail.filter(user=user, is_paid_mail=True, is_active=True).all()
        if len(mails) == 0:
            logger.bind(user_id=user_id, action='on_my_rent_emails').log(
                "USER_ACTION",
                "Нет арендованных почт"
            )
            await c.answer(text='У вас нет арендованных почтовых ящиков', show_alert=True)
            return

        builder = InlineKeyboardBuilder()
        for mail in mails:
            builder.add(types.InlineKeyboardButton(text=mail.email, callback_data=f'mail:{mail.id}'))

        builder.button(text=bt.BACK_BTN, callback_data='receive_email')
        builder.adjust(1)

        logger.bind(user_id=user_id, action='on_my_rent_emails').log(
            "USER_ACTION",
            f"Отображено {len(mails)} арендованных почт"
        )

        await c.message.edit_text(text='Выберите почтовый ящик', reply_markup=builder.as_markup())
        await manager.reset_stack(remove_keyboard=False)
    except Exception as e:
        logger.opt(exception=e).error(f"Ошибка в on_my_rent_emails: {e}")

app\dialogs\receive_email\states.py
from aiogram.fsm.state import StatesGroup, State


class ReceiveEmailMenu(StatesGroup):
    receive_email = State()
    rent_email = State()
    rent_email_confirm = State()
    rent_email_success = State()
    not_enough_balance = State()
    rent_email_discount = State()  # Состояние для аренды с учетом скидки
    rent_email_no_free_week = State()
    rent_email_no_discount = State()  # Состояние для аренды без скидки


app\dialogs\receive_email\windows.py
import operator

from aiogram import F
from aiogram_dialog import Window
from aiogram_dialog.widgets.kbd import Cancel, Back, Button
from aiogram_dialog.widgets.text import Const, Format


from app.dialogs.receive_email import states
from app.dialogs.receive_email.getters import get_email_info, get_balance
from app.dialogs.receive_email.keyboards import rent_email_kb, rent_email_discount_kb
from app.dialogs.receive_email.selected import on_change_email, on_rent_email, on_rent_email_item, \
    on_confirm_rent_email, on_back_mail, on_my_rent_emails, on_rent_email_item_discount
from app.services import bot_texts as bt
from app.services.bot_texts import RENT_EMAIL_DISCOUNT_PROMO, RENT_EMAIL_NO_DISCOUNT


def receive_email_window():
    """
    Создает окно для отображения информации о текущем почтовом ящике пользователя и предоставляет кнопки для изменения
    почтового ящика, аренды нового и просмотра арендованных ящиков.

    :return: Объект Window для отображения информации о почтовом ящике.
    """

    return Window(
        Format(bt.MY_EMAIL),  # Форматированный текст с информацией о почтовом ящике
        Button(Const(bt.CHANGE_EMAIL_BTN), id='change_email', on_click=on_change_email),
        # Кнопка для изменения почтового ящика
        Button(Const(bt.RENT_EMAIL_BTN), id='rent_email', on_click=on_rent_email),
        # Кнопка для аренды нового почтового ящика
        Button(
            Const(bt.MY_RENT_EMAILS_BTN),
            id='my_rent_emails_btn',
            on_click=on_my_rent_emails,
            when=F['paid_mails_count'] > 0
            # Кнопка для просмотра арендованных ящиков, отображается только если есть арендованные ящики
        ),
        state=states.ReceiveEmailMenu.receive_email,  # Состояние окна
        getter=get_email_info  # Функция для получения информации о почтовом ящике
    )


def rent_email_window():
    buttons = rent_email_kb(on_rent_email_item, is_free_week=False)  # неделя ДОСТУПНА
    return Window(
        Format(bt.MY_EMAIL),
        buttons,
        Button(Const(bt.BACK_BTN), id='back_rent', on_click=on_back_mail),
        state=states.ReceiveEmailMenu.rent_email,
        getter=get_email_info,
    )

def rent_email_no_free_week():
    buttons = rent_email_kb(on_rent_email_item, is_free_week=True)  # неделя ИСПОЛЬЗОВАНА
    return Window(
        Format(bt.MY_EMAIL),
        buttons,
        Button(Const(bt.BACK_BTN), id='back_rent', on_click=on_back_mail),
        state=states.ReceiveEmailMenu.rent_email_no_free_week,
        getter=get_email_info,
    )


def confirm_rent_email_window():
    """
    Создает окно для подтверждения аренды почтового ящика.

    :return: Объект Window для подтверждения аренды.
    """

    return Window(
        Format(bt.CONFIRM_RENT_EMAIL),  # Форматированный текст с подтверждением аренды
        Button(Const(bt.CONFIRM_BTN), id='confirm_btn', on_click=on_confirm_rent_email),
        # Кнопка для подтверждения аренды
        Back(Const(bt.BACK_BTN)),  # Кнопка для возврата назад
        state=states.ReceiveEmailMenu.rent_email_confirm  # Состояние окна
    )


def not_enough_balance_window():
    """
    Создает окно для уведомления пользователя о недостаточном балансе и предоставляет кнопку для пополнения баланса.

    :return: Объект Window для уведомления о недостаточном балансе.
    """
    from app.dialogs.personal_cabinet.selected import on_deposit_state
    return Window(
        Format(bt.NOT_ENOUGH_BALANCE),  # Форматированный текст с уведомлением о недостаточном балансе
        Button(Const(bt.DEPOSIT_BTN), id='deposit_btn', on_click=on_deposit_state),  # Кнопка для пополнения баланса
        Back(Const(bt.BACK_BTN)),  # Кнопка для возврата назад
        state=states.ReceiveEmailMenu.not_enough_balance,  # Состояние окна
        getter=get_balance  # Функция для получения текущего баланса пользователя
    )


def rent_email_success_window():
    """
    Создает окно для уведомления пользователя об успешной аренде почтового ящика и предоставляет кнопку для просмотра арендованных ящиков.

    :return: Объект Window для уведомления об успешной аренде.
    """
    return Window(
        Format(bt.RENT_EMAIL_SUCCESS),  # Форматированный текст с уведомлением об успешной аренде
        Button(Const(bt.MY_RENT_EMAILS_BTN), id='my_rent_emails_btn', on_click=on_my_rent_emails),
        # Кнопка для просмотра арендованных ящиков
        state=states.ReceiveEmailMenu.rent_email_success  # Состояние окна
    )


def rent_email_discount_window():
    """
    Создает окно для выбора периода аренды почтового ящика со скидкой.

    :return: Объект Window для выбора периода аренды со скидкой.
    """
    return Window(Const(RENT_EMAIL_DISCOUNT_PROMO),
        rent_email_discount_kb(on_rent_email_item_discount),
        state=states.ReceiveEmailMenu.rent_email_discount,
        getter=get_email_info
    )

def rent_email_no_discount_window():
    """
    Создает окно для выбора периода аренды почтового ящика без скидки.

    :return: Объект Window для выбора периода аренды без скидки.
    """
    return Window(Const(RENT_EMAIL_NO_DISCOUNT),
        rent_email_kb(on_rent_email_item_discount, is_free_week=True),
        state=states.ReceiveEmailMenu.rent_email_no_discount,
        getter=get_email_info
    )


app\dialogs\receive_email\__init__.py
from aiogram_dialog import Dialog

from app.dialogs.receive_email import windows


def receive_email_dialogs():
    return [
        Dialog(
            windows.rent_email_window(),
            windows.receive_email_window(),
            windows.confirm_rent_email_window(),
            windows.not_enough_balance_window(),
            windows.rent_email_success_window(),
            windows.rent_email_discount_window(),  # окно для аренды со скидкой
            windows.rent_email_no_discount_window(),  # окно для аренды без скидки
        )
    ]


app\dialogs\receive_sms\getters.py
from aiogram_dialog import DialogManager
from app.db import models
from app.services.sms_receive import SmsReceive
from loguru import logger


async def get_countries_service(dialog_manager: DialogManager, **middleware_data):
    """
    Получает список стран с ценами для услуги.

    Аргументы:
    dialog_manager (DialogManager): Менеджер диалогов.
    **middleware_data: Дополнительные данные middleware.

    Возвращает:
    dict: Словарь с отфильтрованными странами и кодом услуги.
    """
    try:
        ctx = dialog_manager.current_context()

        # Проверяем, существует ли start_data и является ли она словарем
        if not ctx.start_data or not isinstance(ctx.start_data, dict):
            return {"countries": [], "service_code": None}

        countries_with_prices = ctx.start_data.get("countries_with_prices")
        service_code = ctx.start_data.get("service_code")
        search_name = ctx.dialog_data.get('search_name') if ctx.dialog_data else None

        # Фильтровать страны по поисковому имени, если оно существует.
        if countries_with_prices is not None:
            if search_name:
                filtered_countries = [
                    {"id": idx, "country": item['country'], "price": item['price']}
                    for idx, item in enumerate(countries_with_prices)
                    if item['country'] == search_name
                ]
            else:
                filtered_countries = [
                    {"id": idx, "country": item['country'], "price": item['price']}
                    for idx, item in enumerate(countries_with_prices)
                ]
        else:
            filtered_countries = []

        data = {
            "countries": filtered_countries,
            "service_code": service_code
        }
        return data

    except Exception as e:
        logger.error(e)


async def get_services(dialog_manager: DialogManager, **middleware_data):
    """
    Получает список услуг для указанной страны.

    Аргументы:
    dialog_manager (DialogManager): Менеджер диалогов.
    **middleware_data: Дополнительные данные middleware.

    Возвращает:
    dict: Словарь с отфильтрованными услугами.
    """
    ctx = dialog_manager.current_context()
    country_id = ctx.start_data.get("country_id")
    if country_id is None:
        return {"services": []}

    search_service_name = ctx.dialog_data.get("search_service_name")
    if search_service_name is not None:
        find_services = await models.ServicesSmsActivate.search_service(search_service_name)
        find_services_codes = list(map(lambda x: x.code, find_services))
    else:
        find_services_codes = None

    sms = SmsReceive()
    services = await sms.get_services_by_country_id(country_id=country_id)
    services_list = []
    for service in services:
        # Пропустить услуги с количеством меньше 5.
        if service['count'] < 5:
            continue

        service_obj = await models.ServicesSmsActivate.get_service(code=service['code'])
        if service_obj is None:
            continue

        # Пропустить услуги, не найденные в find_services_codes.
        if find_services_codes is not None and service_obj.code not in find_services_codes:
            continue

        service_data = {
            'code': service['code'],
            'cost': service['cost'],
            'name': service_obj.name
        }

        services_list.append(service_data)

    data = {
        "services": services_list
    }
    return data


async def service_is_smsactivate():
    return await models.AdminSettings.get_setting_value("sms_rental_service") == "SMS_Activate"


async def get_services_2(dialog_manager: DialogManager, **middleware_data):
    """
    Получает список всех услуг либо из контекста, либо из базы данных.

    Аргументы:
    dialog_manager (DialogManager): Менеджер диалогов.
    **middleware_data: Дополнительные данные middleware.

    Возвращает:
    list: Список услуг.
    """
    ctx = dialog_manager.current_context()
    services_data = ctx.dialog_data.get('services', [])
    if services_data:
        return services_data
    else:
        if await service_is_smsactivate():
            services_db = await models.ServicesSmsActivate.get_services()
        else:
            services_db = await models.PriceOnlinesim.get_all_services()
            services_db["services"].extend([
                {"code": "ts", "name": "PayPal"},
                {"code": "ot", "name": "Любой другой"}
            ])

            priority_codes = {"telegram", "google", "vkcom", "whatsapp"}
            priority_services = [s for s in services_db["services"] if s["code"] in priority_codes]
            other_services = [s for s in services_db["services"] if s["code"] not in priority_codes]

            services_db["services"] = priority_services + other_services
        return services_db



async def get_other_service(dialog_manager: DialogManager, **middleware_data):
    """
    Получает другую услугу для указанной страны.

    Аргументы:
    dialog_manager (DialogManager): Менеджер диалогов.
    **middleware_data: Дополнительные данные middleware.

    Возвращает:
    dict: Словарь с услугами.
    """
    pass
    # ctx = dialog_manager.current_context()
    # country_id = ctx.start_data.get("country_id")
    # if country_id is None:
    #     return {"services": []}
    #
    # sms = SmsReceive()
    # services = await sms.get_services_by_country_id(country_id=country_id)
    # services_list = []
    # for service in services:
    #     if service['code'] != 'ot':
    #         continue
    #
    #     service_obj = await models.Service.get_service(code=service['code'])
    #     service_data = {
    #         'code': service['code'],
    #         'cost': service['cost'],
    #         'name': service_obj.name
    #     }
    #
    #     services_list.append(service_data)
    #     break
    #
    # data = {
    #     "services": services_list
    # }
    # return data


async def get_need_balance(dialog_manager: DialogManager, **middleware_data):
    """
    Получает баланс пользователя и стоимость услуги.

    :param dialog_manager: Менеджер диалога.
    :param middleware_data: Дополнительные данные из промежуточного слоя.
    :return: Словарь с данными о стоимости и балансе.
    """
    # Получаем текущий контекст диалога
    ctx = dialog_manager.current_context()
    # Получаем стоимость услуги из данных диалога
    service_cost = ctx.dialog_data.get("service_cost")
    # Получаем пользователя по его идентификатору
    user = await models.User.get_user(dialog_manager.event.from_user.id)
    # Формируем словарь с данными о стоимости и балансе
    data = {
        "cost": service_cost,
        "balance": user.balance
    }
    return data


async def get_all_services(dialog_manager: DialogManager, **middleware_data):
    """
    Получает список всех доступных услуг в определенной стране.

    :param dialog_manager: Менеджер диалога.
    :param middleware_data: Дополнительные данные из промежуточного слоя.
    :return: Словарь с данными о доступных услугах.
    """
    # Получаем текущий контекст диалога
    ctx = dialog_manager.current_context()
    # Получаем идентификатор страны из данных запуска диалога
    country_id = ctx.start_data.get("country_id")
    if country_id is None:
        # Если идентификатор страны не указан, возвращаем пустой список услуг
        return {"services": []}

    # Получаем имя услуги для поиска из данных диалога
    search_service_name = ctx.dialog_data.get("search_service_name")
    if search_service_name is not None:
        # Если указано имя услуги для поиска, выполняем поиск
        find_services = await models.ServicesSmsActivate.search_service(search_service_name)
        # Получаем список кодов найденных услуг
        find_services_codes = list(map(lambda x: x.code, find_services))
    else:
        find_services_codes = None

    # Создаем экземпляр класса SmsReceive для работы с SMS-сервисами
    sms = SmsReceive()
    # Получаем список услуг по идентификатору страны
    services = await sms.get_services_by_country_id(country_id=country_id)
    services_list = []
    for service in services:
        if service['count'] < 5:
            # Если количество доступных номеров меньше 5, пропускаем услугу
            continue

        # Получаем объект услуги из модели Service по коду услуги
        service_obj = await models.ServicesSmsActivate.get_service(code=service['code'])
        if service_obj is None:
            # Если объект услуги не найден, пропускаем услугу
            continue

        if find_services_codes is not None and service_obj.code not in find_services_codes:
            # Если указано имя услуги для поиска и код услуги не находится в списке найденных услуг, пропускаем услугу
            continue

        # Формируем словарь с данными об услуге
        service_data = {
            'code': service['code'],
            'cost': service['cost'],
            'name': service_obj.name
        }

        # Добавляем данные об услуге в список
        services_list.append(service_data)

    # Формируем словарь с данными о доступных услугах
    data = {
        "services": services_list
    }
    return data


app\dialogs\receive_sms\scheduler_balance.py
from datetime import datetime, timedelta
from apscheduler.triggers.interval import IntervalTrigger
from apscheduler.triggers.date import DateTrigger
from app.db import models
from app.dialogs.receive_sms.selected import send_service_on_country
from app.scheduler_instance import scheduler
from loguru import logger


# Асинхронная функция для проверки баланса и отправки сервиса
async def check_balance_and_send_service(user_id, price, retail_price, free_price_map, country_id, service_code, c, manager):
    try:
        # Получаем информацию о пользователе из базы данных
        user = await models.User.get_user(user_id)

        # Если баланс пользователя достаточен, отправляем услугу
        if user.balance >= price:
            logger.bind(user_id=user_id, action='check_balance_and_send_service').log(
                "USER_ACTION",
                f"Баланс достаточен. Отправка услуги: страна={country_id}, сервис={service_code}"
            )
            await send_service_on_country(
                country_id=country_id,
                service_code=service_code,
                price=price,
                retail_price=retail_price,
                free_price_map=free_price_map,
                c=c,
                manager=manager
            )
            # Удаляем задачу проверки баланса после успешного выполнения
            scheduler.remove_job(f'balance_check_sms_{user_id}')
    except Exception as e:
        logger.opt(exception=e).error(f"Ошибка в check_balance_and_send_service: {e}")


# Асинхронная функция для запуска проверки баланса
async def start_balance_check(user_id, price, retail_price, free_price_map, country_id, service_code, c, manager):
    try:
        logger.bind(user_id=user_id, action='start_balance_check').log(
            "USER_ACTION",
            f"Запуск проверки баланса для услуги: цена={price}, страна={country_id}, сервис={service_code}"
        )

        # Генерируем уникальный идентификатор задачи с меткой времени
        job_id = f'balance_check_sms_{user_id}'

        # Добавляем задачу для периодической проверки баланса каждые 5 секунд
        scheduler.add_job(
            check_balance_and_send_service,
            IntervalTrigger(seconds=5),
            args=[user_id, price, retail_price, free_price_map, country_id, service_code, c, manager],
            id=job_id,
            replace_existing=True  # Заменяем существующую задачу с тем же ID
        )

        # Определяем время завершения задачи (через 5 минут)
        end_time = datetime.now() + timedelta(minutes=5)

        # Добавляем отдельную задачу для остановки проверки баланса по истечении времени
        scheduler.add_job(
            lambda: scheduler.remove_job(job_id),  # Лямбда-функция для удаления задачи
            DateTrigger(run_date=end_time),  # Запускаем через 5 минут
            id=f'stop_{job_id}'  # Уникальный ID для задачи остановки
        )
    except Exception as e:
        logger.opt(exception=e).error(f"Ошибка в start_balance_check: {e}")

app\dialogs\receive_sms\selected.py
from datetime import datetime, timedelta
import pytz
import math
import asyncio
from loguru import logger
from aiogram import types
from aiogram_dialog import DialogManager, StartMode
from aiogram_dialog.widgets.input import TextInput
from aiogram_dialog.widgets.kbd import Select, Button
from pyonlinesim import OnlineSMS
from app.db import models
from app.db.models import PriceOnlinesim
from app.dependencies import API_KEY_ONLINESIM, ADMINS, bot
from app.dialogs.receive_sms.getters import service_is_smsactivate
from app.dialogs.receive_sms.states import ServiceMenu, CountryMenu
from app.dialogs.rent_sms.states import RentCountryMenu
from app.services.bot_texts import country_flags, sort_countries, SERVICES_TRANSLATION, \
    REVERSE_SERVICES_TRANSLATION, NUMBER_REQUEST_SENT, PLEASE_WAIT_SECONDS, DOLLAR_ONLINESIM, DOLLAR_SMS_ACTIVATE, \
    SMS_ACTIVATE_SERVICE_CODES_AT_ONLINESIM, NOT_NUMBERS_ALERT, list_for_sorting_countries_for_telegram
from app.services.low_balance import check_low_balance, send_low_balance_alert
from app.services.onlinesim.get_tariffs import fetch_tariffs
from app.services.sms_receive import SmsReceive
from app.services import bot_texts as bt


@logger.catch()
async def on_select_service(c: types.CallbackQuery, widget: Select, manager: DialogManager, code: str):
    """
    Обрабатывает выбор сервиса пользователем и отправляет информацию о сервисе.
    :param c: Объект CallbackQuery от aiogram.
    :param widget: Виджет Select от aiogram_dialog.
    :param manager: Менеджер диалогов от aiogram_dialog.
    :param code: Код выбранного сервиса.
    """
    try:
        user_id = c.from_user.id
        logger.bind(user_id=user_id, action='on_select_service').log(
            "USER_ACTION",
            f"Выбран сервис: {code}"
        )
        await send_country_info(code, c, manager)
    except Exception as e:
        logger.opt(exception=e).error(f"Ошибка в on_select_service: {e}")


@logger.catch()
async def on_search_service(c: types.CallbackQuery, widget: Button, manager: DialogManager):
    """
    Обрабатывает нажатие кнопки поиска сервиса и переводит на меню ввода сервиса.
    :param c: Объект CallbackQuery от aiogram.
    :param widget: Виджет Button от aiogram_dialog.
    :param manager: Менеджер диалогов от aiogram_dialog.
    """
    try:
        user_id = c.from_user.id
        logger.bind(user_id=user_id, action='on_search_service').log(
            "USER_ACTION",
            "Переход к поиску сервиса"
        )
        await manager.switch_to(ServiceMenu.enter_service)
    except Exception as e:
        logger.opt(exception=e).error(f"Ошибка в on_search_service: {e}")


@logger.catch()
async def on_result_service(m: types.Message, widget: TextInput, manager: DialogManager, service_name: str):
    """
    Обрабатывает результат поиска сервиса по введенному названию.
    :param m: Объект Message от aiogram.
    :param widget: Виджет TextInput от aiogram_dialog.
    :param manager: Менеджер диалогов от aiogram_dialog.
    :param service_name: Название сервиса, введенное пользователем.
    """
    try:
        user_id = m.from_user.id
        logger.bind(user_id=user_id, action='on_result_service').log(
            "USER_ACTION",
            f"Поиск сервиса: {service_name}"
        )

        if await service_is_smsactivate():
            services = await models.ServicesSmsActivate.search_service(service_name.lower())
        else:
            services = await models.ServicesOnlinesim.search_service(service_name.lower())

        if not services:
            logger.bind(user_id=user_id, action='on_result_service').log(
                "USER_ACTION",
                "Сервис не найден"
            )
            await manager.switch_to(ServiceMenu.enter_service_error)
            return

        services_data = [{'code': service.code, 'name': service.name} for service in services]
        ctx = manager.current_context()
        ctx.dialog_data["services"] = {'services': services_data}

        logger.bind(user_id=user_id, action='on_result_service').log(
            "USER_ACTION",
            f"Найдено сервисов: {len(services)}"
        )
        await manager.switch_to(ServiceMenu.select_service)
    except Exception as e:
        logger.opt(exception=e).error(f"Ошибка в on_result_service: {e}")


@logger.catch()
async def on_select_country_new(c: types.CallbackQuery, widget: Select, manager: DialogManager, country_index: str):
    """
    Обрабатывает выбор страны и сервиса.
    :param c: Объект CallbackQuery от aiogram.
    :param widget: Виджет Select от aiogram_dialog.
    :param manager: Менеджер диалогов от aiogram_dialog.
    :param country_index: Индекс выбранной страны.
    """
    try:
        user_id = c.from_user.id
        logger.bind(user_id=user_id, action='on_select_country_new').log(
            "USER_ACTION",
            f"Выбор страны по индексу: {country_index}"
        )

        ctx = manager.current_context()
        service_code = ctx.start_data.get('service_code')
        countries_with_prices = ctx.start_data.get('countries_with_prices', [])
        country_index = int(country_index)

        if 0 <= country_index < len(countries_with_prices):
            selected_country = countries_with_prices[country_index]
            country_name = selected_country['country']
            price = selected_country['price']
            free_price_map = selected_country.get('freePriceMap')
            if free_price_map is None:
                country_id = await models.CountriesOnlinesim.get_country_id_by_name(country_name)
                if await service_is_smsactivate():
                    service_code = SERVICES_TRANSLATION[service_code]
            else:
                country_id = await models.CountriesSmsActivate.get_country_id_by_name(country_name)

            retail_price = selected_country.get('retail_price')

            logger.bind(user_id=user_id, action='on_select_country_new').log(
                "USER_ACTION",
                f"Выбрана страна: {country_name}, цена: {price}, сервис: {service_code}"
            )

            await send_service_on_country(
                country_id=country_id,
                service_code=service_code,
                price=price,
                retail_price=retail_price,
                free_price_map=free_price_map,
                c=c,
                manager=manager
            )
        else:
            logger.bind(user_id=user_id, action='on_select_country_new').log(
                "USER_ACTION",
                f"Неверный индекс страны: {country_index}"
            )
    except Exception as e:
        logger.opt(exception=e).error(f"Ошибка в on_select_country_new: {e}")


@logger.catch()
async def on_search_country(c: types.CallbackQuery, widget: Button, manager: DialogManager):
    """
    Обрабатывает нажатие кнопки поиска страны и переводит на меню ввода страны.
    :param c: Объект CallbackQuery от aiogram.
    :param widget: Виджет Button от aiogram_dialog.
    :param manager: Менеджер диалогов от aiogram_dialog.
    """
    try:
        user_id = c.from_user.id
        logger.bind(user_id=user_id, action='on_search_country').log(
            "USER_ACTION",
            "Переход к поиску страны"
        )
        await manager.switch_to(CountryMenu.enter_country)
    except Exception as e:
        logger.opt(exception=e).error(f"Ошибка в on_search_country: {e}")


@logger.catch()
async def on_result_country(m: types.Message, widget: TextInput, manager: DialogManager, country_name: str):
    """
    Обрабатывает результат поиска страны по введенному названию.
    :param m: Объект Message от aiogram.
    :param widget: Виджет TextInput от aiogram_dialog.
    :param manager: Менеджер диалогов от aiogram_dialog.
    :param country_name: Название страны, введенное пользователем.
    """
    try:
        user_id = m.from_user.id
        logger.bind(user_id=user_id, action='on_result_country').log(
            "USER_ACTION",
            f"Поиск страны: {country_name}"
        )

        country_names = await models.CountriesSmsActivate.search_countries(country_name.lower())
        if len(country_names) == 0:
            logger.bind(user_id=user_id, action='on_result_country').log(
                "USER_ACTION",
                "Страна не найдена"
            )
            await manager.switch_to(CountryMenu.enter_country_error)
            return

        ctx = manager.current_context()
        ctx.dialog_data['search_name'] = country_names[0]
        await manager.switch_to(CountryMenu.select_country)
    except Exception as e:
        logger.opt(exception=e).error(f"Ошибка в on_result_country: {e}")


@logger.catch()
async def send_service_on_country(country_id: int, service_code: str, price: float, retail_price, free_price_map,
                                  c: types.CallbackQuery, manager: DialogManager = None):
    """
    Отправляет информацию о сервисе пользователю и обрабатывает активацию номера.
    :param country_id: Идентификатор страны.
    :param service_code: Код сервиса.
    :param price: Цена для клиента.
    :param retail_price: Цена сервиса.
    :param free_price_map: Дополнительные цены.
    :param c: Объект CallbackQuery от aiogram.
    :param manager: Менеджер диалогов от aiogram_dialog (опционально).
    """
    try:
        await c.answer()
        user_id = c.from_user.id
        logger.bind(user_id=user_id, action='send_service_on_country').log(
            "USER_ACTION",
            f"Запрос на активацию сервиса: страна={country_id}, сервис={service_code}, цена={price}"
        )

        # Получаем информацию о пользователе
        user = await models.User.get_user(user_id)

        # Проверяем, прошло ли 10 секунд с последнего запроса
        if user.last_request_time is not None and (
                datetime.now(pytz.utc) - user.last_request_time.astimezone(pytz.utc)).total_seconds() < 5:
            await c.answer(text=PLEASE_WAIT_SECONDS, show_alert=True)
            return

        current_time = datetime.now(pytz.timezone('Europe/Moscow'))
        user.last_request_time = current_time.astimezone(pytz.utc)
        await user.save(update_fields=['last_request_time'])

        # если onlinesim
        if not await service_is_smsactivate():
            tariffs = await fetch_tariffs(country_id, service_code)
            if tariffs is None:
                logger.bind(user_id=user_id, action='send_service_on_country').log(
                    "USER_ACTION",
                    "Нет доступных номеров OnlineSim"
                )
                await c.message.answer(text=NOT_NUMBERS_ALERT)
                return

        # Проверяем, достаточно ли средств на балансе
        if user.balance < price:
            missing_amount = max(price - user.balance, 50.0) if user.balance < price else 0.0
            manager.current_context().dialog_data.update({
                'country_id': country_id,
                'service_code': service_code,
                'retail_price': retail_price,
                'service_price': price,
                'price': missing_amount
            })
            from app.dialogs.personal_cabinet.selected import send_payment_keyboard
            await send_payment_keyboard(m=c, manager=manager, price=missing_amount)
            return

        sent_message = await c.message.answer(text=NUMBER_REQUEST_SENT)
        sent_message_id = sent_message.message_id

        if service_code not in SMS_ACTIVATE_SERVICE_CODES_AT_ONLINESIM:
            client = OnlineSMS(api_key=API_KEY_ONLINESIM)
            try:
                logger.bind(user_id=user_id, action='send_service_on_country').log(
                    "USER_ACTION",
                    f"OnlineSim"
                )
                order_number_response = await client.order_number(service=service_code, country=country_id)
                activation_id = order_number_response.get('tzid')
                phone_number = (await client.get_order_info(operation_id=activation_id))[0].get('number').lstrip('+')
                country = await models.CountriesOnlinesim.get_country_from_country_by_id(country_id=country_id)
                if await service_is_smsactivate():
                    key = REVERSE_SERVICES_TRANSLATION.get(service_code)
                    service = await models.ServicesSmsActivate.get_service(code=key)
                else:
                    service = await models.ServicesOnlinesim.get_service(code=service_code)
            except Exception as e:
                await c.message.answer(text=bt.NOT_NUMBERS_ALERT)
                error_message = str(e)
                logger.bind(user_id=user_id, action='send_service_on_country').log(
                    "USER_ACTION",
                    f"Ошибка при получении номера сервиса OnlineSim: {error_message}"
                )
                if "No available numbers for this service" in error_message:
                    await manager.switch_to(CountryMenu.select_country)
                    return
                if "Not enough funds" in error_message:
                    for admin_id in ADMINS:
                        await bot.send_message(
                            chat_id=admin_id,
                            text=(
                                "🚨 *Внимание, администратор!*\n"
                                "❌ На сервисе *OnlineSim* недостаточно средств для выполнения операции.\n"
                                f"📅 *Время*: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n"
                                f"💬 *Описание ошибки*: {error_message}"
                            ),
                            parse_mode="Markdown"
                        )
                await manager.switch_to(CountryMenu.select_country)
                return
        else:
            sms = SmsReceive()
            max_price = math.ceil(retail_price)
            phone_number_data = await sms.get_phone_number(country_id=country_id, service_code=service_code,
                                                           max_price=max_price)
            logger.bind(user_id=user_id, action='send_service_on_country').log(
                "USER_ACTION",
                f"SMSActivate"
            )
            if 'activationId' not in phone_number_data:
                max_price = math.ceil(retail_price * 1.05)
                phone_number_data = await sms.get_phone_number(country_id=country_id, service_code=service_code,
                                                             max_price=max_price)
                if 'activationId' not in phone_number_data:
                    await c.answer(text=bt.NOT_NUMBERS_ALERT, show_alert=True)
                    await manager.switch_to(CountryMenu.select_country)
                    return

            activation_id = int(phone_number_data['activationId'])
            phone_number = phone_number_data['phoneNumber']
            country = await models.CountriesSmsActivate.get_country_by_id(country_id=country_id)
            service = await models.ServicesSmsActivate.get_service(code=service_code)

        if await service_is_smsactivate() or service_code in SMS_ACTIVATE_SERVICE_CODES_AT_ONLINESIM:
            activation = await models.Activation.add_activation_sms_activate(
                user=user,
                activation_id=activation_id,
                country=country,
                service=service,
                cost=price,
                phone_number=phone_number,
                activation_expire_at=datetime.now(pytz.timezone("Europe/Moscow")).replace(microsecond=0) + timedelta(minutes=10)
            )
            service = activation.service.name
        else:
            activation = await models.Activation.add_activation_onlinesim(
                user=user,
                activation_id=activation_id,
                country=country,
                service_2=service,
                cost=price,
                phone_number=phone_number,
                activation_expire_at=datetime.now(pytz.timezone("Europe/Moscow")).replace(microsecond=0) + timedelta(minutes=10)
            )
            service = activation.service_2.name

        user.balance -= price
        await user.save(update_fields=['balance'])

        await bot.delete_message(chat_id=c.from_user.id, message_id=sent_message_id)
        try:
            country = activation.country.name
        except Exception as e:
            country = None
            logger.opt(exception=e).error(f"country = None")

        await send_service_info_with_keyboard(message=c.message, activation=activation, service=service, country=country)

        low_balance = await check_low_balance(user, price)
        await asyncio.sleep(1)
        if low_balance:
            await send_low_balance_alert(user)
    except Exception as e:
        logger.opt(exception=e).error(f"Ошибка в send_service_on_country: {e}")


@logger.catch()
async def send_service_info_with_keyboard(message: types.Message, activation, service, country):
    """
    Отправляет пользователю информацию о сервисе и номере телефона с клавиатурой.
    :param message: Сообщение для отправки.
    :param activation: Объект активации.
    :param service: Название сервиса.
    :param country: Страна.
    """

    buttons = []

    # Добавляем первую кнопку только если длина activation_id > 9
    if len(str(activation.activation_id)) > 8:
        buttons.append([types.InlineKeyboardButton(
            text=bt.RECEIVE_ANOTHER_SMS_TO_NUMBER,
            callback_data=f"request_code:{activation.id}"
        )])

    # Вторая и третья кнопки всегда добавляются
    buttons.append([types.InlineKeyboardButton(
        text=bt.CANCEL_SERVICE_BTN,
        callback_data=f"cancel_service:{activation.id}"
    )])
    buttons.append([types.InlineKeyboardButton(
        text=bt.REQUEST_ANOTHER_CODE,
        callback_data="receive_sms_for_another_service"
    )])

    mk = types.InlineKeyboardMarkup(inline_keyboard=buttons)
    country = country.strip()
    flag = country_flags.get(country, "")
    flag_and_country = f"{flag} {country}"

    if service != "Telegram":
        await message.answer(
            text=bt.SERVICE_INFO.format(
                country=flag_and_country,
                service=service,
                phone=activation.phone_number,
            ),
            reply_markup=mk
        )
    else:
        await message.answer(
            text=bt.SERVICE_INFO_TELEGRAM.format(
                country=flag_and_country,
                service=service,
                phone=activation.phone_number,
            ),
            reply_markup=mk
        )

    user_id = message.from_user.id
    logger.bind(user_id=user_id, action='send_service_info_with_keyboard').log(
        "USER_ACTION",
        f"Ваш номер: {activation.phone_number}"
    )


@logger.catch()
async def send_country_info(service_code: str, c: types.CallbackQuery, manager: DialogManager = None):
    """
    Отправляет информацию о сервисе пользователю и обрабатывает активацию номера.
    :param service_code: Код сервиса.
    :param c: Объект CallbackQuery от aiogram.
    :param manager: Менеджер диалогов от aiogram_dialog (опционально).
    """
    try:
        user_id = c.from_user.id
        logger.bind(user_id=user_id, action='send_country_info').log(
            "USER_ACTION",
            f"Запрос информации о сервисе: {service_code}"
        )

        if await service_is_smsactivate():
            if service_code in SERVICES_TRANSLATION:
                code_onlinesim = SERVICES_TRANSLATION.get(service_code)
                services = await PriceOnlinesim.get_service_data(code_onlinesim)
                sorted_countries_with_prices = [
                    {
                        "country": country,
                        "price": math.ceil(float(price) * DOLLAR_ONLINESIM),
                        "retail_price": int(price),
                        "freePriceMap": None
                    }
                    for country, price in services.items()
                ]
            else:
                sms = SmsReceive()
                services = await sms.get_top_country(service=service_code)
                if not services:
                    logger.bind(user_id=user_id, action='send_country_info').log(
                        "USER_ACTION",
                        f"Сервис не найден: {service_code}"
                    )
                    await c.answer("Извините, информация о сервисе недоступна.")
                    return

                filtered_services = services
                countries_with_prices = [
                    {
                        "country": service["country"],
                        "price": math.ceil(float(service["retail_price"]) * DOLLAR_SMS_ACTIVATE),
                        "retail_price": service.get("retail_price"),
                        "freePriceMap": service.get("freePriceMap")
                    }
                    for service in filtered_services.values()
                ]

                country_name_mapping = await models.CountriesSmsActivate.get_country_name_mapping()
                for country in countries_with_prices:
                    country_id = int(country["country"])
                    country["country"] = country_name_mapping.get(country_id, "Unknown Country")

                sorted_countries_with_prices = sort_countries_by_dict(countries_with_prices)

            await manager.start(CountryMenu.select_country, mode=StartMode.NORMAL,
                                data={"countries_with_prices": sorted_countries_with_prices,
                                      "service_code": service_code})
        else:
            if service_code not in SMS_ACTIVATE_SERVICE_CODES_AT_ONLINESIM:
                services = await PriceOnlinesim.get_service_data(service_code)

                sorted_countries_with_prices = [
                    {
                        "country": country,
                        "price": math.ceil(float(price) * DOLLAR_ONLINESIM),
                        "retail_price": int(price),
                        "freePriceMap": None
                    }
                    for country, price in services.items()
                ]
                if service_code == 'vkcom':
                    sorted_countries_with_prices = move_russia_first(sorted_countries_with_prices)
            else:
                sms = SmsReceive()
                services = await sms.get_top_country(service=service_code)
                if not services:
                    logger.bind(user_id=user_id, action='send_country_info').log(
                        "USER_ACTION",
                        f"Сервис не найден: {service_code}"
                    )
                    await c.answer("Извините, информация о сервисе недоступна в данный момент.")
                    return

                filtered_services = services
                countries_with_prices = [
                    {
                        "country": service["country"],
                        "price": math.ceil(float(service["retail_price"]) * DOLLAR_SMS_ACTIVATE),
                        "retail_price": service.get("retail_price"),
                        "freePriceMap": service.get("freePriceMap")
                    }
                    for service in filtered_services.values()
                ]

                country_name_mapping = await models.CountriesSmsActivate.get_country_name_mapping()
                for country in countries_with_prices:
                    country_id = int(country["country"])
                    country["country"] = country_name_mapping.get(country_id, "Unknown Country")

                sorted_countries_with_prices = sort_countries_by_dict(countries_with_prices)

            if service_code == 'telegram':
                sorted_countries_with_prices = await sort_countries_tg(sorted_countries_with_prices, list_for_sorting_countries_for_telegram)

            await manager.start(CountryMenu.select_country, mode=StartMode.NORMAL,
                                data={"countries_with_prices": sorted_countries_with_prices,
                                      "service_code": service_code})
    except Exception as e:
        logger.opt(exception=e).error(f"Ошибка в send_country_info: {e}")

async def back_country(c: types.CallbackQuery, widget: Button, manager: DialogManager):
    await manager.switch_to(CountryMenu.select_country)

def move_russia_first(country_list):
    for i, country_data in enumerate(country_list):
        if country_data.get("country") == "Россия":
            russia_entry = country_list.pop(i)
            country_list.insert(0, russia_entry)
            break
    return country_list


def sort_countries_by_dict(countries_with_prices):
    """
    Сортирует список стран с ценами в соответствии с порядком в countries_dict
    Args:
        countries_with_prices (list): Список словарей с информацией о странах и ценах
    Returns:
        list: Отсортированный список стран с ценами
    """
    order_dict = {country_id: position for position, country_id in enumerate(sort_countries.keys())}
    sorted_countries = sorted(
        countries_with_prices,
        key=lambda x: order_dict.get(x['country'], float('inf'))
    )
    return sorted_countries


def country_key(country_dict, priority_list):
    try:
        return (priority_list.index(country_dict["country"]),)
    except ValueError:
        return (len(priority_list),)


@logger.catch()
async def sort_countries_tg(data, priority_list):
    return sorted(data, key=lambda x: country_key(x, priority_list))

app\dialogs\receive_sms\states.py
from aiogram.fsm.state import StatesGroup, State


class CountryMenu(StatesGroup):
    select_country = State()
    deposit = State()
    enter_amount = State()
    payment_method = State()
    payment_method_anypay = State()
    payment_method_minimum_pay = State()
    payment_method_anypay_min = State()
    enter_country = State()
    enter_country_error = State()


class ServiceMenu(StatesGroup):
    select_service = State()
    service_info = State()
    enter_service = State()
    enter_service_error = State()
    not_enough_balance = State()



app\dialogs\receive_sms\windows.py
import operator

from aiogram_dialog import Window, DialogManager, Data
from aiogram_dialog.widgets.input import TextInput, MessageInput
from aiogram_dialog.widgets.kbd import Cancel, Back, Button, ScrollingGroup, Select
from aiogram_dialog.widgets.text import Const, Format
from aiogram import F

from app.dialogs.personal_cabinet.selected import send_payment_keyboard_anypay, on_payment_method
from app.dialogs.receive_sms import states
from app.dialogs.receive_sms.getters import get_countries_service, get_services, get_need_balance, get_other_service, \
    get_services_2
from app.dialogs.receive_sms.selected import on_select_country_new, on_select_service, on_search_country, \
    on_result_country, \
    on_search_service, on_result_service, back_country
from app.services import bot_texts as bt
from app.dialogs.personal_cabinet import keyboards
from app.services.stars_pay import send_invoice_handler_stars


# Окно выбора сервиса
def select_service_window():
    """
    Создает окно выбора сервиса с прокручиваемым списком сервисов и кнопкой поиска.

    :return: Объект Window от aiogram_dialog.
    """
    return Window(
        Const(bt.SELECT_SERVICE),
        ScrollingGroup(
            Select(
                Format("{item[name]}"),
                id="services_select",
                item_id_getter=operator.itemgetter("code"),
                items="services",
                on_click=on_select_service,
            ),
            id="services_scroll",
            width=2,
            height=5
        ),
        Button(Const(bt.SEARCH_SERVICE_BTN), id="search_service", on_click=on_search_service),
        # Cancel(Const(bt.BACK_BTN)),
        state=states.ServiceMenu.select_service,
        getter=get_services_2
    )


# Окно ввода сервиса
def enter_service_window():
    """
    Создает окно ввода названия сервиса с текстовым вводом и кнопкой назад.

    :return: Объект Window от aiogram_dialog.
    """
    return Window(
        Const(bt.ENTER_SERVICE),
        TextInput(id="service_name", on_success=on_result_service),
        Back(Const(bt.BACK_BTN)),
        state=states.ServiceMenu.enter_service
    )


def enter_service_error_window():
    """
    Создает окно ошибки ввода сервиса с кнопкой повторного ввода, кнопкой выбора другого сервиса и кнопкой назад.

    :return: Объект Window от aiogram_dialog.
    """
    return Window(
        Const(bt.ENTER_SERVICE_ERROR),
        TextInput(id="service_name", on_success=on_result_service),
        Back(Const(bt.BACK_BTN)),
        state=states.ServiceMenu.enter_service_error
    )


# Окно выбора страны
def select_country_window():
    """
    Создает окно выбора страны с прокручиваемым списком стран и кнопкой поиска.

    :return: Объект Window от aiogram_dialog.
    """
    return Window(
        Const(bt.SELECT_COUNTRY),
        ScrollingGroup(
            Select(
                Format("{item[country]} {item[price]} ₽"),
                id="countries_select",
                item_id_getter=operator.itemgetter("id"),
                items="countries",
                on_click=on_select_country_new,
            ),
            id="countries_scroll",
            width=2,
            height=5
        ),
        Button(Const(bt.SEARCH_COUNTRY_BTN), id="search_country", on_click=on_search_country),
        Cancel(Const(bt.BACK_BTN)),
        state=states.CountryMenu.select_country,
        getter=get_countries_service
    )


# Окно ввода страны
def enter_country_window():
    """
    Создает окно ввода названия страны с текстовым вводом и кнопкой назад.

    :return: Объект Window от aiogram_dialog.
    """
    return Window(
        Const(bt.ENTER_COUNTRY),
        TextInput(id="country_name", on_success=on_result_country),
        Button(Const(bt.BACK_BTN), id="back", on_click=back_country),
        state=states.CountryMenu.enter_country
    )


# Окно ошибки ввода страны
def enter_country_error_window():
    """
    Создает окно ошибки ввода страны с кнопкой повторного ввода и кнопкой назад.

    :return: Объект Window от aiogram_dialog.
    """
    return Window(
        Const(bt.ENTER_COUNTRY_ERROR),
        Button(Const(bt.ENTER_AGAIN_BTN), id="enter_again", on_click=on_search_country),
        Cancel(Const(bt.BACK_BTN)),
        state=states.CountryMenu.enter_country_error
    )


def deposit_window_country():
    from app.dialogs.personal_cabinet.selected import on_deposit_price
    from app.dialogs.personal_cabinet.selected import on_other_price
    from app.dialogs.personal_cabinet.getters import get_deposit_prices
    return Window(
        Const(bt.SELECT_DEPOSIT_PRICE),
        keyboards.prices_kb(on_deposit_price),
        Button(Const(bt.OTHER_DEPOSIT_PRICE_BTN), id='other_price', on_click=on_other_price, when=~F['bonus']),
        Button(Const(bt.OTHER_DEPOSIT_PRICE_BTN + ' (+10%)'), id='other_price', on_click=on_other_price,
               when=F['bonus']),
        Back(Const(bt.BACK_BTN)),
        state=states.CountryMenu.deposit,
        getter=get_deposit_prices
    )


def enter_amount_window_country():
    from app.dialogs.personal_cabinet.selected import on_enter_other_price
    return Window(
        Const(bt.ENTER_DEPOSIT_AMOUNT),
        TextInput(id='enter_deposit_amount', on_success=on_enter_other_price),
        Back(Const(bt.BACK_BTN)),
        state=states.CountryMenu.enter_amount
    )


# Функция для нового окна выбора метода оплаты
def payment_method_window_country():
    from app.dialogs.personal_cabinet.selected import switch_to_payment, on_deposit
    return Window(
        Const(bt.SELECT_DEPOSIT_METHOD),
        Button(Const(bt.METHOD_CKASSA), id='ckassa', on_click=switch_to_payment),
        Button(Const(bt.METHOD_STREAMPAY), id='bank_card', on_click=switch_to_payment),
        # Button(Const(bt.METHOD_LAVA), id='SBP', on_click=switch_to_payment),
        # Button(Const(bt.METHOD_ANYPAY), id='anypay', on_click=send_payment_keyboard_anypay),
        Button(Const(bt.METHOD_STARS_BTN), id='stars', on_click=send_invoice_handler_stars),
        Button(Const(bt.METHOD_CRYPTO_BTN), id='crypto', on_click=switch_to_payment),
        Button(Const(bt.METHOD_OTHER_BTN), id='other', on_click=switch_to_payment),
        Button(Const(bt.BACK_BTN), id='back', on_click=on_deposit),
        state=states.CountryMenu.payment_method
    )


# Функция для выбора метода оплаты с платежем менее 300 руб
def payment_method_window_country_minimum_pay():
    from app.dialogs.personal_cabinet.selected import switch_to_payment, on_deposit
    return Window(
        Const(bt.SELECT_DEPOSIT_METHOD),
        Button(Const(bt.METHOD_CKASSA), id='ckassa', on_click=switch_to_payment),
        Button(Const(bt.METHOD_STARS_BTN), id='stars', on_click=send_invoice_handler_stars),
        Button(Const(bt.METHOD_CRYPTO_BTN), id='crypto', on_click=switch_to_payment),
        Button(Const(bt.METHOD_OTHER_BTN), id='other', on_click=switch_to_payment),
        Button(Const(bt.BACK_BTN), id='back', on_click=on_deposit),
        state=states.CountryMenu.payment_method_minimum_pay
    )

# Функция для нового окна выбора метода оплаты AnyPay
def payment_method_window_anypay():
    from app.dialogs.personal_cabinet.selected import switch_to_payment
    return Window(
        Const(bt.SELECT_DEPOSIT_METHOD),
        Button(Const(bt.METHOD_BANK_CARD), id='card', on_click=switch_to_payment),
        Button(Const(bt.METHOD_BANK_SBP), id='sbp', on_click=switch_to_payment),
        Button(Const(bt.METHOD_BANK_CRYPTOCURRENCY), id='btc', on_click=switch_to_payment),
        Button(Const(bt.BACK_BTN), id='back', on_click=on_payment_method),
        state=states.CountryMenu.payment_method_anypay
    )

# Функция для нового окна выбора метода оплаты AnyPay с непроходящим по сумме патежем
def payment_method_window_anypay_min():
    from app.dialogs.personal_cabinet.selected import switch_to_payment
    return Window(
        Const(bt.SELECT_DEPOSIT_METHOD),
        Button(Const(bt.METHOD_BANK_CRYPTOCURRENCY), id='btc', on_click=switch_to_payment),
        Button(Const(bt.BACK_BTN), id='back', on_click=on_payment_method),
        state=states.CountryMenu.payment_method_anypay_min
    )

app\dialogs\receive_sms\__init__.py
from aiogram_dialog import Dialog

from app.dialogs.receive_sms import windows


def select_countries_dialogs():
    return [
        Dialog(
            windows.select_country_window(),
            windows.deposit_window_country(),
            windows.enter_amount_window_country(),
            windows.payment_method_window_country(),
            windows.payment_method_window_country_minimum_pay(),
            windows.payment_method_window_anypay(),
            windows.enter_country_window(),
            windows.enter_country_error_window(),
        )
    ]


def select_services_dialogs():
    return [
        Dialog(
            windows.select_service_window(),
            windows.enter_service_window(),
            windows.enter_service_error_window(),
        )
    ]


app\dialogs\rent_sms\getters.py
from aiogram_dialog import DialogManager
from loguru import logger
from sqlalchemy import false

from app.db.models import CountriesOnlinesim
from app.services.bot_texts import DOLLAR_ONLINESIM
from app.services.onlinesim.rent_number import OnlineSimRentAPI


def log_exceptions(func):
    async def wrapper(*args, **kwargs):
        try:
            return await func(*args, **kwargs)
        except Exception as e:
            logger.opt(exception=e).error(f"Ошибка в обработчике {func.__name__}: {e}")
            raise  # Повторно вызываем ошибку, чтобы не скрывать её от фреймворка
    return wrapper


@log_exceptions
async def get_rent_countries(dialog_manager: DialogManager, **middleware_data):
    """
    Получает список стран для аренды с ценами для услуги.

    :param dialog_manager: Менеджер диалогов.
    :param middleware_data: Дополнительные данные из middleware.
    :return: dict - Данные о странах для аренды с увеличенными ценами.
    """
    try:
        user_id = dialog_manager.event.from_user.id
        logger.bind(user_id=user_id, action='get_rent_countries').log(
            "USER_ACTION",
            "Запрос списка стран для аренды номера"
        )

        api_client = OnlineSimRentAPI()
        tariffs = await api_client.get_tariffs()

        if not tariffs:
            logger.bind(user_id=user_id, action='get_rent_countries').log(
                "USER_ACTION",
                "Не удалось получить тарифы для аренды номеров"
            )
            return {"rent_countries": []}

        all_countries = await CountriesOnlinesim.all().values("country_id", "name")
        country_map = {str(country["country_id"]): country["name"] for country in all_countries}

        countries = []
        for country_code, days in tariffs.items():
            country_name = country_map.get(country_code, country_code)
            base_price = list(days.values())[0] if days else 0
            increased_price = round(base_price * DOLLAR_ONLINESIM)

            countries.append({
                "id": country_code,
                "country": country_name,
                "price": increased_price,
                "tariffs": tariffs,
            })

        dialog_manager.dialog_data["rent_countries"] = countries

        # logger.bind(user_id=user_id, action='get_rent_countries').log(
        #     "USER_ACTION",
        #     f"Получено {len(countries)} стран для аренды"
        # )

        return {"rent_countries": countries}
    except Exception as e:
        logger.opt(exception=e).error(f"Ошибка в get_rent_countries: {e}")
        return {"rent_countries": []}


async def get_country_details(dialog_manager: DialogManager, **kwargs):
    """
    Получает информацию о выбранной стране для отображения в деталях.

    :param dialog_manager: Менеджер диалогов.
    :param kwargs: Дополнительные параметры.
    :return: dict с деталями выбранной страны.
    """
    try:
        user_id = dialog_manager.event.from_user.id

        selected_country = dialog_manager.dialog_data.get("selected_country")
        if selected_country is None:
            selected_country = dialog_manager.start_data.get("selected_country")

        if not selected_country or "tariffs" not in selected_country:
            logger.bind(user_id=user_id, action='get_country_details').log(
                "USER_ACTION",
                "Детали страны недоступны или не найдены"
            )
            return {"country": "Неизвестно", "tariffs": []}

        tariffs = sorted(
            [{"days": get_day_string(int(days)), "price": price} for days, price in selected_country["tariffs"].items()],
            key=lambda x: x["price"]
        )

        logger.bind(user_id=user_id, action='get_country_details').log(
            "USER_ACTION",
            f"Отображение деталей страны: {selected_country['country']}"
        )

        return {
            "country": selected_country["country"],
            "tariffs": tariffs,
        }
    except Exception as e:
        logger.opt(exception=e).error(f"Ошибка в get_country_details: {e}")
        return {"country": "Неизвестно", "tariffs": []}


def get_day_string(days):
    """Возвращает строку с правильным склонением дня."""
    if days % 10 == 1 and days % 100 != 11:
        return f"{days} день"
    elif 2 <= days % 10 <= 4 and not (12 <= days % 100 <= 14):
        return f"{days} дня"
    else:
        return f"{days} дней"


# Обработчик для кнопки Cancel
async def cancel_btn(c, button, dialog_manager: DialogManager):
    """
    Обработчик кнопки "Отмена". Завершает текущее состояние диалога.
    :param c: CallbackQuery.
    :param button: Кнопка.
    :param dialog_manager: Менеджер диалогов.
    """
    try:
        user_id = c.from_user.id
        logger.bind(user_id=user_id, action='cancel_btn').log(
            "USER_ACTION",
            "Пользователь отменил операцию"
        )
        await dialog_manager.done()
    except Exception as e:
        logger.opt(exception=e).error(f"Ошибка в cancel_btn: {e}")

app\dialogs\rent_sms\scheduler_balance.py
from datetime import datetime, timedelta
from apscheduler.triggers.interval import IntervalTrigger
from apscheduler.triggers.date import DateTrigger
from app.db import models
from app.dialogs.rent_sms.selected import rent_number_in_days
from app.scheduler_instance import scheduler
from loguru import logger


# Асинхронная функция для проверки баланса и аренды номера
async def check_balance_and_send_service_rent(user_id, price, day_index, selected_country, c, manager):
    """
    Проверяет баланс пользователя и, при достаточном количестве средств,
    вызывает функцию аренды номера. После успешного выполнения удаляет задачу.

    :param user_id: ID пользователя.
    :param price: Стоимость услуги.
    :param day_index: Индекс количества дней аренды.
    :param selected_country: Выбранная страна.
    :param c: CallbackQuery от aiogram.
    :param manager: Менеджер диалогов aiogram_dialog.
    """
    try:
        # Получаем информацию о пользователе из базы данных
        user = await models.User.get_user(user_id)

        # Если баланс пользователя достаточен, арендуем номер
        if user.balance >= price:
            logger.bind(user_id=user_id, action='check_balance_and_send_service_rent').log(
                "USER_ACTION",
                f"Баланс достаточно. Запуск аренды номера на {day_index} дней"
            )
            await rent_number_in_days(
                c=c,
                widget=None,
                manager=manager,
                day_index=day_index,
                selected_country=selected_country
            )
            # Удаляем задачу проверки баланса после успешного выполнения
            if scheduler.get_job(f'balance_check_rent_{user_id}'):
                scheduler.remove_job(f'balance_check_rent_{user_id}')
    except Exception as e:
        logger.opt(exception=e).error(f"Ошибка в check_balance_and_send_service_rent: {e}")


# Асинхронная функция для запуска проверки баланса
async def start_balance_check_rent(user_id, price, day_index, selected_country, c, manager):
    """
    Запускает периодическую проверку баланса пользователя для аренды номера.
    Если баланс пополняется, запускается аренда номера.

    :param user_id: ID пользователя.
    :param price: Стоимость аренды.
    :param day_index: Индекс количества дней аренды.
    :param selected_country: Выбранная страна.
    :param c: CallbackQuery от aiogram.
    :param manager: Менеджер диалогов aiogram_dialog.
    """
    try:
        country = selected_country.get('country', 'неизвестная')

        logger.bind(user_id=user_id, action='start_balance_check_rent').log(
            "USER_ACTION",
            f"Запуск проверки баланса для аренды номера: цена={price}, страна={country}, дни={day_index}"
        )

        job_id = f'balance_check_rent_{user_id}'
        stop_job_id = f'stop_{job_id}'

        # Проверяем, есть ли уже такая задача, и удаляем её перед добавлением новой
        if scheduler.get_job(job_id):
            scheduler.remove_job(job_id)
        if scheduler.get_job(stop_job_id):
            scheduler.remove_job(stop_job_id)

        # Добавляем задачу для периодической проверки баланса каждые 5 секунд
        scheduler.add_job(
            check_balance_and_send_service_rent,
            IntervalTrigger(seconds=5),
            args=[user_id, price, day_index, selected_country, c, manager],
            id=job_id
        )

        # Определяем время завершения задачи (через 5 минут)
        end_time = datetime.now() + timedelta(minutes=5)

        # Добавляем отдельную задачу для остановки проверки баланса по истечении времени
        scheduler.add_job(
            lambda: scheduler.remove_job(job_id) if scheduler.get_job(job_id) else None,
            DateTrigger(run_date=end_time),
            id=stop_job_id
        )
    except Exception as e:
        logger.opt(exception=e).error(f"Ошибка в start_balance_check_rent: {e}")

app\dialogs\rent_sms\selected.py
from aiogram import types
from aiogram_dialog import DialogManager
from aiogram_dialog.widgets.input import TextInput
from aiogram_dialog.widgets.kbd import Select, Button
from app.db import models
from app.dialogs.rent_sms.getters import get_day_string
from app.dialogs.rent_sms.states import RentCountryMenu
from app.services.bot_texts import DOLLAR_ONLINESIM, NUMBER_REQUEST_SENT, PLEASE_WAIT_SECONDS, country_flags
from app.services.low_balance import check_low_balance, send_low_balance_alert
from app.services.onlinesim.rent_number import OnlineSimRentAPI
from datetime import datetime, timedelta
import pytz
from app.services import bot_texts as bt
import asyncio
from typing import Optional
from loguru import logger
from app.dependencies import bot

# Функция для обработки нажатия кнопки поиска страны
async def rent_on_search_country(c: types.CallbackQuery, widget: Button, manager: DialogManager):
    try:
        user_id = c.from_user.id
        logger.bind(user_id=user_id, action='rent_on_search_country').log(
            "USER_ACTION",
            "Переход к поиску страны для аренды"
        )
        await manager.switch_to(RentCountryMenu.enter_country)
    except Exception as e:
        logger.opt(exception=e).error(f"Ошибка в rent_on_search_country: {e}")


async def rent_on_deposit(c: types.CallbackQuery, widget: Button, manager: DialogManager):
    try:
        user_id = c.from_user.id
        logger.bind(user_id=user_id, action='rent_on_deposit').log(
            "USER_ACTION",
            "Переход к пополнению баланса"
        )
        await manager.switch_to(RentCountryMenu.deposit)
    except Exception as e:
        logger.opt(exception=e).error(f"Ошибка в rent_on_deposit: {e}")


async def rent_back_country(c: types.CallbackQuery, widget: Button, manager: DialogManager):
    try:
        user_id = c.from_user.id
        logger.bind(user_id=user_id, action='rent_back_country').log(
            "USER_ACTION",
            "Возврат к выбору страны"
        )
        await manager.switch_to(RentCountryMenu.select_country)
    except Exception as e:
        logger.opt(exception=e).error(f"Ошибка в rent_back_country: {e}")


# Функция для обработки результата поиска страны
async def rent_on_result_country(m: types.Message, widget: TextInput, manager: DialogManager, country_name: str):
    """
    Обрабатывает результат поиска страны по введенному названию.

    :param m: Объект Message от aiogram.
    :param widget: Виджет TextInput от aiogram_dialog.
    :param manager: Менеджер диалогов от aiogram_dialog.
    :param country_name: Название страны, введенное пользователем.
    """
    try:
        user_id = m.from_user.id
        logger.bind(user_id=user_id, action='rent_on_result_country').log(
            "USER_ACTION",
            f"Поиск страны: {country_name}"
        )

        country_names = await models.CountriesOnlinesim.search_countries(country_name.lower())
        if len(country_names) == 0:
            logger.bind(user_id=user_id, action='rent_on_result_country').log(
                "USER_ACTION",
                "Страна не найдена"
            )
            await manager.switch_to(RentCountryMenu.enter_country_error)
            return

        ctx = manager.current_context()
        ctx.dialog_data['search_name'] = country_names[0]
        logger.bind(user_id=user_id, action='rent_on_result_country').log(
            "USER_ACTION",
            f"Найдена страна: {country_names[0]}"
        )
        await manager.switch_to(RentCountryMenu.select_country)
    except Exception as e:
        logger.opt(exception=e).error(f"Ошибка в rent_on_result_country: {e}")


# Функция для обработки нажатия кнопки поиска страны
async def on_search_rent_country(c: types.CallbackQuery, widget: Button, manager: DialogManager):
    """
    Обрабатывает нажатие кнопки поиска страны и переводит на меню ввода страны.

    :param c: Объект CallbackQuery от aiogram.
    :param widget: Виджет Button от aiogram_dialog.
    :param manager: Менеджер диалогов от aiogram_dialog.
    """
    try:
        user_id = c.from_user.id
        logger.bind(user_id=user_id, action='on_search_rent_country').log(
            "USER_ACTION",
            "Переход к поиску страны для аренды"
        )
        await manager.switch_to(RentCountryMenu.enter_country)
    except Exception as e:
        logger.opt(exception=e).error(f"Ошибка в on_search_rent_country: {e}")


async def rent_on_select_country_new(c: types.CallbackQuery, widget: Select, manager: DialogManager,
                                     country_index: str):
    """
    Обрабатывает выбор страны для аренды.

    :param c: Объект CallbackQuery от aiogram.
    :param widget: Виджет Select от aiogram_dialog.
    :param manager: Менеджер диалогов от aiogram_dialog.
    :param country_index: Индекс выбранной страны.
    """
    try:
        user_id = c.from_user.id
        logger.bind(user_id=user_id, action='rent_on_select_country_new').log(
            "USER_ACTION",
            f"Выбор страны для аренды: {country_index}"
        )

        # Получаем список стран из текущего контекста
        rent_countries = manager.dialog_data.get("rent_countries", [])

        # Находим выбранную страну
        selected_country = next((country for country in rent_countries if country["id"] == country_index), None)

        if not selected_country:
            logger.bind(user_id=user_id, action='rent_on_select_country_new').log(
                "USER_ACTION",
                f"Страна с ID={country_index} не найдена"
            )
            await c.answer("Страна не найдена.", show_alert=True)
            return

        tariffs = selected_country["tariffs"].get(country_index, {})
        updated_tariffs = {days: round(price * DOLLAR_ONLINESIM) for days, price in tariffs.items()}

        manager.dialog_data["selected_country"] = {
            "rent_country_code": country_index,
            "country": selected_country["country"],
            "tariffs": updated_tariffs,
        }

        logger.bind(user_id=user_id, action='rent_on_select_country_new').log(
            "USER_ACTION",
            f"Выбрана страна: {selected_country['country']}, тарифы обновлены"
        )

        await manager.switch_to(RentCountryMenu.country_details)
    except Exception as e:
        logger.opt(exception=e).error(f"Ошибка в rent_on_select_country_new: {e}")


async def rent_number_in_days(c: types.CallbackQuery, widget: Select, manager: DialogManager, day_index: str,
                              selected_country: Optional[dict] = None):
    """
    Обрабатывает выбор количества дней для аренды или продления аренды номера страны.

    :param c: Объект CallbackQuery от aiogram.
    :param widget: Виджет Select от aiogram_dialog.
    :param manager: Менеджер диалогов от aiogram_dialog.
    :param day_index: Индекс выбранного количества дней.
    :param selected_country: selected_country.
    """
    try:
        user_id = c.from_user.id
        logger.bind(user_id=user_id, action='rent_number_in_days').log(
            "USER_ACTION",
            f"Запрос аренды на {day_index} дней"
        )

        tzid = None
        if selected_country is None:
            # Получаем данные о выбранной стране
            selected_country = manager.dialog_data.get("selected_country")
            if selected_country is None:
                selected_country = manager.start_data.get("selected_country")
                tzid = selected_country["tzid"]

            if not selected_country:
                await c.answer("Ошибка: данные о стране отсутствуют.", show_alert=True)
                logger.bind(user_id=user_id, action='rent_number_in_days').log(
                    "USER_ACTION",
                    "Данные о стране отсутствуют"
                )
                return

        # Преобразуем индекс дней в число
        days = int(day_index.split()[0])

        price = selected_country['tariffs'].get(str(days))
        # Получаем информацию о пользователе
        user = await models.User.get_user(c.from_user.id)
        country_code = selected_country["rent_country_code"]  # Код страны из context

        # Проверяем, достаточно ли у пользователя средств на балансе
        if user.balance < price:
            logger.bind(user_id=user_id, action='rent_number_in_days').log(
                "USER_ACTION",
                f"Недостаточно средств для аренды. Требуется: {price}, доступно: {user.balance}"
            )

            missing_amount = max(price - user.balance, 50.0) if user.balance < price else 0.0
            manager.current_context().dialog_data.update({'day_index': day_index, 'selected_country': selected_country,
                                                          'rent_country_code': country_code, 'price': missing_amount})
            from app.dialogs.personal_cabinet.selected import send_payment_keyboard
            await send_payment_keyboard(m=c, manager=manager, price=missing_amount)

            # await manager.switch_to(RentCountryMenu.deposit)
            return


        sent_message = await c.message.answer(text=NUMBER_REQUEST_SENT)
        sent_message_id = sent_message.message_id

        # Проверяем, прошло ли 10 секунд с последнего запроса
        if user.last_request_time is not None and (
                datetime.now(pytz.utc) - user.last_request_time.astimezone(pytz.utc)).total_seconds() < 5:
            await c.answer(text=PLEASE_WAIT_SECONDS, show_alert=True)
            logger.bind(user_id=user_id, action='rent_number_in_days').log(
                "USER_ACTION",
                "Слишком частый запрос"
            )
            return

        # Получаем текущее время в московском часовом поясе
        current_time = datetime.now(pytz.timezone('Europe/Moscow'))
        # Обновляем время последнего запроса
        user.last_request_time = current_time.astimezone(pytz.utc)
        await user.save(update_fields=['last_request_time'])
        # Создаем экземпляр API клиента и делаем запрос аренды
        api_client = OnlineSimRentAPI()

        try:
            if tzid is None:
                logger.bind(user_id=user_id, action='rent_number_in_days').log(
                    "USER_ACTION",
                    f"Запрос аренды номера: страна={country_code}, дни={days}"
                )
                rent_result = await api_client.rent_number(country=int(country_code), days=days) # Запрос номера
            else:
                logger.bind(user_id=user_id, action='rent_number_in_days').log(
                    "USER_ACTION",
                    f"Продление аренды: tzid={tzid}, дни={days}"
                )
                rent_result = await api_client.extend_rent_state(tzid=tzid, days=days)
        except Exception as e:
            logger.opt(exception=e).error(f"Ошибка при вызове API: {e}")
            await c.answer(f"Ошибка при аренде: {str(e)}", show_alert=True)
            return

        # Выводим результат аренды
        if rent_result is None:
            logger.bind(user_id=user_id, action='rent_number_in_days').log(
                "USER_ACTION",
                "Не удалось получить номер"
            )
            await c.answer(text=bt.NOT_NUMBERS_ALERT, show_alert=True)
            return

            # Извлекаем данные активации
        rent_id = int(rent_result.get("tzid", 0))
        phone_number = rent_result.get("number", None)
        country = await models.CountriesOnlinesim.get_country_onlinesim(country_id=country_code)
        minutes = int(rent_result.get("time", 0))

        if phone_number is None:
            await c.answer(text=bt.NOT_NUMBERS_ALERT, show_alert=True)
            logger.bind(user_id=user_id, action='rent_number_in_days').log(
                "USER_ACTION",
                "Номер не получен"
            )
            return

        # Добавляем запись об активации в базу данных
        activation = await models.Rent.add_rent(
            user=user,
            rent_id=rent_id,
            country=country,
            cost=price,
            phone_number=f"{country_code}{phone_number}",
            rent_expire_at=datetime.now(pytz.timezone("Europe/Moscow")).replace(microsecond=0) + timedelta(minutes=minutes),
            days=days
        )

        # обновляем количество покупок номеров
        activation.purchase_count += 1
        await activation.save(update_fields=["purchase_count"])
        logger.bind(user_id=user_id, action='rent_number_in_days').log(
            "USER_ACTION",
            f"Успешная аренда номера: {activation.phone_number}, истекает {activation.rent_expire_at}"
        )

        await bot.delete_message(chat_id=c.from_user.id, message_id=sent_message_id)

        # Отправляем пользователю сообщение о номере телефона
        await send_message_country_number(message=c.message, activation=activation, country=activation.country.name, days=days)

        # Списываем средства с баланса пользователя
        user.balance -= price
        await user.save(update_fields=['balance'])

        # Проверяем, низкий ли баланс у пользователя после списания средств
        low_balance = await check_low_balance(user, price)
        # Ждем 1 секунду перед отправкой уведомления о низком балансе, если это необходимо
        await asyncio.sleep(1)
        if low_balance:
            await send_low_balance_alert(user)
    except Exception as e:
        logger.opt(exception=e).error(f"Ошибка в rent_number_in_days: {e}")


async def send_message_country_number(message: types.Message, activation, country, days):
    """
    Отправляет пользователю о номер телефона.

    :param country: Страна
    :param message: Сообщение для отправки.
    :param activation: Объект активации.
    :param days: Количество арендованных дней.
    """

    try:
        user_id = message.from_user.id
        country = country.strip()
        flag = country_flags.get(country, "")
        flag_and_country = f"{flag} {country}"

        days_text = get_day_string(days)

        await message.answer(
            text=bt.RENT_SUCCESS_MESSAGE.format(days=days_text)
        )

        await message.answer(
            text=bt.NUMBER_INFO.format(
                country=flag_and_country,
                phone=activation.phone_number,
            )
        )
    except Exception as e:
        logger.opt(exception=e).error(f"Ошибка в send_message_country_number: {e}")

app\dialogs\rent_sms\states.py
from aiogram.fsm.state import StatesGroup, State


class RentCountryMenu(StatesGroup):
    select_country = State()
    deposit = State()
    enter_amount = State()
    country_details = State()
    payment_method = State()
    payment_method_anypay = State()
    payment_method_minimum_pay = State()
    payment_method_anypay_min = State()
    enter_country = State()
    enter_country_error = State()



app\dialogs\rent_sms\windows.py
import operator
from aiogram import F
from aiogram_dialog import Window
from aiogram_dialog.widgets.input import TextInput
from aiogram_dialog.widgets.kbd import Cancel, Back, Button, ScrollingGroup, Select
from aiogram_dialog.widgets.text import Const, Format
from app.dialogs.personal_cabinet import keyboards

from app.dialogs.rent_sms import states
from app.dialogs.rent_sms.getters import get_rent_countries, get_country_details, cancel_btn
from app.dialogs.rent_sms.selected import rent_on_result_country, rent_on_select_country_new, \
    rent_back_country, on_search_rent_country, rent_number_in_days, rent_on_deposit
from app.services import bot_texts as bt
from app.services.stars_pay import send_invoice_handler_stars


# Окно выбора страны для аренды
def select_rent_window():
    """
    Создает окно выбора страны для аренды с прокручиваемым списком стран и кнопкой поиска.

    :return: Объект Window от aiogram_dialog.
    """
    return Window(
        Const(bt.SELECT_COUNTRY_RENT),
        ScrollingGroup(
            Select(
                Format("{item[country]} от {item[price]} ₽"),
                id="rent_countries_select",
                item_id_getter=operator.itemgetter("id"),
                items="rent_countries",
                on_click=rent_on_select_country_new,
            ),
            id="rent_countries_scroll",
            width=2,
            height=5
        ),
        # Button(Const(bt.SEARCH_COUNTRY_BTN), id="rent_search_country", on_click=on_search_rent_country),
        # Cancel(Const(bt.BACK_BTN), on_click=cancel_btn),
        state=states.RentCountryMenu.select_country,
        getter=get_rent_countries
    )


# Окно ввода страны
def enter_country_window():
    """
    Создает окно ввода названия страны с текстовым вводом и кнопкой назад.

    :return: Объект Window от aiogram_dialog.
    """
    return Window(
        Const(bt.ENTER_COUNTRY),
        TextInput(id="rent_country_name", on_success=rent_on_result_country),
        Button(Const(bt.BACK_BTN), id="rent_back", on_click=rent_back_country),
        state=states.RentCountryMenu.enter_country
    )


# Окно ошибки ввода страны
def enter_country_error_window():
    """
    Создает окно ошибки ввода страны с кнопкой повторного ввода и кнопкой назад.

    :return: Объект Window от aiogram_dialog.
    """
    return Window(
        Const(bt.ENTER_COUNTRY_ERROR),
        Button(Const(bt.ENTER_AGAIN_BTN), id="enter_again", on_click=on_search_rent_country),
        Cancel(Const(bt.BACK_BTN)),
        state=states.RentCountryMenu.enter_country_error
    )


def country_details_window():
    """
    Окно отображения информации о выбранной стране.

    :return: Объект Window от aiogram_dialog.
    """
    return Window(
        Const(bt.SELECT_RENTAL_PERIOD),
        ScrollingGroup(
            Select(
                Format("{item[days]}, {item[price]} ₽"),
                id="tariffs_scroll",
                item_id_getter=operator.itemgetter("days"),
                items="tariffs",
                on_click=rent_number_in_days,
            ),
            id="tariffs_group",
            width=1,
            height=5
        ),
        Button(Const(bt.BACK_BTN), id="back_to_country_select", on_click=rent_back_country),
        state=states.RentCountryMenu.country_details,
        getter=get_country_details,
    )



def deposit_window_country():
    from app.dialogs.personal_cabinet.selected import on_deposit_price
    from app.dialogs.personal_cabinet.selected import on_other_price
    from app.dialogs.personal_cabinet.getters import get_deposit_prices
    return Window(
        Const(bt.SELECT_DEPOSIT_PRICE),
        keyboards.prices_kb(on_deposit_price),
        Button(Const(bt.OTHER_DEPOSIT_PRICE_BTN), id='other_price', on_click=on_other_price, when=~F['bonus']),
        Button(Const(bt.OTHER_DEPOSIT_PRICE_BTN + ' (+10%)'), id='other_price', on_click=on_other_price,
               when=F['bonus']),
        Back(Const(bt.BACK_BTN)),
        state=states.RentCountryMenu.deposit,
        getter=get_deposit_prices
    )


def enter_amount_window_country():
    from app.dialogs.personal_cabinet.selected import on_enter_other_price
    return Window(
        Const(bt.ENTER_DEPOSIT_AMOUNT),
        TextInput(id='enter_deposit_amount', on_success=on_enter_other_price),
        Back(Const(bt.BACK_BTN)),
        state=states.RentCountryMenu.enter_amount
    )


# Функция для нового окна выбора метода оплаты
def payment_method_window_country():
    from app.dialogs.personal_cabinet.selected import switch_to_payment
    from app.dialogs.personal_cabinet.selected import send_payment_keyboard_anypay
    return Window(
        Const(bt.SELECT_DEPOSIT_METHOD),
        Button(Const(bt.METHOD_CKASSA), id='ckassa', on_click=switch_to_payment),
        Button(Const(bt.METHOD_STREAMPAY), id='bank_card', on_click=switch_to_payment),
        # Button(Const(bt.METHOD_LAVA), id='SBP', on_click=switch_to_payment),
        # Button(Const(bt.METHOD_ANYPAY), id='anypay', on_click=send_payment_keyboard_anypay),
        Button(Const(bt.METHOD_STARS_BTN), id='stars', on_click=send_invoice_handler_stars),
        Button(Const(bt.METHOD_CRYPTO_BTN), id='crypto', on_click=switch_to_payment),
        Button(Const(bt.METHOD_OTHER_BTN), id='other', on_click=switch_to_payment),
        Button(Const(bt.BACK_BTN), id='back', on_click=rent_on_deposit),
        state=states.RentCountryMenu.payment_method
    )


# Функция для выбора метода оплаты с платежем менее 300 руб
def payment_method_window_country_minimum_pay():
    from app.dialogs.personal_cabinet.selected import switch_to_payment
    return Window(
        Const(bt.SELECT_DEPOSIT_METHOD),
        Button(Const(bt.METHOD_CKASSA), id='ckassa', on_click=switch_to_payment),
        Button(Const(bt.METHOD_STARS_BTN), id='stars', on_click=send_invoice_handler_stars),
        Button(Const(bt.METHOD_CRYPTO_BTN), id='crypto', on_click=switch_to_payment),
        Button(Const(bt.METHOD_OTHER_BTN), id='other', on_click=switch_to_payment),
        Button(Const(bt.BACK_BTN), id='back', on_click=rent_on_deposit),
        state=states.RentCountryMenu.payment_method_minimum_pay
    )

# Функция для нового окна выбора метода оплаты AnyPay
def payment_method_window_anypay():
    from app.dialogs.personal_cabinet.selected import switch_to_payment, on_payment_method
    return Window(
        Const(bt.SELECT_DEPOSIT_METHOD),
        Button(Const(bt.METHOD_BANK_CARD), id='card', on_click=switch_to_payment),
        Button(Const(bt.METHOD_BANK_SBP), id='sbp', on_click=switch_to_payment),
        Button(Const(bt.METHOD_BANK_CRYPTOCURRENCY), id='btc', on_click=switch_to_payment),
        Button(Const(bt.BACK_BTN), id='back', on_click=on_payment_method),
        state=states.RentCountryMenu.payment_method_anypay
    )

# Функция для нового окна выбора метода оплаты AnyPay с непроходящим по сумме патежем
def payment_method_window_anypay_min():
    from app.dialogs.personal_cabinet.selected import switch_to_payment, on_payment_method
    return Window(
        Const(bt.SELECT_DEPOSIT_METHOD),
        Button(Const(bt.METHOD_BANK_CRYPTOCURRENCY), id='btc', on_click=switch_to_payment),
        Button(Const(bt.BACK_BTN), id='back', on_click=on_payment_method),
        state=states.RentCountryMenu.payment_method_anypay_min
    )

app\dialogs\rent_sms\__init__.py
from aiogram_dialog import Dialog

from app.dialogs.rent_sms import windows


def select_rent_dialogs():
    return [
        Dialog(
            windows.select_rent_window(),
            windows.country_details_window(),
            windows.deposit_window_country(),
            windows.enter_amount_window_country(),
            windows.payment_method_window_country(),
            windows.payment_method_window_country_minimum_pay(),
            windows.payment_method_window_anypay(),
            windows.enter_country_window(),
            windows.enter_country_error_window(),
        )
    ]



app\handlers\admin_handler.py
import asyncio
import random
import string
from datetime import datetime, timedelta
import pytz
from app.services.onlinesim.service_updater import add_services
from app.services.periodic_tasks import send_coder
from app.services.sms_receive import SmsReceive
from aiogram import Router, types, F
from aiogram.filters import Command
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import StatesGroup, State
from app.db import models
from app.db.models import Activation, AdminSettings
from app.dependencies import ADMINS, bot
from app.services import bot_texts as bt
from tabulate import tabulate
from aiogram_dialog import DialogManager
from loguru import logger
from tortoise.functions import Sum
import calendar
from celery_worker.tasks import send_message_batch
from aiogram.types import FSInputFile


router = Router()


class BroadcastState(StatesGroup):
    send_message = State()

MONTHS_RU = {
    "January": "Январь", "February": "Февраль", "March": "Март",
    "April": "Апрель", "May": "Май", "June": "Июнь",
    "July": "Июль", "August": "Август", "September": "Сентябрь",
    "October": "Октябрь", "November": "Ноябрь", "December": "Декабрь"
}

@router.message(Command('stat'))
async def stat(message: types.Message):
    logger.bind(user_id=message.from_user.id, action='stat').log("USER_ACTION", "Команда /stat вызвана")
    utc_now = datetime.now(pytz.timezone("Europe/Moscow"))
    if message.from_user.id not in ADMINS:
        return

    users_count = await models.User.all().count()
    users_count_today = await models.User.filter(
        created_at__gte=utc_now.replace(hour=0, minute=0, second=0)).count()

    letters_count = await models.Letter.all().count()
    letters_count_today = await models.Letter.filter(
        created_at__gte=utc_now.replace(hour=0, minute=0, second=0)).count()

    sms_count = await models.Activation.filter(sms_text__isnull=False, sms_text__not="").count()
    sms_count_today = await models.Activation.filter(
        sms_text__isnull=False, sms_text__not="",
        created_at__gte=utc_now.replace(hour=0, minute=0, second=0)
    ).count()

    sms_count_month = await models.Activation.filter(
        sms_text__isnull=False, sms_text__not="",
        created_at__gte=utc_now - timedelta(days=30)
    ).count()

    rented_sms_total = await models.Activation.all().count()
    rented_sms_month = await models.Activation.filter(
        created_at__gte=utc_now - timedelta(days=30)
    ).count()
    rented_sms_today = await models.Activation.filter(
        created_at__gte=utc_now.replace(hour=0, minute=0, second=0)
    ).count()

    payments = await models.Payment.filter(is_success=True).all().prefetch_related('user')
    payments_count = len(payments)
    payments_repeat_count = 0
    user_ids = []
    for payment in payments:
        if payment.user.id in user_ids:
            payments_repeat_count += 1
        else:
            user_ids.append(payment.user.id)
        await asyncio.sleep(0)

    payments_count_today = await models.Payment.filter(
        is_success=True,
        created_at__gte=utc_now.replace(hour=0, minute=0, second=0)
    ).count()

    payments_amount_today = sum(await models.Payment.filter(
        is_success=True,
        created_at__gte=utc_now.replace(hour=0, minute=0, second=0)
    ).values_list('amount', flat=True))

    rent_email_count = await models.Mail.filter(is_paid_mail=True).all().count()
    rent_email_count_today = await models.Mail.filter(
        is_paid_mail=True,
        created_at__gte=utc_now.replace(hour=0, minute=0, second=0)
    ).count()

    # Общая сумма всех покупок
    rented_number_total = await models.Rent.all().annotate(total=Sum("purchase_count")).values("total")
    rented_number_total = rented_number_total[0]["total"] or 0

    # Сумма покупок за последние 30 дней
    rented_number_month = await models.Rent.filter(
        created_at__gte=utc_now - timedelta(days=30)
    ).annotate(total=Sum("purchase_count")).values("total")
    rented_number_month = rented_number_month[0]["total"] or 0

    # Сумма покупок за сегодняшний день
    rented_number_today = await models.Rent.filter(
        created_at__gte=utc_now.replace(hour=0, minute=0, second=0)
    ).annotate(total=Sum("purchase_count")).values("total")
    rented_number_today = rented_number_today[0]["total"] or 0

    # Группируем по user_id и считаем количество записей для каждого пользователя
    user_purchases = await models.Rent.all().group_by("user_id").annotate(
        total_purchases=Sum("purchase_count")
    ).values("user_id", "total_purchases")

    first_day_of_month = utc_now.replace(day=1, hour=0, minute=0, second=0)
    last_month = utc_now.month - 1 if utc_now.month > 1 else 12
    last_year = utc_now.year if utc_now.month > 1 else utc_now.year - 1
    first_day_of_last_month = datetime(last_year, last_month, 1, tzinfo=pytz.timezone("Europe/Moscow"))
    last_month_name = MONTHS_RU[calendar.month_name[last_month]]
    current_month_name = MONTHS_RU[calendar.month_name[utc_now.month]]

    payments_count_month = await models.Payment.filter(
        is_success=True,
        created_at__gte=first_day_of_month
    ).count()

    payments_count_last_month = await models.Payment.filter(
        is_success=True,
        created_at__gte=first_day_of_last_month,
        created_at__lt=first_day_of_month
    ).count()

    payments_amount_month = sum(await models.Payment.filter(
        is_success=True,
        created_at__gte=first_day_of_month
    ).values_list('amount', flat=True))

    payments_amount_last_month = sum(await models.Payment.filter(
        is_success=True,
        created_at__gte=first_day_of_last_month,
        created_at__lt=first_day_of_month
    ).values_list('amount', flat=True))

    # Суммируем (count - 1) для каждого пользователя
    repeat_purchases_total = sum(user["total_purchases"] - 1 for user in user_purchases)

    # Для STARS
    today_start = utc_now.replace(hour=0, minute=0, second=0)

    # За сегодня
    stars_today_count = await models.Payment.filter(
        method=models.PaymentMethod.STARS,
        is_success=True,
        created_at__gte=today_start
    ).count()

    # Используем values_list для суммы
    amounts_today = await models.Payment.filter(
        method=models.PaymentMethod.STARS,
        is_success=True,
        created_at__gte=today_start
    ).values_list("amount", flat=True)
    stars_today_amount = sum(amounts_today) if amounts_today else 0.0

    # За текущий месяц
    stars_month_count = await models.Payment.filter(
        method=models.PaymentMethod.STARS,
        is_success=True,
        created_at__gte=first_day_of_month
    ).count()

    amounts_month = await models.Payment.filter(
        method=models.PaymentMethod.STARS,
        is_success=True,
        created_at__gte=first_day_of_month
    ).values_list("amount", flat=True)
    stars_month_amount = sum(amounts_month) if amounts_month else 0.0

    # За предыдущий месяц
    stars_last_month_count = await models.Payment.filter(
        method=models.PaymentMethod.STARS,
        is_success=True,
        created_at__gte=first_day_of_last_month,
        created_at__lt=first_day_of_month
    ).count()

    amounts_last_month = await models.Payment.filter(
        method=models.PaymentMethod.STARS,
        is_success=True,
        created_at__gte=first_day_of_last_month,
        created_at__lt=first_day_of_month
    ).values_list("amount", flat=True)
    stars_last_month_amount = sum(amounts_last_month) if amounts_last_month else 0.0

    msg_text = bt.ADMIN_STAT.format(
        users_count=users_count,
        users_count_today=users_count_today,
        received_count=letters_count + sms_count,
        received_sms_count=sms_count,
        received_email_count=letters_count,
        received_count_today=letters_count_today + sms_count_today,
        received_sms_count_today=sms_count_today,
        received_email_count_today=letters_count_today,
        payments_count=payments_count,
        payments_repeat_count=payments_repeat_count,
        payments_count_today=payments_count_today,
        payments_amount_today=payments_amount_today,
        payments_count_month=payments_count_month,
        payments_count_last_month=payments_count_last_month,
        payments_amount_month=payments_amount_month,
        payments_amount_last_month=payments_amount_last_month,
        rent_email_count=rent_email_count,
        rent_email_count_today=rent_email_count_today,
        rented_sms_total=rented_sms_total,
        rented_sms_month=rented_sms_month,
        rented_sms_today=rented_sms_today,
        delivered_sms_total=sms_count,
        delivered_sms_month=sms_count_month,
        delivered_sms_today=sms_count_today,
        rented_number_total=rented_number_total,
        rented_number_month=rented_number_month,
        rented_number_today=rented_number_today,
        repeat_purchases_total=repeat_purchases_total,
        month_name=current_month_name,
        last_month_name=last_month_name,
        stars_count_today=stars_today_count,
        stars_amount_today=stars_today_amount,
        stars_month_count=stars_month_count,
        stars_month_amount=stars_month_amount,
        stars_last_month_count=stars_last_month_count,
        stars_last_month_amount=stars_last_month_amount,
    )

    await message.answer(msg_text)



@router.message(Command('test_balance'))
async def test_balance(message: types.Message):
    logger.bind(user_id=message.from_user.id, action="test_balance").log("USER_ACTION", "Команда /test_balance вызвана")
    if message.from_user.id not in ADMINS:
        return
    sms = SmsReceive()
    balance = await sms.get_balance()
    logger.bind(user_id=message.from_user.id, action="info").log("USER_ACTION", f"Баланс: {balance}")


@router.message(Command('test_delete'))
async def test_delete(message: types.Message):
    logger.bind(user_id=message.from_user.id, action="test_delete").log("USER_ACTION", "Команда /test_delete вызвана")
    if message.from_user.id not in ADMINS:
        return
    count = await Activation.delete_user_activations(message.from_user.id)
    await message.answer(f'Активации удалены {count}')


@router.message(Command('test_db'))
async def test(message: types.Message):
    logger.bind(user_id=message.from_user.id, action="test_db").log("USER_ACTION", "Команда /test_db вызвана")
    if message.from_user.id not in ADMINS:
        return
    await message.answer(f'тест ')
    # text = await load_services_from_file("data.txt")
    # await message.answer(text)
    return
    # await models.Service.normalize_search_names()


@router.message(Command('test_state'))
async def test_state(message: types.Message, dialog_manager: DialogManager):
    logger.bind(user_id=message.from_user.id, action="test_state").log("USER_ACTION", "Команда /test_state вызвана")
    if message.from_user.id not in ADMINS:
        return
    try:
        logger.bind(user_id=message.from_user.id, action="success").log("USER_ACTION", dialog_manager.current_context())
    except Exception as e:
        logger.bind(user_id=message.from_user.id, action="success").log("USER_ACTION", e)


@router.message(Command('freemoney'))
async def free_money(message: types.Message):
    logger.bind(user_id=message.from_user.id, action="freemoney").log("USER_ACTION", "Команда /freemoney вызвана")
    if message.from_user.id not in ADMINS:
        return

    command_args = message.text.split(' ')
    if len(command_args) != 3:
        await message.answer('Неверный формат команды')
        return

    _, amount, limit = command_args
    try:
        amount = float(amount)
        limit = int(limit)
    except ValueError:
        await message.answer('Неверный формат команды')
        return

    # generate unique 32 symbols string
    word = ''.join(random.choice(string.ascii_letters) for _ in range(16))
    word = 'free_' + word

    await models.PaymentLink.add_payment_link(
        payment_link_id=word,
        amount=amount,
        limit=limit
    )

    me = await bot.me()
    msg_text = f"""
<b>Ссылка готова</b>

<b>Сумма:</b> {amount} руб.
<b>Количество активаций:</b> {limit}

https://t.me/{me.username}?start={word}
"""

    await message.answer(text=msg_text, disable_web_page_preview=True)

@router.message(Command('send'))
async def send_message(message: types.Message, state: FSMContext):
    if message.from_user.id not in ADMINS:
        return

    logger.bind(user_id=message.from_user.id, action="clear_state").log("USER_ACTION", "Сброс состояния FSM")
    await state.clear()
    logger.bind(user_id=message.from_user.id, action='init_broadcast').log('USER_ACTION', 'Инициализация рассылки')
    logger.bind(user_id=message.from_user.id, action="set_broadcast_state").log("USER_ACTION", "Установка состояния: send_message")
    await state.set_state(BroadcastState.send_message)
    mk = types.InlineKeyboardMarkup(
        inline_keyboard=[
            [
                types.InlineKeyboardButton(text='Отменить', callback_data='cancel_send_message')
            ]
        ]
    )
    await message.answer('Отправьте сообщение для рассылки', reply_markup=mk)


@router.callback_query(F.data == 'cancel_send_message')
async def cancel_send_message(c: types.CallbackQuery, state: FSMContext):
    await c.message.edit_text(text='Ввод отменен')
    logger.bind(user_id=c.from_user.id, action="clear_state").log("USER_ACTION", "Сброс состояния FSM")
    await state.clear()

@router.message(BroadcastState.send_message)
async def on_send_message(message: types.Message, state: FSMContext):
    if message.from_user.id not in ADMINS:
        return

    logger.bind(user_id=message.from_user.id, action="clear_state").log("USER_ACTION", "Сброс состояния FSM")
    await state.clear()

    # Проверяем, есть ли у сообщения текст
    message_text = message.text if message.content_type == types.ContentType.TEXT else None

    # Сохраняем информацию о рассылке в базе данных
    campaign = await models.BroadcastCampaign.create(
        message_id=message.message_id,
        message_text=message_text,  # Сохраняем текст сообщения, если он есть
        sent_by_admin_id = message.from_user.id  # Сохраняем ID администратора
    )

    # Обновляем состояние с данными рассылки и campaign_id
    await state.update_data(
        campaign_id=campaign.id,  # Сохраняем campaign_id
        chat_id=message.chat.id,
        message_id=message.message_id,
        message_text=message_text
    )

    # Копируем сообщение (для наглядности перед подтверждением)
    await bot.copy_message(
        chat_id=message.chat.id,
        from_chat_id=message.chat.id,
        message_id=message.message_id
    )

    users_count = await models.User.all().count()
    mk = types.InlineKeyboardMarkup(
        inline_keyboard=[
            [
                types.InlineKeyboardButton(text=bt.CONFIRM_BTN, callback_data='send_message_celery'),
                types.InlineKeyboardButton(text='Отмена', callback_data='cancel_send_message')
            ]
        ]
    )

    await message.answer(
        text=f'Сообщение выше будет отправлено {users_count} пользователям. Продолжить?',
        reply_markup=mk
    )



@router.callback_query(F.data == 'send_message_celery')
async def on_confirm_send_message(c: types.CallbackQuery, state: FSMContext):
    if c.from_user.id not in ADMINS:
        return
    # Получаем данные из состояния
    data = await state.get_data()
    campaign_id = data.get("campaign_id")  # Получаем campaign_id
    logger.bind(user_id=c.from_user.id, action='confirm_broadcast').log('USER_ACTION', f'Запуск рассылки #{campaign_id}')
    await c.message.edit_text(f"Рассылка #{campaign_id} запущена!")
    # Запуск задачи Celery с campaign_id
    send_message_batch.delay(campaign_id)  # Передаем campaign_id в Celery-задачу
    logger.bind(user_id=c.from_user.id, action="clear_state").log("USER_ACTION", "Сброс состояния FSM")
    await state.clear()



@router.callback_query(F.data == 'send_message')
async def on_confirm_send_message(c: types.CallbackQuery, state: FSMContext):
    if c.from_user.id not in ADMINS:
        return

    data = await state.get_data()
    chat_id = data.get('chat_id')
    message_id = data.get('message_id')
    await c.message.edit_text(text='Отправка сообщения...')
    users = await models.User.all()
    for user in users:
        await bot.copy_message(
            chat_id=user.telegram_id,
            from_chat_id=chat_id,
            message_id=message_id
        )
    await c.message.answer(text=f'Сообщение отправлено {len(users)} пользователям')
    logger.bind(user_id=c.from_user.id, action="clear_state").log("USER_ACTION", "Сброс состояния FSM")
    await state.clear()


@router.message(Command('affiliate_stat'))
async def affiliate_stat(message: types.Message):
    logger.bind(user_id=message.from_user.id, action="affiliate_stat").log("USER_ACTION", "Команда /affiliate_stat вызвана")
    if message.from_user.id not in ADMINS:
        return

    logger.bind(user_id=message.from_user.id, action='affiliate_stat').log('USER_ACTION', 'Команда /affiliate_stat вызвана')
    users = await models.User.filter(refer_id__isnull=False).all()
    referrers_dict = {}
    for user in users:
        refer = await models.User.get_or_none(id=user.refer_id)
        refer_id = refer.telegram_id
        if refer_id not in referrers_dict:
            referrers_dict[refer_id] = {
                'count': 0,
            }
        referrers_dict[refer_id]['count'] += 1
        payments = await models.Payment.filter(is_success=True, user=user).all()
        for payment in payments:
            if refer_id not in referrers_dict:
                referrers_dict[refer_id] = {
                    'count': 0,
                    'payments_count': 0
                }
            elif 'payments_count' not in referrers_dict[refer_id]:
                referrers_dict[refer_id]['payments_count'] = 0

            referrers_dict[refer_id]['payments_count'] += 1

    referrers_ids = list(referrers_dict.keys())
    referrers = await models.User.filter(telegram_id__in=referrers_ids).all()
    for refer in referrers:
        referrers_dict[refer.telegram_id]['total_earning'] = refer.total_ref_earnings
        referrers_dict[refer.telegram_id]['ref_balance'] = refer.ref_balance

    data_tab = []
    for refer_id, data in referrers_dict.items():
        if 'payments_count' not in data:
            data['payments_count'] = 0
        if 'total_earning' not in data:
            data['total_earning'] = 0
        if 'ref_balance' not in data:
            data['ref_balance'] = 0

        data_tab.append([
            refer_id,
            data['count'],
            data['payments_count'],
            data['total_earning'],
            data['ref_balance']
        ])

    stat = tabulate(data_tab, headers=['ID', 'Приглашено', 'Оплаты', 'Заработано', 'Доступно'])

    await message.answer(bt.AFFILIATE_STAT.format(stat=stat))


@router.message(Command("refund"))
async def handle_refund_command(message: types.Message):
    logger.bind(user_id=message.from_user.id, action='refund').log('USER_ACTION', 'Команда /refund вызвана')
    logger.info(f'message.from_user.id: {message.from_user.id} '
                   f'message.successful_payment.telegram_payment_charge_id: {message.successful_payment.telegram_payment_charge_id}')
    refund_star = await message.bot.refund_star_payment(message.from_user.id,
                                                        message.successful_payment.telegram_payment_charge_id)

    await message.answer(str(refund_star))


@router.message(Command('add_balance'))
async def add_balance(message: types.Message):
    logger.bind(user_id=message.from_user.id, action='add_balance').log("USER_ACTION", "Команда /add_balance вызвана")
    logger.bind(user_id=message.from_user.id, action="add_balance").log("USER_ACTION", "Команда /add_balance вызвана")
    if message.from_user.id not in ADMINS:
        return

    args = message.text.split()
    if len(args) != 3:
        await message.answer("Использование: /add_balance [telegram_id] [сумма]")
        return

    try:
        telegram_id = int(args[1])
        amount = float(args[2])
    except ValueError:
        await message.answer("Некорректный Telegram ID или сумма. Пожалуйста, введите числовые значения.")
        return

    user = await models.User.get_user(telegram_id)
    if user is None:
        await message.answer("Пользователь с таким Telegram ID не найден.")
        return

    user.balance += amount
    await user.save()

    logger.bind(user_id=message.from_user.id, action='add_balance').log('USER_ACTION', f'Пополнение баланса {telegram_id} на {amount}')
    await message.answer(f"Баланс пользователя {user} пополнен на {amount}.")

    if amount > 0:
        await bot.send_message(telegram_id, f"Администратор пополнил ваш баланс на {amount}.")

    msg_text = f"Администратор пополнил баланс пользователю {user.mention} на {amount}."
    await send_coder(msg_text)


@router.message(Command('services_update'))
async def services(message: types.Message, state: FSMContext):
    logger.bind(user_id=message.from_user.id, action="services_update").log("USER_ACTION", "Команда /services_update вызвана")
    if message.from_user.id not in ADMINS:
        return
    await message.answer("Обновляю список сервисов...")
    await add_services()
    await message.answer("Сервисы обновлены!")


@router.message(Command('smsactivate'))
async def set_smsactivate(message: types.Message):
    logger.bind(user_id=message.from_user.id, action="smsactivate").log("USER_ACTION", "Команда /smsactivate вызвана")
    if message.from_user.id not in ADMINS:
        return
    await AdminSettings.update_setting("sms_rental_service", "SMS_Activate")
    await message.answer(text="Установлен сервис SMS_Activate")


@router.message(Command('onlinesim'))
async def set_smsactivate(message: types.Message):
    logger.bind(user_id=message.from_user.id, action="onlinesim").log("USER_ACTION", "Команда /onlinesim вызвана")
    if message.from_user.id not in ADMINS:
        return
    await AdminSettings.update_setting("sms_rental_service", "Onlinesim")
    await message.answer(text="Установлен сервис Onlinesim")


@router.message(Command('info_id'))
async def info_id(message: types.Message):
    logger.bind(user_id=message.from_user.id, action='info_id').log("USER_ACTION", "Команда /info_id вызвана")
    logger.bind(user_id=message.from_user.id, action="info_id").log("USER_ACTION", "Команда /info_id вызвана")
    if message.from_user.id not in ADMINS:
        return

    args = message.text.split()
    if len(args) != 2:
        await message.answer("Использование: /info_id [telegram_id]")
        return

    try:
        telegram_id = int(args[1])
    except ValueError:
        await message.answer("Некорректный Telegram ID")
        return

    logger.bind(user_id=message.from_user.id, action='info_id').log('USER_ACTION', f'Запрос информации по пользователю {telegram_id}')
    user = await models.User.get_user(telegram_id)
    if user is None:
        await message.answer("Пользователь с таким Telegram ID не найден.")
        return

    amount = user.balance
    mail = await models.Mail.get_user_mails(user.id)
    last_element = mail[-1] if mail else "-"

    data = await models.Activation.get_last_rented_info(user.id)

    # Проверка наличия арендованного номера с sms_text
    rent_with_sms = await models.Rent.filter(user=user, sms_text__isnull=False).order_by('-created_at').first()

    rent_number = rent_with_sms.phone_number if rent_with_sms else "Нет"
    rent_date = rent_with_sms.created_at.strftime("%Y-%m-%d %H:%M") if rent_with_sms else "Нет"

    # Получаем сумму всех успешных пополнений
    from tortoise.functions import Sum
    total_payments_result = await models.Payment.filter(user=user, is_success=True).annotate(total=Sum("amount")).values("total")
    total_payments = total_payments_result[0]["total"] or 0


    # Сумма списаний из Rent
    rent_cost_result = await models.Rent.filter(user=user, sms_text__isnull=False).exclude(sms_text="").annotate(total=Sum("cost")).values("total")
    rent_total = rent_cost_result[0]["total"] or 0

    # Сумма списаний из Activation
    activation_cost_result = await models.Activation.filter(user=user, sms_text__isnull=False).exclude(sms_text="").annotate(total=Sum("cost")).values("total")
    activation_total = activation_cost_result[0]["total"] or 0

    total_spent = rent_total + activation_total

    await message.answer(
        f"<b>📋 Информация о пользователе:</b>\n\n"
        f"<b>💳 Баланс:</b> {amount} ₽\n"
        f"<b>💰 Всего пополнений:</b> {total_payments:.2f} ₽\n"
        f"<b>📤 Всего списаний:</b> {total_spent:.2f} ₽\n"
        f"\n<i>📱 Последний арендованный номер:</i> {rent_number}\n"
        f"<i>🗓 Дата аренды:</i> {rent_date}\n"
        f"\n<b>📩 Последний номер, на который было получено SMS:</b>\n"
        f"<i>📞 Номер:</i> {data[0] if data and data[0] else 'Нет'}\n"
        f"<i>🗓 Дата:</i> {data[1] if data and data[1] else 'Нет'}\n"
        f"<i>🛠 Сервис:</i> {data[2] if data and data[2] else 'Нет'}\n"
        f"<i>🌍 Страна:</i> {data[3] if data and data[3] else 'Нет'}\n"

        f"\n<i>📫 Почта:</i> <a href='mailto:{last_element}'></a>\n",
        parse_mode="HTML"
    )


@router.message(Command('sending_status'))
async def campaign_status(message: types.Message):
    logger.bind(user_id=message.from_user.id, action="sending_status").log("USER_ACTION", "Команда /sending_status вызвана")
    if message.from_user.id not in ADMINS:
        return

    # Проверяем, передан ли campaign_id
    args = message.text.split()
    if len(args) != 2:
        await message.answer("Использование: /sending_status [номер рассылки]")
        return

    try:
        campaign_id = int(args[1])
    except ValueError:
        await message.answer("Некорректный номер рассылки")
        return

    # Проверяем существование рассылки
    campaign = await models.BroadcastCampaign.get_or_none(id=campaign_id)
    if not campaign:
        await message.answer("Рассылка с таким ID не найдена.")
        return

    # Подсчитываем количество отправленных сообщений
    sent_count = await models.Broadcast.filter(campaign_id=campaign_id).count()

    await message.answer(f"В рамках рассылки #{campaign_id} отправлено сообщений: {sent_count}")

import tempfile

@router.message(Command('users_with_balance'))
async def users_with_balance_html(message: types.Message):
    logger.bind(user_id=message.from_user.id, action="users_with_balance").log("USER_ACTION", "Команда /users_with_balance вызвана")
    if message.from_user.id not in ADMINS:
        return

    args = message.text.split()
    if len(args) != 2:
        await message.answer("Использование: /users_with_balance [сумма]")
        return

    try:
        balance_threshold = float(args[1])
    except ValueError:
        await message.answer("Некорректное значение суммы.")
        return

    users = await models.User.filter(balance__gt=balance_threshold).all()

    if not users:
        await message.answer(f"Нет пользователей с балансом выше {balance_threshold} ₽.")
        return

    # Формируем HTML-таблицу
    rows = "".join([
        f"<tr><td>{u.telegram_id}</td><td>{u.full_name}</td><td>{u.username or '-'}</td><td>{u.mention}</td><td>{u.balance:.2f} ₽</td></tr>"
        for u in users
    ])
    html_content = f"""
    <html>
    <head>
        <meta charset="UTF-8">
        <style>
            table {{ border-collapse: collapse; width: 100%; }}
            th, td {{ border: 1px solid #ddd; padding: 8px; text-align: left; }}
            th {{ background-color: #f2f2f2; }}
        </style>
    </head>
    <body>
        <h2>Пользователи с балансом выше {balance_threshold} ₽</h2>
        <table>
            <thead>
                <tr>
                    <th>Telegram ID</th>
                    <th>Имя</th>
                    <th>Username</th>
                    <th>Mention</th>
                    <th>Баланс</th>
                </tr>
            </thead>
            <tbody>
                {rows}
            </tbody>
        </table>
    </body>
    </html>
    """

    # Создаём временный файл
    with tempfile.NamedTemporaryFile(mode='w+', suffix='.html', delete=False, encoding='utf-8') as f:
        f.write(html_content)
        f.flush()
        file_path = f.name

    # Отправляем файл
    await message.answer_document(types.FSInputFile(file_path), caption=f"Пользователи с балансом > {balance_threshold} ₽")


@router.message(Command('users_without_payments'))
async def users_without_payments(message: types.Message):
    logger.bind(user_id=message.from_user.id, action='users_without_payments').log("USER_ACTION", "Команда /users_without_payments вызвана")
    if message.from_user.id not in ADMINS:
        return

    from tortoise.expressions import Q
    from tortoise.functions import Sum

    # Получаем всех пользователей с положительным балансом
    users_with_balance = await models.User.filter(balance__gt=0).all()

    # Получаем ID пользователей с успешными платежами
    paid_user_ids = set(await models.Payment.filter(is_success=True).values_list('user_id', flat=True))

    # Оставляем только тех, кто не пополнял
    filtered_users = [u for u in users_with_balance if u.id not in paid_user_ids]

    if not filtered_users:
        await message.answer("Нет пользователей с балансом больше 0 и без пополнений.")
        return

    # Словарь user_id -> total_spent
    user_spent = {}

    for user in filtered_users:
        rent_cost_result = await models.Rent.filter(
            user=user, sms_text__isnull=False
        ).exclude(sms_text="").annotate(total=Sum("cost")).values("total")
        rent_total = rent_cost_result[0]["total"] or 0

        activation_cost_result = await models.Activation.filter(
            user=user, sms_text__isnull=False
        ).exclude(sms_text="").annotate(total=Sum("cost")).values("total")
        activation_total = activation_cost_result[0]["total"] or 0

        user_spent[user.id] = rent_total + activation_total

    # Формируем HTML-таблицу
    rows = "".join([
        f"<tr><td>{u.id}</td><td>{u.telegram_id}</td><td>{u.full_name}</td><td>{u.username or '-'}</td>"
        f"<td>{u.mention}</td><td>{u.balance:.2f} ₽</td><td>{user_spent[u.id]:.2f} ₽</td><td>{u.created_at.strftime('%Y-%m-%d %H:%M')}</td></tr>"
        for u in filtered_users
    ])
    html_content = f"""
    <html>
    <head>
        <meta charset="UTF-8">
        <style>
            table {{ border-collapse: collapse; width: 100%; }}
            th, td {{ border: 1px solid #ddd; padding: 8px; text-align: left; }}
            th {{ background-color: #f2f2f2; }}
        </style>
    </head>
    <body>
        <h3>Пользователи с балансом > 0 и без успешных пополнений</h3>
        <table>
            <thead>
                <tr>
                    <th>ID</th>
                    <th>Telegram ID</th>
                    <th>Имя</th>
                    <th>Username</th>
                    <th>Mention</th>
                    <th>Баланс</th>
                    <th>Всего списаний</th>
                    <th>Зарегистрирован</th>
                </tr>
            </thead>
            <tbody>{rows}</tbody>
        </table>
    </body>
    </html>
    """

    import tempfile
    with tempfile.NamedTemporaryFile(mode='w+', suffix='.html', delete=False, encoding='utf-8') as f:
        f.write(html_content)
        file_path = f.name

    await message.answer_document(types.FSInputFile(file_path), caption="Пользователи без пополнений с балансом.")



@router.message(Command("users_with_discrepancy"))
async def users_with_discrepancy(message: types.Message):
    if message.from_user.id not in ADMINS:
        return

    # Получаем суммы пополнений по пользователям
    payments = await models.Payment.filter(is_success=True).group_by("user_id").annotate(
        total_paid=Sum("amount")
    ).values("user_id", "total_paid")

    # Получаем суммы расходов на аренды
    rents = await models.Rent.filter(sms_text__isnull=False).exclude(sms_text="").group_by("user_id").annotate(
        total_rent=Sum("cost")
    ).values("user_id", "total_rent")

    # Получаем суммы расходов на активации
    activations = await models.Activation.filter(sms_text__isnull=False).exclude(sms_text="").group_by("user_id").annotate(
        total_activation=Sum("cost")
    ).values("user_id", "total_activation")

    # Сопоставляем user_id с их данными
    user_data = {}

    for p in payments:
        user_data[p["user_id"]] = {"total_paid": p["total_paid"], "total_spent": 0}

    for r in rents:
        user_data.setdefault(r["user_id"], {"total_paid": 0, "total_spent": 0})
        user_data[r["user_id"]]["total_spent"] += r["total_rent"]

    for a in activations:
        user_data.setdefault(a["user_id"], {"total_paid": 0, "total_spent": 0})
        user_data[a["user_id"]]["total_spent"] += a["total_activation"]

    # Получаем баланс всех этих пользователей
    user_ids = list(user_data.keys())
    users = await models.User.filter(id__in=user_ids).values(
        "id", "telegram_id", "full_name", "username", "balance", "mention"
    )

    user_info_map = {u["id"]: u for u in users}

    # Выбираем пользователей с расхождениями
    filtered = []
    for user_id, data in user_data.items():
        user = user_info_map.get(user_id)
        if not user:
            continue
        total_paid = data["total_paid"] or 0
        total_spent = data["total_spent"] or 0
        balance = user["balance"] or 0

        if total_spent + balance > total_paid:
            filtered.append({
                "telegram_id": user["telegram_id"],
                "full_name": user["full_name"],
                "username": user["username"] or "-",
                "mention": user["mention"] or "-",
                "balance": balance,
                "total_paid": total_paid,
                "total_spent": total_spent,
                "difference": (total_spent + balance - total_paid)
            })

    # сортировка по убыванию разницы
    filtered.sort(key=lambda x: x["difference"], reverse=True)

    if not filtered:
        await message.answer("Нет пользователей с расхождениями.")
        return

    # Формируем HTML-таблицу
    rows = "".join([
        f"<tr>"
        f"<td>{u['telegram_id']}</td>"
        f"<td>{u['full_name']}</td>"
        f"<td>{u['username']}</td>"
        f"<td>{u['mention']}</td>"
        f"<td>{u['balance']:.2f} ₽</td>"
        f"<td>{u['total_paid']:.2f} ₽</td>"
        f"<td>{u['total_spent']:.2f} ₽</td>"
        f"<td>{u['difference']:.2f} ₽</td>"
        f"</tr>"
        for u in filtered
    ])

    html_content = f"""
    <html>
    <head>
        <meta charset="UTF-8">
        <style>
            table {{ border-collapse: collapse; width: 100%; }}
            th, td {{ border: 1px solid #ddd; padding: 8px; text-align: left; }}
            th {{ background-color: #f2f2f2; }}
        </style>
    </head>
    <body>
        <h2>Пользователи с (расходы + баланс) > пополнений</h2>
        <table>
            <thead>
                <tr>
                    <th>Telegram ID</th>
                    <th>Имя</th>
                    <th>Username</th>
                    <th>Mention</th>
                    <th>Баланс</th>
                    <th>Пополнения</th>
                    <th>Расходы</th>
                    <th>Разница</th>
                </tr>
            </thead>
            <tbody>
                {rows}
            </tbody>
        </table>
    </body>
    </html>
    """

    with tempfile.NamedTemporaryFile(mode='w+', suffix='.html', delete=False, encoding='utf-8') as f:
        f.write(html_content)
        file_path = f.name

    await message.answer_document(
        FSInputFile(file_path),
        caption="Пользователи с (расходы + баланс) > пополнений"
    )

@router.message(Command("users_with_overspent"))
async def users_with_overspent(message: types.Message):
    if message.from_user.id not in ADMINS:
        return

    # Получаем суммы пополнений
    payments = await models.Payment.filter(is_success=True).group_by("user_id").annotate(
        total_paid=Sum("amount")
    ).values("user_id", "total_paid")

    # Расходы: аренда
    rents = await models.Rent.filter(sms_text__isnull=False).exclude(sms_text="").group_by("user_id").annotate(
        total_rent=Sum("cost")
    ).values("user_id", "total_rent")

    # Расходы: активации
    activations = await models.Activation.filter(sms_text__isnull=False).exclude(sms_text="").group_by("user_id").annotate(
        total_activation=Sum("cost")
    ).values("user_id", "total_activation")

    user_data = {}

    for p in payments:
        user_data[p["user_id"]] = {"total_paid": p["total_paid"], "total_spent": 0}

    for r in rents:
        user_data.setdefault(r["user_id"], {"total_paid": 0, "total_spent": 0})
        user_data[r["user_id"]]["total_spent"] += r["total_rent"]

    for a in activations:
        user_data.setdefault(a["user_id"], {"total_paid": 0, "total_spent": 0})
        user_data[a["user_id"]]["total_spent"] += a["total_activation"]

    user_ids = list(user_data.keys())
    users = await models.User.filter(id__in=user_ids).values(
        "id", "telegram_id", "full_name", "username", "mention"
    )
    user_info_map = {u["id"]: u for u in users}

    filtered = []
    for user_id, data in user_data.items():
        user = user_info_map.get(user_id)
        if not user:
            continue

        total_paid = data["total_paid"] or 0
        total_spent = data["total_spent"] or 0

        if total_spent > total_paid:
            filtered.append({
                "telegram_id": user["telegram_id"],
                "full_name": user["full_name"],
                "username": user["username"] or "-",
                "mention": user["mention"] or "-",
                "total_paid": total_paid,
                "total_spent": total_spent,
                "difference": total_spent - total_paid
            })

    filtered.sort(key=lambda x: x["difference"], reverse=True)

    if not filtered:
        await message.answer("Нет пользователей, у которых расходы превышают пополнения.")
        return

    rows = "".join([
        f"<tr>"
        f"<td>{u['telegram_id']}</td>"
        f"<td>{u['full_name']}</td>"
        f"<td>{u['username']}</td>"
        f"<td>{u['mention']}</td>"
        f"<td>{u['total_paid']:.2f} ₽</td>"
        f"<td>{u['total_spent']:.2f} ₽</td>"
        f"<td>{u['difference']:.2f} ₽</td>"
        f"</tr>"
        for u in filtered
    ])

    html_content = f"""
    <html>
    <head>
        <meta charset="UTF-8">
        <style>
            table {{ border-collapse: collapse; width: 100%; }}
            th, td {{ border: 1px solid #ddd; padding: 8px; text-align: left; }}
            th {{ background-color: #f2f2f2; }}
        </style>
    </head>
    <body>
        <h2>Пользователи с расходами выше, чем пополнения</h2>
        <table>
            <thead>
                <tr>
                    <th>Telegram ID</th>
                    <th>Имя</th>
                    <th>Username</th>
                    <th>Mention</th>
                    <th>Пополнения</th>
                    <th>Расходы</th>
                    <th>Разница</th>
                </tr>
            </thead>
            <tbody>
                {rows}
            </tbody>
        </table>
    </body>
    </html>
    """

    with tempfile.NamedTemporaryFile(mode='w+', suffix='.html', delete=False, encoding='utf-8') as f:
        f.write(html_content)
        file_path = f.name

    await message.answer_document(
        FSInputFile(file_path),
        caption="Пользователи с расходами выше пополнений"
    )


@router.message(Command('help_admin'))
async def help_admin(message: types.Message):
    if message.from_user.id not in ADMINS:
        return

    commands = """
    /stat - Статистика
    /freemoney [сумма] [лимит] - Создать ссылку на бесплатные деньги
    /send - Рассылка сообщений
    /sending_status [номер рассылки] - Проверка рассылки сообщений
    /add_balance [telegram_id] [сумма] - Пополнение баланса пользователя
    /info_id [telegram_id] - Информация о пользователе
    /user_report [telegram_id] - HTML-отчёт по пользователю
    /users_with_balance [сумма] - Выгрузка пользователей с балансом выше указанного
    /users_without_payments - Пользователи с балансом > 0 и без пополнений
    /users_with_discrepancy - Выгрузка пользователей с (расходы + баланс) > пополнений
    /users_with_overspent - Пользователи с расходами > пополнений (без учёта баланса)
    /smsactivate - Установить SMS_Activate
    /onlinesim - Установить Onlinesim
    """

    await message.answer(f"<b>Доступные команды для админов:</b>\n{commands}", parse_mode="HTML")

app\handlers\affilate_program.py
from aiogram import Router, F, types
from app.services import bot_texts as bt

router = Router()


@router.callback_query(F.data == 'withdraw')
async def withdraw(call: types.CallbackQuery):
    await call.message.delete()
    mk = types.InlineKeyboardMarkup(
        inline_keyboard=[
            [
                types.InlineKeyboardButton(
                    text=bt.ON_BANK_CARD_BTN,
                    callback_data='on_bank_card'
                )
            ],
            [
                types.InlineKeyboardButton(
                    text=bt.ON_BALANCE_BTN,
                    callback_data='on_balance'
                )
            ],
            [
                types.InlineKeyboardButton(text=bt.BACK_BTN,
                                           callback_data='back')
            ]
        ]
    )
    await call.message.answer(text=bt.WITHDRAW_TEXT, reply_markup=mk)


app\handlers\affiliate_program.py
from aiogram import Router, F, types
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import StatesGroup, State
from app import dependencies
from app.db import models
from app.services import bot_texts as bt
from app.services.need_subscribe import check_subscribe, send_subscribe_msg
from app.services.payments.cryptomus import create_a_payout
from app.services.qr_code import generate_qr_code
from loguru import logger
from tortoise.functions import Count
from aiogram.utils.keyboard import InlineKeyboardBuilder


router = Router()

# --- Клавиатуры ---
back_mk = types.InlineKeyboardMarkup(
    inline_keyboard=[
        [
            types.InlineKeyboardButton(text=bt.BACK_BTN, callback_data='withdraw')
        ]
    ]
)

choice_cryptocurrency_kb = types.InlineKeyboardMarkup(
    inline_keyboard=[
        [
            types.InlineKeyboardButton(text="USDT", callback_data='choice_cryptocurrency:USDT'),
            types.InlineKeyboardButton(text="BTC", callback_data='choice_cryptocurrency:BTC'),
            types.InlineKeyboardButton(text="ETH", callback_data='choice_cryptocurrency:ETH')
        ],
        [
            types.InlineKeyboardButton(text="TON", callback_data='choice_cryptocurrency:TON'),
            types.InlineKeyboardButton(text="BNB", callback_data='choice_cryptocurrency:BNB'),
            types.InlineKeyboardButton(text="DAI", callback_data='choice_cryptocurrency:DAI')
        ],
        [
            types.InlineKeyboardButton(text="TRX", callback_data='choice_cryptocurrency:TRX'),
            types.InlineKeyboardButton(text="AVAX", callback_data='choice_cryptocurrency:AVAX')
        ],
    ]
)

network_selection_kb = types.InlineKeyboardMarkup(
    inline_keyboard=[
        [
            types.InlineKeyboardButton(text="TRON", callback_data='network_selection:TRON'),
            types.InlineKeyboardButton(text="TON", callback_data='network_selection:TON'),
            types.InlineKeyboardButton(text="BTC", callback_data='network_selection:BTC')
        ],
        [
            types.InlineKeyboardButton(text="BSC", callback_data='network_selection:BSC'),
            types.InlineKeyboardButton(text="ETH", callback_data='network_selection:ETH'),
        ]
    ]
)

confirm_conclusion_btn = types.InlineKeyboardMarkup(
    inline_keyboard=[
        [
            types.InlineKeyboardButton(text="☑️Подтвердить вывод", callback_data='confirm_withdrawal')
        ],
        [
            types.InlineKeyboardButton(text="🔙Отменить", callback_data='cancel_withdrawal')
        ]
    ]
)

# --- Состояния ---
class AffiliateState(StatesGroup):
    enter_withdraw_amount = State()
    enter_withdraw_requisites = State()

class ChoiceOfCryptocurrency(StatesGroup):
    enter_amount = State()
    enter_choice_cryptocurrency = State()
    enter_network = State()


# --- Вспомогательные функции ---
async def send_affiliate_message(m: types.Message, user_id: int = None):
    try:
        if not user_id:
            user_id = m.from_user.id

        logger.bind(user_id=user_id, action="send_affiliate_message").log("USER_ACTION", "Запрос на отправку реферального сообщения")
        loading_msg = await m.answer("⏳Идёт загрузка, ожидайте...")
        me = await m.bot.me()
        link = f'https://t.me/{me.username}?start={user_id}'
        qr_code_bytes = await generate_qr_code(link)
        user = await models.User.get_user(user_id)

        keyboard = types.InlineKeyboardMarkup(inline_keyboard=[])

        keyboard.inline_keyboard.append([
            types.InlineKeyboardButton(
                text=bt.SHARE_LINK_BTN,
                switch_inline_query_chosen_chat=types.SwitchInlineQueryChosenChat(
                    query=bt.SHARE_BOT_TEXT.format(
                        link=link,
                        mention=user.mention
                    ),
                    allow_user_chats=True,
                    allow_group_chats=True,
                    allow_channel_chats=True
                )
            )
        ])

        keyboard.inline_keyboard.append([
            types.InlineKeyboardButton(text=bt.WITHDRAW_BTN, callback_data='withdraw')
        ])

        if user.disable_ref_notifications:
            keyboard.inline_keyboard.append([
                types.InlineKeyboardButton(
                    text="🔔 Включить уведомления о рефералах",
                    callback_data=f"enable_ref_notify:{user_id}"
                )
            ])

        ref = await models.User.filter(refer_id=user.id).all()
        ref_count = len(ref)
        payment_count = 0
        for r in ref:
            payment_count += (await models.Payment.filter(user=r, is_success=True).all().count())
        logger.bind(user_id=user_id, action="send_affiliate_message").log("USER_ACTION", f"Рефералы: {ref_count}, платежей: {payment_count}")

        referral_stats = (
            await models.Payment.filter(
                user__refer_id=user.id,
                is_success=True
            )
            .group_by("user_id")
            .annotate(payment_count=Count("id"))
            .values("user_id", "payment_count")
        )

        repeat_payment_users = sum(
            max(0, stat["payment_count"] - 1) for stat in referral_stats if stat["payment_count"] > 1)

        await m.answer_photo(
            photo=types.BufferedInputFile(qr_code_bytes.read(), filename='qr_code.png'),
            caption=bt.AFFILIATE_PROGRAM_TEXT.format(
                link=link,
                ref_balance=round(user.ref_balance),
                ref_count=ref_count,
                ref_balance_total=round(user.total_ref_earnings),
                payment_count=payment_count,
                repeat_payment_count=repeat_payment_users
            ),
            reply_markup=keyboard
        )
        await loading_msg.delete()
    except Exception as e:
        logger.opt(exception=e).error(f"Ошибка в хэндлере /send_affiliate_message: {e}")

# --- Хэндлеры ---
@router.message(F.text == bt.AFFILIATE_PROGRAM_BTN)
async def affiliate_program(message: types.Message):
    try:
        user_id = message.from_user.id
        logger.bind(user_id=user_id, action="affiliate_program").log("USER_ACTION", "Пользователь открыл Партнерская программа")
        # logger.bind(user_id=user_id, action="affiliate_program").log("USER_ACTION", f"Запрос к БД: получение пользователя {user_id}")
        user = await models.User.get_user(user_id)
        # logger.bind(user_id=user_id, action="affiliate_program").log("USER_ACTION", f"Результат из БД: пользователь {user_id} найден")
        sub = await check_subscribe(user)
        if not sub:
            await send_subscribe_msg(user)
            return
        await send_affiliate_message(message)
    except Exception as e:
        logger.opt(exception=e).error(f"Ошибка в хэндлере /affiliate_program: {e}")

@router.callback_query(F.data == 'affiliate_program')
async def affiliate_program(call: types.CallbackQuery):
    try:
        user_id = call.from_user.id
        logger.bind(user_id=user_id, action="callback_affiliate_program").log("USER_ACTION", "Пользователь вернулся к Партнерская программа")
        await call.message.delete()
        await send_affiliate_message(call.message)
    except Exception as e:
        logger.opt(exception=e).error(f"Ошибка в хэндлере /callback_affiliate_program: {e}")

@router.callback_query(F.data == 'withdraw')
async def withdraw(call: types.CallbackQuery, state: FSMContext):
    try:
        user_id = call.from_user.id
        logger.bind(user_id=user_id, action="withdraw").log("USER_ACTION", "Пользователь выбрал способ вывода средств")
        if state:
            await state.clear()
        await call.message.delete()
        mk = types.InlineKeyboardMarkup(
            inline_keyboard=[
                [
                    types.InlineKeyboardButton(
                        text=bt.ON_CRYPTOCURRENCY_BTN,
                        callback_data='cryptocurrency'
                    )
                ],
                [
                    types.InlineKeyboardButton(
                        text=bt.ON_BALANCE_BTN,
                        callback_data='on_balance'
                    )
                ],
                [
                    types.InlineKeyboardButton(text=bt.BACK_BTN,
                                               callback_data='affiliate_program')
                ]
            ]
        )
        await call.message.answer(text=bt.WITHDRAW_TEXT, reply_markup=mk)
        await call.answer()
    except Exception as e:
        logger.opt(exception=e).error(f"Ошибка в хэндлере /withdraw: {e}")

@router.callback_query(F.data == 'on_bank_card')
async def on_bank_card(call: types.CallbackQuery, state: FSMContext):
    try:
        user_id = call.from_user.id
        logger.bind(user_id=user_id, action="on_bank_card").log("USER_ACTION", "Выбран вывод на банковскую карту")
        await state.update_data(withdraw_method=call.data)
        await state.set_state(AffiliateState.enter_withdraw_amount)
        await call.message.edit_text(text=bt.ENTER_WITHDRAW_AMOUNT, reply_markup=back_mk)
    except Exception as e:
        logger.opt(exception=e).error(f"Ошибка в хэндлере /on_bank_card: {e}")

@router.callback_query(F.data == 'cryptocurrency')
async def on_cryptocurrency(call: types.CallbackQuery, state: FSMContext):
    try:
        user_id = call.from_user.id
        logger.bind(user_id=user_id, action="on_cryptocurrency").log("USER_ACTION", "Выбран вывод на криптовалюту")
        await state.update_data(withdraw_method=call.data)
        await state.set_state(AffiliateState.enter_withdraw_amount)
        await call.message.edit_text(text=bt.ENTER_WITHDRAW_AMOUNT, reply_markup=back_mk)
    except Exception as e:
        logger.opt(exception=e).error(f"Ошибка в хэндлере /on_cryptocurrency: {e}")

@router.callback_query(F.data == 'on_balance')
async def on_balance(call: types.CallbackQuery, state: FSMContext):
    try:
        user_id = call.from_user.id
        logger.bind(user_id=user_id, action="on_balance").log("USER_ACTION", "Выбран вывод на баланс бота")
        await state.update_data(withdraw_method=call.data)
        await state.set_state(AffiliateState.enter_withdraw_amount)
        await call.message.edit_text(text=bt.ENTER_WITHDRAW_AMOUNT, reply_markup=back_mk)
    except Exception as e:
        logger.opt(exception=e).error(f"Ошибка в хэндлере /on_balance: {e}")

@router.message(AffiliateState.enter_withdraw_amount)
async def enter_withdraw_amount(m: types.Message, state: FSMContext):
    try:
        user_id = m.from_user.id
        logger.bind(user_id=user_id, action="enter_withdraw_amount").log("USER_ACTION", "Пользователь ввёл сумму для вывода")
        data = await state.get_data()
        withdraw_method = data.get('withdraw_method')
        amount_text = m.text
        logger.bind(user_id=user_id, action="enter_withdraw_amount").log("USER_ACTION", f"Введено: сумма={amount_text}, метод={withdraw_method}")
        if not amount_text.isdigit():
            logger.bind(user_id=user_id, action="enter_withdraw_amount").log("USER_ACTION", "Ошибка: сумма не является числом")
            await m.answer(text='Сумма должна быть числом', reply_markup=back_mk)
            return
        amount = int(amount_text)
        if amount < 100 and withdraw_method == 'on_bank_card':
            logger.bind(user_id=user_id, action="enter_withdraw_amount").log("USER_ACTION", "Ошибка: сумма меньше минимальной для карты")
            await m.answer(text='Минимальная сумма вывода - 100₽', reply_markup=back_mk)
            return
        if amount < 300 and withdraw_method == 'cryptocurrency':
            logger.bind(user_id=user_id, action="enter_withdraw_amount").log("USER_ACTION", "Ошибка: сумма меньше минимальной для крипты")
            await m.answer(text=f'Минимальная сумма вывода: {bt.MIN_CRYPT_AMOUNT}₽', reply_markup=back_mk)
            return
        # logger.bind(user_id=user_id, action="enter_withdraw_amount").log("USER_ACTION", f"Запрос к БД: получение пользователя {user_id}")
        user = await models.User.get_user(user_id)
        logger.bind(user_id=user_id, action="enter_withdraw_amount").log("USER_ACTION", f"Результат из БД: баланс={user.ref_balance}")
        if user.ref_balance < amount:
            logger.bind(user_id=user_id, action="enter_withdraw_amount").log("USER_ACTION", "Ошибка: недостаточно средств")
            await m.answer(text='Недостаточно средств', reply_markup=back_mk)
            return
        if withdraw_method == 'on_bank_card':
            logger.bind(user_id=user_id, action="enter_withdraw_amount").log("USER_ACTION", "Переход к вводу реквизитов карты")
            await m.answer(text=bt.ENTER_WITHDRAW_CARD, reply_markup=back_mk)
            await state.set_state(AffiliateState.enter_withdraw_requisites)
            await state.update_data(amount=amount)
        elif withdraw_method == 'cryptocurrency':
            logger.bind(user_id=user_id, action="enter_withdraw_amount").log("USER_ACTION", "Переход к выбору криптовалюты")
            await state.clear()
            await state.set_state(ChoiceOfCryptocurrency.enter_amount)
            await state.update_data(amount=amount)
            await m.answer(text=f'В какой криптовалюте Вы хотите получить выплату?', reply_markup=choice_cryptocurrency_kb)
        elif withdraw_method == 'on_balance':
            logger.bind(user_id=user_id, action="enter_withdraw_amount").log("USER_ACTION", f"Выполняется вывод {amount}₽ на баланс")
            user.ref_balance -= amount
            user.balance += amount
            await user.save()
            await m.answer(text=f'Вывод {amount}₽ на баланс бота подтвержден', reply_markup=back_mk)
            await state.clear()
    except Exception as e:
        logger.opt(exception=e).error(f"Ошибка в хэндлере /enter_withdraw_amount: {e}")

# --- Остальные хэндлеры аналогично оборачиваются в try/except и логгируются по шаблону выше ---

# Пример для одного из ключевых хэндлеров:
@router.callback_query(F.data.startswith('network_selection:'))
async def network_selection(call: types.CallbackQuery, state: FSMContext):
    try:
        user_id = call.from_user.id
        network = call.data.split(':')[1]
        logger.bind(user_id=user_id, action="network_selection").log("USER_ACTION", f"Выбрана сеть: {network}")
        await state.update_data(withdraw_network=network)
        await state.set_state(ChoiceOfCryptocurrency.enter_network)
        await call.message.edit_text(
            text=f'Вы выбрали сеть: {network}\nОтправьте адрес вашего крипто-кошелька для вывода средств⤵️'
        )
    except Exception as e:
        logger.opt(exception=e).error(f"Ошибка в хэндлере /network_selection: {e}")

@router.message(ChoiceOfCryptocurrency.enter_network)
async def enter_wallet_address(message: types.Message, state: FSMContext):
    try:
        user_id = message.from_user.id
        logger.bind(user_id=user_id, action="enter_wallet_address").log("USER_ACTION", "Пользователь ввёл адрес кошелька")
        address = message.text
        await state.update_data(address=address)
        user_data = await state.get_data()
        currency = user_data.get('withdraw_cryptocurrency')
        network = user_data.get('withdraw_network')
        amount = user_data.get('amount')
        logger.bind(user_id=user_id, action="enter_wallet_address").log(
            "USER_ACTION",
            f"Запрос на вывод средств: сумма={amount}, валюта={currency}, сеть={network}, адрес={address}"
        )
        await message.answer(
            text=(
                f"💸 *Ваш запрос на вывод средств:*"
                f"\n💳 **Сумма:** `{amount}₽`"
                f"\n🌍 **Валюта:** `{currency}`"
                f"\n🔗 **Сеть:** `{network}`"
                f"\n📥 **Кошелек:** `{address}`"
                f"\n⚠️ *Обратите внимание:*"
                f"\nПри выводе средств на криптокошелёк сервис может взимать комиссию."
                f"\n✅ Подтвердите запрос, чтобы продолжить."
            ),
            parse_mode="Markdown",
            reply_markup=confirm_conclusion_btn
        )
        await state.clear()
    except Exception as e:
        logger.opt(exception=e).error(f"Ошибка в хэндлере /enter_wallet_address: {e}")

@router.callback_query(F.data == 'cancel_withdrawal')
async def cancel_withdrawal(call: types.CallbackQuery, state: FSMContext):
    try:
        user_id = call.from_user.id
        logger.bind(user_id=user_id, action="cancel_withdrawal").log("USER_ACTION", "Пользователь отменил вывод средств")
        await call.message.delete()
        await state.clear()
        await call.message.answer(text="Вывод средств отменен🙅‍♂️")
    except Exception as e:
        logger.opt(exception=e).error(f"Ошибка в хэндлере /cancel_withdrawal: {e}")

@router.callback_query(F.data == 'confirm_withdrawal')
async def confirm_withdrawal(call: types.CallbackQuery, state: FSMContext):
    try:
        user_id = call.from_user.id
        logger.bind(user_id=user_id, action="confirm_withdrawal").log("USER_ACTION", "Пользователь подтвердил вывод средств")
        await call.message.delete()
        user_data = await state.get_data()
        amount = user_data.get('amount')
        currency = user_data.get('withdraw_cryptocurrency')
        address = user_data.get('address')
        network = user_data.get('withdraw_network')

        # logger.bind(user_id=user_id, action="confirm_withdrawal").log("USER_ACTION", f"Запрос к БД: получение пользователя {user_id}")
        user = await models.User.get_user(user_id)
        logger.bind(user_id=user_id, action="confirm_withdrawal").log("USER_ACTION", f"Результат из БД: баланс={user.ref_balance}")

        # Создаем новый платеж в базе данных
        logger.bind(user_id=user_id, action="confirm_withdrawal").log("USER_ACTION", "Запрос к БД: создание выплаты")
        payout = await models.PayOut.create_payout(
            user=user,
            amount=amount,
            currency=currency,
            address=address,
            network=network,
        )
        logger.bind(user_id=user_id, action="confirm_withdrawal").log("USER_ACTION", f"Выплата создана: ID={payout.id}")

        # Выполняем выплату через Cryptomus API
        logger.bind(user_id=user_id, action="confirm_withdrawal").log("USER_ACTION", "Вызов Cryptomus API для выплаты")
        pay = await create_a_payout(amount=str(amount), to_currency=currency, order_id=payout.id, address=address, network=network)

        if pay:
            user.ref_balance -= amount
            await user.save()
            logger.bind(user_id=user_id, action="confirm_withdrawal").log("USER_ACTION", f"Баланс обновлен: новый баланс={user.ref_balance}")

            try:
                commission = getattr(pay, 'commission', 3)
                logger.bind(user_id=user_id, action="confirm_withdrawal").log("USER_ACTION", f"Комиссия: {commission}")
            except Exception as e:
                logger.opt(exception=e).error(f"Ошибка получения комиссии в /confirm_withdrawal: {e}")
                commission = None

            message_text = (
                f"✅ *Заявка на вывод средств успешно завершена!*"
                f"\n💳 **Сумма:** `{amount}₽`"
                f"\n📥 **Кошелек:** `{address}`"
            )

            if commission is not None:
                message_text += f"\n💸 **Комиссия:** `{commission}$`"

            await call.message.answer(
                text=message_text,
                parse_mode="Markdown"
            )
    except Exception as e:
        logger.opt(exception=e).error(f"Ошибка в хэндлере /confirm_withdrawal: {e}")

@router.message(AffiliateState.enter_withdraw_requisites)
async def enter_withdraw_requisites(m: types.Message, state: FSMContext):
    try:
        user_id = m.from_user.id
        logger.bind(user_id=user_id, action="enter_withdraw_requisites").log("USER_ACTION", "Пользователь ввёл реквизиты карты")
        data = await state.get_data()
        amount = data.get('amount')
        requisites = m.text
        logger.bind(user_id=user_id, action="enter_withdraw_requisites").log("USER_ACTION", f"Введено: реквизиты={requisites}, сумма={amount}")
        await state.update_data(requisites=requisites)

        # logger.bind(user_id=user_id, action="enter_withdraw_requisites").log("USER_ACTION", f"Запрос к БД: получение пользователя {user_id}")
        user = await models.User.get_user(user_id)
        logger.bind(user_id=user_id, action="enter_withdraw_requisites").log("USER_ACTION", f"Результат из БД: баланс={user.ref_balance}")

        if user.ref_balance < amount:
            logger.bind(user_id=user_id, action="enter_withdraw_requisites").log("USER_ACTION", "Ошибка: недостаточно средств")
            await m.answer(text='Недостаточно средств', reply_markup=back_mk)
            return

        mk = types.InlineKeyboardMarkup(
            inline_keyboard=[
                [
                    types.InlineKeyboardButton(text=bt.CONFIRM_BTN, callback_data='confirm_withdraw')
                ],
                [
                    types.InlineKeyboardButton(text=bt.BACK_BTN, callback_data='withdraw')
                ]
            ]
        )
        await m.answer(text=bt.WITHDRAW_INFO.format(amount=amount, requisites=requisites), reply_markup=mk)
    except Exception as e:
        logger.opt(exception=e).error(f"Ошибка в хэндлере /enter_withdraw_requisites: {e}")

@router.callback_query(F.data == 'confirm_withdraw')
async def confirm_withdraw(call: types.CallbackQuery, state: FSMContext):
    try:
        user_id = call.from_user.id
        logger.bind(user_id=user_id, action="confirm_withdraw").log("USER_ACTION", "Пользователь подтвердил заявку на вывод")
        await call.answer()
        data = await state.get_data()
        amount = float(data.get('amount'))
        requisites = data.get('requisites')

        # logger.bind(user_id=user_id, action="confirm_withdraw").log("USER_ACTION", f"Запрос к БД: получение пользователя {user_id}")
        user = await models.User.get_user(user_id)
        logger.bind(user_id=user_id, action="confirm_withdraw").log("USER_ACTION", f"Результат из БД: баланс={user.ref_balance}")

        if user.ref_balance < amount:
            logger.bind(user_id=user_id, action="confirm_withdraw").log("USER_ACTION", "Ошибка: недостаточно средств")
            await call.message.answer(text='Недостаточно средств', reply_markup=back_mk)
            return

        user.ref_balance -= amount
        await user.save()
        logger.bind(user_id=user_id, action="confirm_withdraw").log("USER_ACTION", f"Баланс обновлен: новый баланс={user.ref_balance}")

        if user.ref_balance < 0:
            user.ref_balance += amount
            await user.save()
            logger.bind(user_id=user_id, action="confirm_withdraw").log("USER_ACTION", "Ошибка: отрицательный баланс, откат изменений")
            return

        logger.bind(user_id=user_id, action="confirm_withdraw").log("USER_ACTION", "Запрос к БД: создание заявки на вывод")
        withdraw_obj = await models.Withdraw.add_withdraw(user, requisites, amount)
        logger.bind(user_id=user_id, action="confirm_withdraw").log("USER_ACTION", f"Заявка создана: ID={withdraw_obj.id}")

        await call.message.edit_text(text='Заявка на вывод отправлена')

        mk = types.InlineKeyboardMarkup(
            inline_keyboard=[
                [
                    types.InlineKeyboardButton(text=bt.CONFIRM_BTN, callback_data=f'admin_withdraw:{withdraw_obj.id}')
                ],
                [
                    types.InlineKeyboardButton(text=bt.DECLINE_BTN,
                                               callback_data=f'admin_withdraw_decline:{withdraw_obj.id}')
                ]
            ]
        )

        logger.bind(user_id=user_id, action="confirm_withdraw").log("USER_ACTION", "Отправка сообщения админу")
        await call.bot.send_message(
            chat_id=dependencies.WITHDRAW_CHAT_ID,
            text=bt.WITHDRAW_INFO.format(amount=amount, requisites=requisites),
            reply_markup=mk
        )
    except Exception as e:
        logger.opt(exception=e).error(f"Ошибка в хэндлере /confirm_withdraw: {e}")

@router.callback_query(F.data.startswith('admin_withdraw_decline:'))
async def admin_withdraw_decline(call: types.CallbackQuery):
    try:
        user_id = call.from_user.id
        logger.bind(user_id=user_id, action="admin_withdraw_decline").log("USER_ACTION", "Админ отклонил заявку на вывод")
        withdraw_id = int(call.data.split(':')[1])
        logger.bind(user_id=user_id, action="admin_withdraw_decline").log("USER_ACTION", f"Запрос к БД: получение заявки ID={withdraw_id}")
        withdraw_obj = await models.Withdraw.get_or_none(id=withdraw_id)
        if not withdraw_obj:
            logger.bind(user_id=user_id, action="admin_withdraw_decline").log("USER_ACTION", "Ошибка: заявка не найдена")
            await call.answer()
            return

        await withdraw_obj.fetch_related('user')
        withdraw_obj.is_success = False
        await withdraw_obj.save()
        logger.bind(user_id=user_id, action="admin_withdraw_decline").log("USER_ACTION", f"Заявка ID={withdraw_id} отклонена")

        withdraw_obj.user.ref_balance += withdraw_obj.amount
        await withdraw_obj.user.save()
        logger.bind(user_id=user_id, action="admin_withdraw_decline").log("USER_ACTION", f"Баланс пользователя восстановлен: +{withdraw_obj.amount}")

        await call.message.edit_text(text=call.message.html_text + '\n<b>❌ Заявка отклонена</b>')
        await call.bot.send_message(
            chat_id=withdraw_obj.user.telegram_id,
            text=f'Ваша заявка на вывод {withdraw_obj.amount}₽ отклонена'
        )
    except Exception as e:
        logger.opt(exception=e).error(f"Ошибка в хэндлере /admin_withdraw_decline: {e}")

@router.callback_query(F.data.startswith('admin_withdraw:'))
async def admin_withdraw(call: types.CallbackQuery):
    try:
        user_id = call.from_user.id
        logger.bind(user_id=user_id, action="admin_withdraw").log("USER_ACTION", "Админ подтвердил заявку на вывод")
        withdraw_id = int(call.data.split(':')[1])
        logger.bind(user_id=user_id, action="admin_withdraw").log("USER_ACTION", f"Запрос к БД: получение заявки ID={withdraw_id}")
        withdraw_obj = await models.Withdraw.get_or_none(id=withdraw_id)
        if not withdraw_obj:
            logger.bind(user_id=user_id, action="admin_withdraw").log("USER_ACTION", "Ошибка: заявка не найдена")
            await call.answer()
            return

        await withdraw_obj.fetch_related('user')
        withdraw_obj.is_success = True
        await withdraw_obj.save()
        logger.bind(user_id=user_id, action="admin_withdraw").log("USER_ACTION", f"Заявка ID={withdraw_id} подтверждена")

        await call.message.edit_text(text=call.message.html_text + '\n<b>✅ Заявка подтверждена</b>')
        await call.bot.send_message(
            chat_id=withdraw_obj.user.telegram_id,
            text=f'Ваша заявка на вывод {withdraw_obj.amount}₽ подтверждена'
        )
    except Exception as e:
        logger.opt(exception=e).error(f"Ошибка в хэндлере /admin_withdraw: {e}")

app\handlers\bot_handler.py
from aiogram import Router, F
from aiogram.filters import ChatMemberUpdatedFilter, KICKED, LEFT, RESTRICTED, MEMBER, ADMINISTRATOR, CREATOR, \
    IS_NOT_MEMBER, IS_MEMBER
from aiogram.types import ChatMemberUpdated

from app import dependencies
from app.db import models
from loguru import logger


router = Router()


@router.chat_member(
    ChatMemberUpdatedFilter(
        member_status_changed=IS_NOT_MEMBER >> IS_MEMBER
    )
)
async def user_subscribe(event: ChatMemberUpdated):
    try:
        user_id = event.from_user.id
        # logger.bind(user_id=user_id, action="user_subscribe").log("USER_ACTION", "Пользователь подписался на канал")
        if str(event.chat.id) != dependencies.CHANNEL_ID:
            return

        # logger.bind(user_id=user_id, action="user_subscribe").log("USER_ACTION", f"Запрос к БД: получение пользователя {user_id}")
        user = await models.User.get_user(user_id)
        # logger.bind(user_id=user_id, action="user_subscribe").log("USER_ACTION", f"Результат из БД: пользователь найден={user is not None}")

        if user is None:
            return

        user.in_channel = True
        await user.save()
        logger.bind(user_id=user_id, action="user_subscribe").log("USER_ACTION", "Статус in_channel обновлён: True")
    except Exception as e:
        logger.opt(exception=e).error(f"Ошибка в хэндлере /user_subscribe: {e}")


@router.chat_member(
    ChatMemberUpdatedFilter(
        member_status_changed=IS_MEMBER >> IS_NOT_MEMBER
    )
)
async def user_unsubscribe(event: ChatMemberUpdated):
    try:
        user_id = event.from_user.id
        if str(event.chat.id) != dependencies.CHANNEL_ID:
            return

        # logger.bind(user_id=user_id, action="user_unsubscribe").log("USER_ACTION", "Пользователь отписался от канала")
        user = await models.User.get_user(user_id)
        if user is None:
            return

        user.in_channel = False
        user.last_check_in = None
        await user.save()
        logger.bind(user_id=user_id, action="user_unsubscribe").log("USER_ACTION", "Статус in_channel обновлён: False, last_check_in сброшен")
    except Exception as e:
        logger.opt(exception=e).error(f"Ошибка в хэндлере /user_unsubscribe: {e}")

app\handlers\get_email_handler.py
from datetime import timedelta
from typing import Union

import asyncio
from aiogram import types, F, Router
from aiogram.filters import Command
from aiogram.fsm.context import FSMContext
from aiogram.utils.keyboard import InlineKeyboardBuilder
from aiogram_dialog import DialogManager, StartMode
from app.db import models
from app.dialogs.receive_email.states import ReceiveEmailMenu
from app.services import bot_texts as bt
from app.services.bot_texts import RENT_EMAIL_WEEK, RENT_EMAIL_MONTH, RENT_EMAIL_SIX_MONTHS, \
    RENT_EMAIL_YEAR
from app.services.low_balance import check_low_balance, send_low_balance_alert
from app.services.mail.temp_mail_tm import create_mail
from app.services.need_subscribe import check_subscribe, send_subscribe_msg
from loguru import logger

router = Router()


@router.message(Command("get_email"))  # Обработка команды /get_email
@router.message(F.text == bt.RECEIVE_EMAIL_BTN)  # кнопка '📩Принять Email'
@router.callback_query(F.data == 'receive_email')  # Обработка коллбэк-запросов с данными 'receive_email'
async def receive_email(message: Union[types.Message, types.CallbackQuery], dialog_manager: DialogManager):
    try:
        user_id = message.from_user.id
        logger.bind(user_id=user_id, action="receive_email").log("USER_ACTION", "Пользователь запросил получение email")

        # logger.bind(user_id=user_id, action="receive_email").log("USER_ACTION", f"Запрос к БД: получение пользователя {user_id}")
        user = await models.User.get_user(user_id)
        # logger.bind(user_id=user_id, action="receive_email").log("USER_ACTION", f"Результат из БД: пользователь найден={user is not None}")

        if not user:
            return

        # logger.bind(user_id=user_id, action="receive_email").log("USER_ACTION", "Проверка подписки")
        sub = await check_subscribe(user)

        if not sub:
            logger.bind(user_id=user_id, action="receive_email").log("USER_ACTION", "Подписка неактивна, отправляем сообщение")
            await send_subscribe_msg(user)
            return

        logger.bind(user_id=user_id, action="receive_email").log("USER_ACTION", f"Запрос к БД: получение непрочитанных писем для {user_id}")
        mails = await models.Mail.filter(user=user, is_paid_mail=False, is_active=True).all()
        logger.bind(user_id=user_id, action="receive_email").log("USER_ACTION", f"Результат из БД: найдено писем={len(mails)}")

        if len(mails) > 0:
            mail = mails[-1]
        else:
            if isinstance(message, types.CallbackQuery):
                temp_mail = message.message
                await temp_mail.edit_text(text=bt.CREATING_EMAIL)
            else:
                temp_mail = await message.answer(text=bt.CREATING_EMAIL)

            logger.bind(user_id=user_id, action="receive_email").log("USER_ACTION", "Создание нового временного email")
            try:
                email, token = await create_mail()
            except Exception as e:
                logger.opt(exception=e).error(f"Ошибка при создании email в /receive_email: {e}")
                await message.answer("В настоящее время сервис недоступен, попробуйте позже🙎‍♂️")
                return

            mail = await models.Mail.add_mail(user, email, token)
            logger.bind(user_id=user_id, action="receive_email").log("USER_ACTION", f"Новый email создан: {email}")

            await temp_mail.delete()

        logger.bind(user_id=user_id, action="receive_email").log("USER_ACTION", f"Запуск диалога с mail_id={mail.id}")
        await dialog_manager.start(ReceiveEmailMenu.receive_email,
                                   data={"mail_id": mail.id},
                                   mode=StartMode.RESET_STACK)
    except Exception as e:
        logger.opt(exception=e).error(f"Ошибка в хэндлере /receive_email: {e}")


@router.callback_query(F.data == 'my_rent_emails')
async def my_rent_emails(call: types.CallbackQuery):
    try:
        user_id = call.from_user.id
        logger.bind(user_id=user_id, action="my_rent_emails").log("USER_ACTION", "Пользователь открыл список арендованных почт")

        # logger.bind(user_id=user_id, action="my_rent_emails").log("USER_ACTION", f"Запрос к БД: получение пользователя {user_id}")
        user = await models.User.get_user(user_id)
        # logger.bind(user_id=user_id, action="my_rent_emails").log("USER_ACTION", f"Результат из БД: пользователь найден={user is not None}")

        if not user:
            return

        logger.bind(user_id=user_id, action="my_rent_emails").log("USER_ACTION", f"Запрос к БД: получение арендованных почт для {user_id}")
        mails = await models.Mail.filter(user=user, is_paid_mail=True, is_active=True).all()
        logger.bind(user_id=user_id, action="my_rent_emails").log("USER_ACTION", f"Результат из БД: найдено почт={len(mails)}")

        if len(mails) == 0:
            logger.bind(user_id=user_id, action="my_rent_emails").log("USER_ACTION", "Нет арендованных почт")
            await call.answer(text='У вас нет арендованных почтовых ящиков', show_alert=True)
            return

        builder = InlineKeyboardBuilder()
        for mail in mails:
            builder.add(types.InlineKeyboardButton(text=mail.email, callback_data=f'mail:{mail.id}'))

        builder.button(text=bt.BACK_BTN, callback_data='receive_email')
        builder.adjust(1)

        await call.message.edit_text(text='Выберите почтовый ящик', reply_markup=builder.as_markup())
    except Exception as e:
        logger.opt(exception=e).error(f"Ошибка в хэндлере /my_rent_emails: {e}")


@router.callback_query(F.data.startswith('receive_my_mail:'))
async def receive_my_mail(call: types.CallbackQuery):
    try:
        user_id = call.from_user.id
        mail_id = int(call.data.split(':')[1])
        logger.bind(user_id=user_id, action="receive_my_mail").log("USER_ACTION", f"Пользователь открыл почту ID={mail_id}")

        logger.bind(user_id=user_id, action="receive_my_mail").log("USER_ACTION", f"Запрос к БД: получение почты ID={mail_id}")
        mail = await models.Mail.get_or_none(id=mail_id)
        logger.bind(user_id=user_id, action="receive_my_mail").log("USER_ACTION", f"Результат из БД: почта найдена={mail is not None}")

        if not mail:
            await call.answer()
            return

        mk = types.InlineKeyboardMarkup(
            inline_keyboard=[
                [
                    types.InlineKeyboardButton(text=bt.BACK_BTN, callback_data=f'mail:{mail.id}')
                ]
            ]
        )
        msg_text = bt.MY_RENT_EMAIL.format(email=mail.email, expire_at=mail.expire_at.strftime('%d.%m.%Y'))
        await call.message.edit_text(text=msg_text, reply_markup=mk)
    except Exception as e:
        logger.opt(exception=e).error(f"Ошибка в хэндлере /receive_my_mail: {e}")


@router.callback_query(F.data.startswith('extend_email:'))
async def extend_email(call: types.CallbackQuery):
    try:
        user_id = call.from_user.id
        mail_id = int(call.data.split(':')[1])
        user = await models.User.get_user(user_id)

        logger.bind(user_id=user_id, action="extend_email").log("USER_ACTION", f"Пользователь начал продление почты ID={mail_id}")

        mail = await models.Mail.filter(user=user).order_by('-id').first()

        keyboard = get_extend_email_kb(mail_id, False)
        await call.message.edit_reply_markup(reply_markup=keyboard)

    except Exception as e:
        logger.opt(exception=e).error(f"Ошибка в хэндлере /extend_email: {e}")



def get_extend_email_kb(mail_id: int, is_free_week: bool):
    builder = InlineKeyboardBuilder()

    if is_free_week:
        builder.button(text=bt.RENT_EMAIL_WEEK_BTN, callback_data=f'extend_email_week:{mail_id}')
    builder.button(text=bt.RENT_EMAIL_MONTH_BTN, callback_data=f'extend_email_month:{mail_id}')
    builder.button(text=bt.RENT_EMAIL_SIX_MONTHS_BTN, callback_data=f'extend_email_six_months:{mail_id}')
    builder.button(text=bt.RENT_EMAIL_YEAR_BTN, callback_data=f'extend_email_year:{mail_id}')
    builder.button(text=bt.BACK_BTN, callback_data=f'mail:{mail_id}')

    builder.adjust(1)
    return builder.as_markup()

@router.callback_query(F.data.startswith('extend_email_'))
async def extend_email_confirm(call: types.CallbackQuery, state: FSMContext):
    try:
        user_id = call.from_user.id
        callback_data = call.data.split(':')  # ['extend_email_month', '6901']
        data_key = callback_data[0]  # например, 'extend_email_month'

        rent_data = {
            'extend_email_week': RENT_EMAIL_WEEK,
            'extend_email_month': RENT_EMAIL_MONTH,
            'extend_email_six_months': RENT_EMAIL_SIX_MONTHS,
            'extend_email_year': RENT_EMAIL_YEAR,
        }

        if data_key not in rent_data:
            logger.bind(user_id=user_id, action="extend_email_confirm").log(
                "USER_ACTION", f"Ошибка: неизвестный ключ срока аренды: {data_key}"
            )
            await call.answer("Неверный формат запроса.", show_alert=True)
            return

        logger.bind(user_id=user_id, action="extend_email_confirm").log(
            "USER_ACTION", f"Пользователь выбрал срок: {data_key}"
        )

        user = await models.User.get_user(user_id)

        price, _, rent_text = rent_data[data_key]
        if user.balance < price:
            logger.bind(user_id=user_id, action="extend_email_confirm").log(
                "USER_ACTION", "Ошибка: недостаточно средств"
            )
            await call.answer(text='Недостаточно средств', show_alert=True)
            return

        mail_id = int(callback_data[1])
        logger.bind(user_id=user_id, action="extend_email_confirm").log(
            "USER_ACTION", f"Запрос к БД: получение почты ID={mail_id}"
        )
        mail = await models.Mail.get_or_none(id=mail_id)

        if not mail:
            logger.bind(user_id=user_id, action="extend_email_confirm").log(
                "USER_ACTION", f"Ошибка: почта с ID={mail_id} не найдена"
            )
            await call.answer("Почта не найдена.", show_alert=True)
            return

        logger.bind(user_id=user_id, action="extend_email_confirm").log(
            "USER_ACTION", f"Результат из БД: почта={mail.email}"
        )

        msg_text = bt.CONFIRM_EXTEND_EMAIL.format(
            email=mail.email,
            rent_text=rent_text,
            cost=price
        )

        mk = types.InlineKeyboardMarkup(
            inline_keyboard=[
                [
                    types.InlineKeyboardButton(
                        text=bt.CONFIRM_BTN,
                        callback_data=f'confirm_{data_key}:{mail_id}'
                    )
                ],
                [
                    types.InlineKeyboardButton(
                        text=bt.BACK_BTN,
                        callback_data=f'mail:{mail_id}'
                    )
                ]
            ]
        )

        await call.message.edit_text(text=msg_text, reply_markup=mk)

    except Exception as e:
        logger.opt(exception=e).error(f"Ошибка в хэндлере /extend_email_confirm: {e}")
        await call.answer("Произошла ошибка. Попробуйте позже.", show_alert=True)



@router.callback_query(F.data.startswith('confirm_extend_email_'))
async def confirm_extend_email(call: types.CallbackQuery):
    try:
        user_id = call.from_user.id
        mail_id = int(call.data.split(':')[1])
        logger.bind(user_id=user_id, action="confirm_extend_email").log(
            "USER_ACTION", f"Подтверждение продления почты ID={mail_id}"
        )

        logger.bind(user_id=user_id, action="confirm_extend_email").log(
            "USER_ACTION", f"Запрос к БД: получение почты ID={mail_id}"
        )
        mail = await models.Mail.get_or_none(id=mail_id)

        if not mail:
            await call.answer("Почта не найдена.", show_alert=True)
            return

        logger.bind(user_id=user_id, action="confirm_extend_email").log(
            "USER_ACTION", f"Результат из БД: почта={mail.email}"
        )

        user = await models.User.get_user(user_id)
        if not user:
            await call.answer("Пользователь не найден.", show_alert=True)
            return

        logger.bind(user_id=user_id, action="confirm_extend_email").log(
            "USER_ACTION", f"Результат из БД: баланс={user.balance}"
        )

        raw_key = call.data.split(':')[0]  # confirm_extend_email_month
        data_key = raw_key.replace('confirm_extend_', 'rent_')

        rent_data = {
            'rent_email_week': RENT_EMAIL_WEEK,
            'rent_email_month': RENT_EMAIL_MONTH,
            'rent_email_six_months': RENT_EMAIL_SIX_MONTHS,
            'rent_email_year': RENT_EMAIL_YEAR,
        }

        if data_key not in rent_data:
            logger.bind(user_id=user_id, action="confirm_extend_email").log(
                "USER_ACTION", f"Ошибка: неизвестный ключ срока аренды: {data_key}"
            )
            await call.answer("Неверный срок аренды.", show_alert=True)
            return

        price, days, rent_text = rent_data[data_key]

        if user.balance < price:
            logger.bind(user_id=user_id, action="confirm_extend_email").log(
                "USER_ACTION", "Ошибка: недостаточно средств"
            )
            await call.answer(text='Недостаточно средств', show_alert=True)
            return

        logger.bind(user_id=user_id, action="confirm_extend_email").log(
            "USER_ACTION", f"Обновление срока аренды: +{days} дней"
        )
        mail.expire_at += timedelta(days=days)
        await mail.save(update_fields=['expire_at'])

        low_balance = await check_low_balance(user, price)
        user.balance -= price
        await user.save(update_fields=['balance'])
        logger.bind(user_id=user_id, action="confirm_extend_email").log(
            "USER_ACTION", f"Баланс обновлён: новый баланс={user.balance}"
        )

        msg_text = bt.EXTEND_EMAIL_SUCCESS.format(
            email=mail.email,
            rent_text=rent_text
        )
        await call.message.edit_text(text=msg_text)
        await call.answer()
        await asyncio.sleep(2)

        if low_balance:
            logger.bind(user_id=user_id, action="confirm_extend_email").log(
                "USER_ACTION", "Отправка уведомления о низком балансе"
            )
            await send_low_balance_alert(user)

    except Exception as e:
        logger.opt(exception=e).error(f"Ошибка в хэндлере /confirm_extend_email: {e}")
        await call.answer("Произошла ошибка.", show_alert=True)


app\handlers\health_check_router.py
from aiogram import Router
from aiogram.types import Message
from aiogram.filters.command import Command

health_check_router = Router()

@health_check_router.message(Command("ping"))
async def ping_handler(message: Message):
    await message.answer("OK")


app\handlers\receive_sms_handler.py
from aiogram import types, F, Router
from aiogram.filters import Command
from aiogram_dialog import DialogManager, StartMode
from pyonlinesim import OnlineSMS
from aiogram.exceptions import TelegramBadRequest
from app.db import models
from app.dependencies import API_KEY_ONLINESIM, bot
from app.dialogs.receive_sms.getters import service_is_smsactivate
from app.dialogs.receive_sms.selected import send_service_info_with_keyboard
from app.dialogs.receive_sms.states import ServiceMenu
from app.services import bot_texts as bt
from app.services.bot_texts import SERVICES_TRANSLATION
from app.services.mail.receive_messages import fetch_full_message
from app.services.need_subscribe import check_subscribe, send_subscribe_msg
from app.services.periodic_tasks import notice_of_arraignment
from app.services.sms_receive import SmsReceive
from loguru import logger
import html
from bs4 import BeautifulSoup
import re
import asyncio


router = Router()


def log_exceptions(func):
    async def wrapper(*args, **kwargs):
        try:
            return await func(*args, **kwargs)
        except Exception as e:
            logger.opt(exception=e).error(f"Ошибка в обработчике {func.__name__}: {e}")
            raise
    return wrapper


@router.message(Command("get_sms"))
@router.message(F.text == bt.RECEIVE_SMS_BTN)
async def receive_sms(message: types.Message, dialog_manager: DialogManager):
    try:
        user_id = message.from_user.id
        logger.bind(user_id=user_id, action="receive_sms").log("USER_ACTION", "Пользователь запросил получение SMS")
        # logger.bind(user_id=user_id, action="receive_sms").log("USER_ACTION", f"Запрос к БД: получение пользователя {user_id}")
        user = await models.User.get_user(user_id)
        logger.bind(user_id=user_id, action="receive_sms").log("USER_ACTION", f"Результат из БД: пользователь найден={user is not None}, баланс = {user.balance} ₽")

        if not user:
            return

        logger.bind(user_id=user_id, action="receive_sms").log("USER_ACTION", "Проверка активации")
        activation = await models.Activation.get_active_activation(user.id)

        if activation is None:
            # logger.bind(user_id=user_id, action="receive_sms").log("USER_ACTION", "Проверка подписки")
            sub = await check_subscribe(user)
            if not sub:
                logger.bind(user_id=user_id, action="receive_sms").log("USER_ACTION", "Подписка неактивна, отправляем сообщение")
                await send_subscribe_msg(user)
                return
            logger.bind(user_id=user_id, action="receive_sms").log("USER_ACTION", "Запуск диалога выбора сервиса")
            await dialog_manager.start(ServiceMenu.select_service, mode=StartMode.RESET_STACK)
        else:
            logger.bind(user_id=user_id, action="receive_sms").log("USER_ACTION", "Получение информации о текущей активации")
            await activation.fetch_related('country')
            country = activation.country.name
            service = await models.ServicesSmsActivate.get_service_name_by_id(service_id=activation.service_id)
            if service is None:
                service = await models.ServicesOnlinesim.get_service_name_by_id(service_id=activation.service_2_id)
            logger.bind(user_id=user_id, action="receive_sms").log("USER_ACTION", f"Текущая активация: сервис={service}, страна={country}")
            await send_service_info_with_keyboard(message=message, activation=activation, service=service, country=country)
    except Exception as e:
        logger.opt(exception=e).error(f"Ошибка в хэндлере /receive_sms: {e}")


@router.callback_query(F.data == 'receive_sms_for_another_service')
async def receive_sms_for_another_service(call: types.CallbackQuery, dialog_manager: DialogManager):
    try:
        user_id = call.from_user.id
        logger.bind(user_id=user_id, action="receive_sms_for_another_service").log("USER_ACTION", "Принять SMS для другого сервиса")
        await dialog_manager.reset_stack()
        await dialog_manager.start(ServiceMenu.select_service, mode=StartMode.NORMAL)
    except Exception as e:
        logger.opt(exception=e).error(f"Ошибка в хэндлере /receive_sms_for_another_service: {e}")


@router.callback_query(F.data.startswith('request_code:'))
@log_exceptions
async def request_code(call: types.CallbackQuery, **kwargs):
    try:
        user_id = call.from_user.id
        activation_id = int(call.data.split(':')[1])
        logger.bind(user_id=user_id, action="request_code").log("USER_ACTION", f"Запрос к БД: получение активации ID={activation_id}")
        activation = await models.Activation.get_or_none(id=activation_id).prefetch_related('service')
        logger.bind(user_id=user_id, action="request_code").log("USER_ACTION", f"Результат из БД: активация найдена={activation is not None}")

        if not activation:
            await call.answer()
            return
        try:
            service = activation.service.code
            service_name = "SMSActivate"
        except AttributeError:
            # service = activation.service_2.code
            service_name = "Onlinesim"
        except Exception:
            logger.bind(user_id=user_id, action="request_code").log("USER_ACTION", "Ошибка: сервис не найден")
            return

        if service_name == "Onlinesim":
            logger.bind(user_id=user_id, action="request_code").log("USER_ACTION", "Используется сервис Onlinesim")
            client = OnlineSMS(api_key=API_KEY_ONLINESIM)
            try:
                # Попробуем перезапросить SMS
                revise_response = await client.revise_order(operation_id=activation.activation_id)
                if revise_response.get("response") == '1':
                    logger.bind(user_id=user_id, action="request_code").log("USER_ACTION", "Ожидание повторной отправки SMS")
                    # Теперь ждём SMS
                    try:
                        order_info = await client.get_order_info(operation_id=activation.activation_id,
                            get_full_message=True,
                            form=1,
                            clean=1
                        )
                    except Exception as e:
                        await call.answer(text='Нового смс нет, попробуйте позже', show_alert=True)
                        logger.opt(exception=e).error(f"Ошибка в request_code: {e}")
                        return
                    sms_text = order_info[0]['msg']
                    if not sms_text:
                        await call.answer(text='Ожидаем смс...', show_alert=True)
                        return
                    else:
                        msg_text = (
                            f"💬<b>Повторное SMS</b> на номер: +{activation.phone_number}\n\n"
                            f"Ваш код активации:\n"
                            f"<code>{sms_text}</code>"
                        )
                        # Отправляем сообщение пользователю в Telegram
                        await bot.send_message(
                            chat_id=user_id,
                            text=msg_text
                        )
                        await notice_of_arraignment("Получение смс", activation, sms_text)
                        logger.bind(
                            user_id=activation.user.telegram_id,
                            action="new_sms"
                        ).log("USER_ACTION",
                              f"Получено новое SMS для номера {activation.phone_number}, код: {sms_text}")

                    return
                else:
                    logger.bind(user_id=user_id, action="request_code").log("USER_ACTION", "Ошибка: повторная отправка недоступна")
                    await call.answer(text='Повторная отправка недоступна')
                    return
            except Exception as e:
                logger.opt(exception=e).warning(f'Повторный запрос смс onlinesim {e}')
                return
        else:
            logger.bind(user_id=user_id, action="request_code").log("USER_ACTION", "Используется сервис SMSActivate")
            sms = SmsReceive()
            status = str(await sms.get_activation_status(activation.activation_id))
            logger.bind(user_id=user_id, action="request_code").log("USER_ACTION", f"Текущий статус активации: {status}")

            if status:
                request_status = str(await sms.set_activation_status(activation_id=activation.activation_id,
                                                                     status=models.ActivationCode.RETRY_GET))
                logger.bind(user_id=user_id, action="request_code").log("USER_ACTION", f"Новый статус: {request_status}")

                if request_status == "STATUS_WAIT_RETRY":
                    await call.answer(text='ожидание повторной отправки смс', show_alert=True)
                    return
                elif request_status != "STATUS_WAIT_CODE":
                    await call.answer(text='ожидание смс')
                    return
                elif request_status != "STATUS_CANCEL":
                    await call.answer(text='активация отменена')
                    return
                elif request_status != "STATUS_OK":
                    await call.answer(text='код получен')
                    return
    except Exception as e:
        logger.opt(exception=e).error(f"Ошибка в хэндлере /request_code: {e}")


@router.callback_query(F.data.startswith('cancel_service:'))
async def cancel_service(call: types.CallbackQuery, **kwargs):
    user_id = call.from_user.id
    try:
        user = await models.User.get_user(telegram_id=call.from_user.id)
        activation_id = int(call.data.split(':')[1])
        logger.bind(user_id=user_id, action="cancel_service").log("USER_ACTION", f"Пользователь запрашивает отмену активации ID={activation_id}, баланс = {user.balance} ₽")
        if await service_is_smsactivate():
            activation = await models.Activation.get_or_none(id=activation_id).prefetch_related('service')
        else:
            activation = await models.Activation.get_or_none(id=activation_id).prefetch_related('service_2')
        logger.bind(user_id=user_id, action="cancel_service").log("USER_ACTION", f"Результат из БД: активация найдена={activation is not None}")

        if not activation:
            logger.bind(user_id=user_id, action="cancel_service").log("USER_ACTION", "Активация не найдена")
            await call.answer(text='Номер автоматически отменится через 10 минут', show_alert=True)
            await call.answer()
            return

        formatted_time = activation.activation_expire_at.strftime("%H:%M")
        try:
            if await service_is_smsactivate():
                service = activation.service.code
            else:
                service = activation.service_2.code
        except AttributeError:
            logger.bind(user_id=user_id, action="cancel_service").log("USER_ACTION", "Ошибка: сервис не найден")
            await call.answer(text=f'Номер автоматически отменится в {formatted_time}', show_alert=True)
            return

        cancellation_successful = False
        if service in SERVICES_TRANSLATION or not await service_is_smsactivate():
            client = OnlineSMS(api_key=API_KEY_ONLINESIM)
            cancel_status = await client.finish_order(operation_id=activation.activation_id, ban=False)
            cancellation_successful = cancel_status.get("response") == 1
        else:
            sms = SmsReceive()
            status = str(await sms.set_activation_status(activation_id=activation.activation_id,
                                                         status=models.ActivationCode.CANCEL))
            if status == 'STATUS_WAIT_CODE':
                await call.answer(text='Ожидание смс', show_alert=True)
                return
            elif status == 'EARLY_CANCEL_DENIED':
                await call.answer(text='Нельзя отменить в первые 2 минуты', show_alert=True)
                return
            elif status == "ACCESS_CANCEL":
                cancellation_successful = True

        if cancellation_successful:
            activation.activation_expire_at = None
            user = await models.User.get_user(telegram_id=call.from_user.id)
            if activation.sms_text is None and activation.status == models.StatusResponse.STATUS_WAIT_CODE:
                    user.balance += activation.cost
                    await user.save()
                    logger.bind(user_id=user_id, action="cancel_service").log("USER_ACTION", f"Если нет смс, возвращаем деньги, баланс = {user.balance} ₽")
                    msg_text = bt.SERVICE_CANCEL_MONEY_RETURNED.strip()
            else:
                msg_text = bt.SERVICE_CANCEL.strip()
            activation.status = models.StatusResponse.STATUS_CANCEL
            await activation.save()
            try:
                if call.message.text.strip() != msg_text or call.message.reply_markup is not None:
                    await call.message.edit_text(text=msg_text)
                    # await call.message.edit_reply_markup(reply_markup=None)
            except TelegramBadRequest as e:
                logger.opt(exception=e).warning("Не удалось изменить сообщение или клавиатуру")
        else:
            await call.answer(text='Отмена больше не доступна', show_alert=True)
            logger.bind(user_id=user_id, action="cancel_service").log("USER_ACTION",
                                                                      f"Отмена больше не доступна")
    except TelegramBadRequest as e:
        logger.opt(exception=e).warning(f"Telegram server error: {e}")
    except Exception as e:
        error_text = str(e)
        if error_text == 'Unable to finish order':
            await call.answer(text='Нельзя отменить в первые 2 минуты', show_alert=True)
            logger.bind(user_id=user_id, action="cancel_service").log("USER_ACTION",
                                                                      f"Нельзя отменить в первые 2 минуты")
        elif error_text == 'Wrong operation ID':
            activation.activation_expire_at = None
            activation.status = models.StatusResponse.STATUS_CANCEL
            await activation.save()
            await call.answer(text='Отмена больше не доступна', show_alert=True)
            logger.bind(user_id=user_id, action="cancel_service").log("USER_ACTION",
                                                                      f"Отмена больше не доступна")
        elif error_text == 'Try again later':
            await call.answer(text='Повторите попытку позже', show_alert=True)
            logger.bind(user_id=user_id, action="cancel_service").log("USER_ACTION",
                                                                      f"Повторите попытку позже")
        else:
            text = error_text[0].upper() + error_text[1:] if error_text else "Неизвестная ошибка"
            logger.bind(user_id=user_id, action="cancel_service").log("USER_ACTION",
                                                                      f"Ошибка при отмене номера.\n{text}")
            await call.answer(text=f'Ошибка при отмене номера.\n{text}', show_alert=True)


@router.callback_query(F.data.startswith('full_unread_message|'))
async def unread_message(call: types.CallbackQuery, **kwargs):
    try:
        user_id = call.from_user.id
        logger.bind(user_id=user_id, action="unread_message").log("USER_ACTION", "Пользователь запросил полный текст сообщения")
        _, message_id, mail_id = call.data.split("|")
        mail_id = int(mail_id)
        logger.bind(user_id=user_id, action="unread_message").log("USER_ACTION", f"Запрос к БД: получение сообщения ID={mail_id}")
        mail = await models.Mail.get_or_none(id=mail_id).prefetch_related("user")
        logger.bind(user_id=user_id, action="unread_message").log("USER_ACTION", f"Результат из БД: сообщение найдено={mail is not None}")

        if not mail:
            logger.bind(user_id=user_id, action="unread_message").log("USER_ACTION", "Ошибка: сообщение не найдено")
            return

        logger.bind(user_id=user_id, action="unread_message").log("USER_ACTION", "Получение полного текста сообщения")
        text = await fetch_full_message(mail.token, message_id)

        # Удаляем HTML-теги <a> и <img>
        soup = BeautifulSoup(text, "html.parser")
        for a in soup.find_all("a"):
            a.decompose()
        for img in soup.find_all("img"):
            img.decompose()

        # Получаем очищенный текст
        cleaned_text = soup.get_text()
        # Удаляем ссылки вида "https://example.com "
        cleaned_text = re.sub(r"https?://\S+", "", cleaned_text)
        # Удаляем ссылки в формате [text](https://example.com )
        cleaned_text = re.sub(r"\[.*?\]\(https?://\S+\)", "", cleaned_text)
        # Экранируем HTML
        cleaned_text = html.escape(cleaned_text)

        msg_text = (
            f'📩<b>Полный текст сообщения</b> на почту: <b>{mail.email}</b>\n'
            f'{cleaned_text}'
        )

        logger.bind(user_id=user_id, action="unread_message").log("USER_ACTION", f"Отправка сообщения пользователю {mail.user.telegram_id}")
        if len(msg_text) <= 4096:
            await bot.send_message(chat_id=mail.user.telegram_id, text=msg_text, parse_mode="HTML")
        else:
            parts = await split_message(msg_text, 4096)
            for part in parts:
                await bot.send_message(chat_id=mail.user.telegram_id, text=part, parse_mode="HTML")
    except Exception as e:
        logger.opt(exception=e).error(f"Ошибка в хэндлере /unread_message: {e}")


async def split_message(text: str, max_length: int) -> list:
    """Разбивает длинное сообщение на части, не превышающие max_length."""
    logger.bind(action="split_message").log("USER_ACTION", f"Разделение сообщения длиной {len(text)} символов")
    lines = text.split('\n')
    parts = []
    current_part = ""
    for line in lines:
        if len(current_part) + len(line) + 1 > max_length:
            parts.append(current_part)
            current_part = ""
        current_part += line + '\n'
    if current_part:
        parts.append(current_part)
    logger.bind(action="split_message").log("USER_ACTION", f"Сообщение разделено на {len(parts)} частей")
    return parts


app\handlers\rent_number_handler.py
from aiogram import types, F, Router
from aiogram.filters import Command
from aiogram_dialog import DialogManager, StartMode
from app.db import models
from app.db.models import StatusResponse
from app.dialogs.rent_sms.states import RentCountryMenu
from app.dialogs.personal_cabinet.states import PersonalMenu
from app.services.bot_texts import country_flags, DOLLAR_ONLINESIM
from app.services.need_subscribe import check_subscribe, send_subscribe_msg
from app.services import bot_texts as bt
from app.services.onlinesim.rent_number import OnlineSimRentAPI
from loguru import logger

router = Router()


@router.message(Command("rent_number"))
@router.message(F.text == bt.RENT_NUMBER)
async def rent_number(message: types.Message, dialog_manager: DialogManager):
    """
    📞Арендовать номер
    """
    user_id = message.from_user.id
    logger.bind(user_id=user_id, action='rent_number').log("USER_ACTION", "Пользователь начал процесс аренды номера")
    try:
        user = await models.User.get_user(user_id)
        logger.bind(user_id=user_id, action='rent_number').log("USER_ACTION",
                                                              f"Запрос к БД: получение данных пользователя {user_id}, баланс = {user.balance} ₽")
        # Проверяем подписку
        sub = await check_subscribe(user)
        if not sub:
            logger.bind(user_id=user_id, action='rent_number').log("USER_ACTION",
                                                                  f"Подписка неактивна для пользователя {user_id}, баланс = {user.balance} ₽")
            await send_subscribe_msg(user)
            return
        # Проверяем аренды пользователя
        activation_list = await models.Rent.get_active_rent(user.id)
        logger.bind(user_id=user_id, action='rent_number').log("USER_ACTION",
                                                              f"Запрос к БД: получение активных аренд для пользователя {user_id}, баланс = {user.balance} ₽")
        logger.bind(user_id=user_id, action='rent_number').log("USER_ACTION",
                                                              f"Результат из БД: найдено активных аренд - {len(activation_list) if activation_list else 0}")
        # Если нет активных арендных номеров, то предлагаем
        if activation_list is None or not activation_list:
            logger.bind(user_id=user_id, action='rent_number').log("USER_ACTION",
                                                                  f"Нет активных аренд, перенаправляем в выбор страны для пользователя {user_id}, баланс = {user.balance} ₽")
            await dialog_manager.start(RentCountryMenu.select_country, mode=StartMode.RESET_STACK)
            return
        # Отправляем меню аренды
        await send_rent_menu(user, message=message)
    except Exception as e:
        logger.opt(exception=e).error(f"Ошибка в хэндлере /rent_number: {e}")


async def send_rent_menu(user: "User", message: types.Message = None, callback_query: types.CallbackQuery = None):
    """
    Вспомогательная функция для отправки меню аренды номеров.
    """
    user_id = user.telegram_id
    logger.bind(user_id=user_id, action='send_rent_menu').log("USER_ACTION", f"Формирование меню аренды для пользователя {user_id}, баланс = {user.balance} ₽")
    try:
        # Проверяем аренды пользователя
        activation_list = await models.Rent.get_active_rent(user.id)
        logger.bind(user_id=user_id, action='send_rent_menu').log("USER_ACTION",
                                                                 f"Запрос к БД: получение активных аренд для формирования меню")
        logger.bind(user_id=user_id, action='send_rent_menu').log("USER_ACTION",
                                                                 f"Результат из БД: найдено активных аренд - {len(activation_list) if activation_list else 0}")

        # Создаем список для вывода информации
        rent_details = ["<i>Ваши арендованные номера⤵️</i>\n"]
        # Создаем inline клавиатуру
        keyboard = types.InlineKeyboardMarkup(inline_keyboard=[])
        # Проходим по всем арендам
        for activation in activation_list:
            # Если аренда отменена, пропускаем ее
            if activation.is_canceled:
                continue
            # Загружаем связанные данные о стране
            await activation.fetch_related('country')
            country = activation.country.name
            # Формируем строку с флагом и номером
            flag = country_flags.get(country, "")  # Получаем флаг по имени страны
            phone_number = activation.phone_number
            # Формируем текст кнопки (флаг + номер)
            button_text = f"{flag} +{phone_number}"
            # Создаем кнопку с уникальным callback_data для каждого номера
            callback_data = f"number_{activation.id}"
            # Добавляем кнопку в клавиатуру
            keyboard.inline_keyboard.append([types.InlineKeyboardButton(text=button_text, callback_data=callback_data)])
        # Добавляем кнопку для аренды нового номера
        keyboard.inline_keyboard.append([types.InlineKeyboardButton(text=bt.RENT_NEW_ROOM, callback_data="new_number")])
        # Отправляем сообщение с inline клавиатурой
        if message:
            await message.answer("\n".join(rent_details), reply_markup=keyboard)
        else:
            await callback_query.message.edit_text("\n".join(rent_details), reply_markup=keyboard)
    except Exception as e:
        logger.opt(exception=e).error(f"Ошибка в send_rent_menu: {e}")


@router.callback_query(F.data == "back_to_rent_menu")
async def back_to_rent_menu(callback_query: types.CallbackQuery, dialog_manager: DialogManager):
    """
    Обработка кнопки 'Назад', возвращающая в меню аренды номеров.
    """
    user_id = callback_query.from_user.id
    logger.bind(user_id=user_id, action='back_to_rent_menu').log("USER_ACTION", f"Пользователь вернулся в меню аренды")
    try:
        user = await models.User.get_user(user_id)
        logger.bind(user_id=user_id, action='back_to_rent_menu').log("USER_ACTION",
                                                                    f"Запрос к БД: получение данных пользователя {user_id}, баланс = {user.balance} ₽")
        # Отправляем меню аренды
        await send_rent_menu(user, callback_query=callback_query)
    except Exception as e:
        logger.opt(exception=e).error(f"Ошибка в хэндлере /back_to_rent_menu: {e}")


# Обработчик для нажатия на кнопку арендованного номера
@router.callback_query(F.data.startswith('number_'))
async def rent_number_selected(callback_query: types.CallbackQuery, dialog_manager: DialogManager):
    """
    Обработка выбора арендованного номера
    """
    user_id = callback_query.from_user.id
    user = await models.User.get_user(user_id)
    logger.bind(user_id=user_id, action='rent_number_selected').log("USER_ACTION", f"Пользователь выбрал арендованный номер, баланс = {user.balance} ₽")
    try:
        rent_id = int(callback_query.data.split('_')[1])  # Извлекаем id аренды из callback_data
        logger.bind(user_id=user_id, action='rent_number_selected').log("USER_ACTION",
                                                                      f"Выбрана аренда с ID={rent_id}")
        rented = await models.Rent.get_rent(id=rent_id)  # Получаем аренду по id
        logger.bind(user_id=user_id, action='rent_number_selected').log("USER_ACTION",
                                                                      f"Запрос к БД: получение аренды с ID={rent_id}")
        if rented:
            # Проверяем, отменена ли аренда
            if rented.is_canceled:
                await callback_query.answer("Эта аренда была отменена.", show_alert=True)
                logger.bind(user_id=user_id, action='rent_number_selected').log("USER_ACTION",
                                                                              f"Аренда ID={rent_id} отменена, баланс = {user.balance} ₽")
                return
            # Формируем информацию о номере
            country = await models.Rent.get_country_by_rent(id=rent_id)
            phone_number = rented.phone_number
            expiry_date = rented.rent_expire_at.strftime("%d.%m.%y %H:%M")  # Пример формата даты
            flag = country_flags.get(country, "")  # Получаем флаг по имени страны
            sms = rented.sms_text
            # Текст для отправки пользователю
            rent_details = bt.RENT_DETAILS.format(
                phone_number=phone_number,
                country=country,
                expiry_date=expiry_date,
                flag=flag
            )
            if sms:
                # Форматируем сообщения для вывода
                formatted_sms = "\n".join(
                    [f"• <b>{service}:</b> {text}" for line in sms.split("\n") if
                     (split_line := line.split(": ", 1)) and len(split_line) == 2 and (service := split_line[0]) and (
                         text := split_line[1])]
                )
                # Добавляем блок с сообщениями
                rent_details += f"\n<b>Ваши сообщения:</b>\n{formatted_sms}"

                # Логируем завершение обработки и текущий баланс
                logger.bind(user_id=user_id, action='rent_number_selected').log(
                    "USER_ACTION",
                    f"Отображение аренды: номер={phone_number}, страна={country}, истекает={expiry_date}, есть_sms={bool(sms)}, баланс = {user.balance} ₽"
                )

            # Создаем inline клавиатуру
            keyboard = types.InlineKeyboardMarkup(inline_keyboard=[])
            # Кнопки для управления автопродлением
            if rented.autorenew:
                keyboard.inline_keyboard.append([types.InlineKeyboardButton(text="✅ Автопродление включено",
                                                                           callback_data=f"auto_renew_{rent_id}")])
            else:
                keyboard.inline_keyboard.append([types.InlineKeyboardButton(text="❌Автопродление выключено",
                                                                           callback_data=f"auto_renew_{rent_id}")])
            # Кнопки для продления и отмены аренды
            keyboard.inline_keyboard.append([
                types.InlineKeyboardButton(text="🔄 Продлить аренду", callback_data=f"extend_rent_{rent_id}"),
                types.InlineKeyboardButton(text="🚫 Отменить аренду", callback_data=f"cancel_rent_{rent_id}")
            ])
            # Кнопка для возврата
            keyboard.inline_keyboard.append([
                types.InlineKeyboardButton(text="🔙 Назад", callback_data="back_to_rent_menu")
            ])
            # Отправляем информацию о номере и клавиатуру
            await callback_query.message.edit_text(rent_details, reply_markup=keyboard)
        else:
            logger.bind(user_id=user_id, action='rent_number_selected').log("USER_ACTION",
                                                                          f"Аренда ID={rent_id} не найдена, баланс = {user.balance} ₽")
            await callback_query.answer("Номер не найден.")
    except Exception as e:
        logger.opt(exception=e).error(f"Ошибка в хэндлере /rent_number_selected: {e}")


# Обработчик изменения состояния автопродления
@router.callback_query(F.data.startswith('auto_renew_'))
async def toggle_autorenew(callback_query: types.CallbackQuery):
    """
    Обработка переключения состояния автопродления.
    """
    user_id = callback_query.from_user.id
    user = await models.User.get_user(user_id)
    logger.bind(user_id=user_id, action='toggle_autorenew').log("USER_ACTION", f"Пользователь изменяет состояние автопродления, баланс = {user.balance} ₽")
    try:
        rent_id = int(callback_query.data.split('_')[2])  # Извлекаем id аренды из callback_data
        logger.bind(user_id=user_id, action='toggle_autorenew').log("USER_ACTION",
                                                                   f"Обновление автопродления для аренды ID={rent_id}")
        # Получаем аренду по id
        rented = await models.Rent.get_rent(id=rent_id)
        logger.bind(user_id=user_id, action='toggle_autorenew').log("USER_ACTION",
                                                                   f"Запрос к БД: получение аренды с ID={rent_id}")
        if not rented:
            logger.bind(user_id=user_id, action='toggle_autorenew').log("USER_ACTION",
                                                                       f"Аренда ID={rent_id} не найдена")
            await callback_query.answer("Аренда не найдена.", show_alert=True)
            return
        # Переключаем значение autorenew
        old_state = rented.autorenew
        rented.autorenew = not rented.autorenew
        # Обновляем статус уведомления
        rented.is_notified = False
        await rented.save()
        logger.bind(user_id=user_id, action='toggle_autorenew').log("USER_ACTION",
                                                                   f"Результат из БД: автопродление для аренды ID={rent_id} изменено с {old_state} на {rented.autorenew}, баланс = {user.balance} ₽")
        # Сообщаем пользователю о новом состоянии
        new_state = "включено" if rented.autorenew else "выключено"
        await callback_query.answer(f"Автопродление {new_state}.")
        # Формируем информацию о номере
        country = await models.Rent.get_country_by_rent(id=rent_id)
        phone_number = rented.phone_number
        expiry_date = rented.rent_expire_at.strftime("%d.%m.%y %H:%M")  # Пример формата даты
        flag = country_flags.get(country, "")  # Получаем флаг по имени страны
        sms = rented.sms_text
        # Текст для отправки пользователю
        rent_details = bt.RENT_DETAILS.format(
            phone_number=phone_number,
            country=country,
            expiry_date=expiry_date,
            flag=flag
        )
        if sms:
            # Форматируем сообщения для вывода
            formatted_sms = "\n".join(
                [f"• <b>{service}:</b> {text}" for line in sms.split("\n") if
                 (split_line := line.split(": ", 1)) and len(split_line) == 2 and (service := split_line[0]) and (
                     text := split_line[1])]
            )
            # Добавляем блок с сообщениями
            rent_details += f"\n<b>Ваши сообщения:</b>\n{formatted_sms}"
        # Формируем обновленные кнопки
        keyboard = types.InlineKeyboardMarkup(inline_keyboard=[])
        # Кнопка автопродления
        if rented.autorenew:
            keyboard.inline_keyboard.append([
                types.InlineKeyboardButton(
                    text="✅ Автопродление включено", callback_data=f"auto_renew_{rent_id}"
                )
            ])
        else:
            keyboard.inline_keyboard.append([
                types.InlineKeyboardButton(
                    text="❌ Автопродление выключено", callback_data=f"auto_renew_{rent_id}"
                )
            ])
        # Кнопки для продления и отмены аренды
        keyboard.inline_keyboard.append([
            types.InlineKeyboardButton(
                text="🔄 Продлить аренду", callback_data=f"extend_rent_{rent_id}"
            ),
            types.InlineKeyboardButton(
                text="🚫 Отменить аренду", callback_data=f"cancel_rent_{rent_id}"
            )
        ])
        # Кнопка для возврата
        keyboard.inline_keyboard.append([
            types.InlineKeyboardButton(
                text="🔙 Назад", callback_data="back_to_rent_menu"
            )
        ])
        await callback_query.message.edit_text(rent_details, reply_markup=keyboard)
    except Exception as e:
        logger.opt(exception=e).error(f"Ошибка в хэндлере /toggle_autorenew: {e}")


# Арендовать новый номер
@router.callback_query(F.data.startswith('new_number'))
async def rent_new_number(callback_query: types.CallbackQuery, dialog_manager: DialogManager):
    """
    Обработка аренды нового номера
    """
    user_id = callback_query.from_user.id
    logger.bind(user_id=user_id, action='rent_new_number').log("USER_ACTION", f"Пользователь начал аренду нового номера")
    try:
        # Передаем только необходимые данные для восстановления
        context_data = {
            'chat_id': callback_query.message.chat.id,
            'message_id': callback_query.message.message_id
        }
        # Завершаем текущий диалог или возвращаем в предыдущий
        logger.bind(user_id=user_id, action='rent_new_number').log("USER_ACTION",
                                                                  f"Переход к выбору страны для аренды нового номера")
        await dialog_manager.start(
            RentCountryMenu.select_country,  # Состояние для выбора страны
            context_data  # Передаем только нужные данные
        )
    except Exception as e:
        logger.opt(exception=e).error(f"Ошибка в хэндлере /rent_new_number: {e}")


# Отмена аренды
@router.callback_query(F.data.startswith('cancel_rent_'))
async def cancel_rent(callback_query: types.CallbackQuery):
    """
    Обработка отмены аренды номера.
    """
    user_id = callback_query.from_user.id
    user = await models.User.get_user(user_id)
    logger.bind(user_id=user_id, action='cancel_rent').log("USER_ACTION", f"Пользователь начал отмену аренды, баланс = {user.balance} ₽")
    try:
        rent_id = int(callback_query.data.split('_')[2])  # Извлекаем id аренды из callback_data
        logger.bind(user_id=user_id, action='cancel_rent').log("USER_ACTION",
                                                               f"Отмена аренды с ID={rent_id}")
        user = await models.User.get_user(user_id)
        logger.bind(user_id=user_id, action='cancel_rent').log("USER_ACTION",
                                                               f"Запрос к БД: получение данных пользователя {user_id}, баланс = {user.balance} ₽")
        # Проверяем, существует ли аренда и не отменена ли она
        rented = await models.Rent.get_rent(id=rent_id)
        logger.bind(user_id=user_id, action='cancel_rent').log("USER_ACTION",
                                                               f"Запрос к БД: получение аренды с ID={rent_id}")
        if not rented:
            logger.bind(user_id=user_id, action='cancel_rent').log("USER_ACTION",
                                                                   f"Аренда ID={rent_id} не найдена, баланс = {user.balance} ₽")
            await callback_query.answer(bt.RENT_NOT_FOUND_MSG, show_alert=True)
            await callback_query.message.delete()
            return
        if rented.is_canceled:
            logger.bind(user_id=user_id, action='cancel_rent').log("USER_ACTION",
                                                                   f"Аренда ID={rent_id} уже отменена, баланс = {user.balance} ₽")
            await callback_query.answer(bt.RENT_ALREADY_CANCELED_MSG, show_alert=True)
            await callback_query.message.delete()
            return
        # Используем API для отмены аренды
        api = OnlineSimRentAPI()  # Создаем экземпляр API
        # Если статус аренды в ожидании, то возвращаем баланс
        if rented.status == StatusResponse.STATUS_WAIT_CODE and not rented.refund_processed:
            user.balance += rented.cost
            rented.refund_processed = True
            await rented.save()
            await user.save()
            logger.bind(user_id=user_id, action='cancel_rent').log("USER_ACTION",
                                                                   f"Баланс пользователя увеличен на {rented.cost}, баланс = {user.balance} ₽")
        try:
            response = await api.close_rent_num(tzid=rented.rent_id)  # Передаем ID операции аренды
            if response.get("response"):
                # Успешно отменено, обновляем статус аренды в базе данных
                rented.is_canceled = True
                await rented.save()  # Сохраняем изменения в базе данных
                logger.bind(user_id=user_id, action='cancel_rent').log("USER_ACTION",
                                                                       f"Аренда ID={rent_id} успешно отменена, баланс = {user.balance} ₽")
                await callback_query.answer(bt.RENT_CANCEL_SUCCESS_MSG, show_alert=True)
                # Удаляем сообщение о текущей аренде
                await callback_query.message.delete()
                # Обновляем меню аренды
                await send_rent_menu(user, callback_query=callback_query)
            else:
                # Если API вернул неизвестный ответ
                await callback_query.answer(bt.RENT_CANCEL_FAILED_MSG, show_alert=True)
                logger.error(f"Неизвестный ответ API при отмене аренды: {response}")
        except Exception as e:
            # Обрабатываем специфическую ошибку
            if "ERROR_NO_OPERATIONS" in str(e):
                logger.error(e)
                await callback_query.answer(bt.RENT_CANCEL_SUCCESS_MSG, show_alert=True)
            else:
                await callback_query.answer(bt.RENT_CANCEL_FAILED_MSG, show_alert=True)
            # Удаляем сообщение о текущей аренде
            await callback_query.message.delete()
            # В случае ошибки переводим аренду в статус отмененной
            rented.is_canceled = True
            await rented.save()  # Сохраняем изменения в базе данных
            logger.bind(user_id=user_id, action='cancel_rent').log("USER_ACTION",
                                                                   f"Аренда ID={rent_id} переведена в статус отмененной, баланс = {user.balance} ₽")
    except Exception as e:
        logger.opt(exception=e).error(f"Ошибка в хэндлере /cancel_rent: {e}")


# Продление аренды
@router.callback_query(F.data.startswith('extend_rent_'))
async def extend_rent(callback_query: types.CallbackQuery, dialog_manager: DialogManager):
    """
    Обработка продления аренды.
    """
    user_id = callback_query.from_user.id
    user = await models.User.get_user(user_id)
    logger.bind(user_id=user_id, action='extend_rent').log("USER_ACTION", f"Пользователь начал продление аренды, баланс = {user.balance} ₽")
    try:
        rent_id = int(callback_query.data.split('_')[2])  # Извлекаем id аренды из callback_data
        logger.bind(user_id=user_id, action='extend_rent').log("USER_ACTION",
                                                               f"Продление аренды с ID={rent_id}")
        rented = await models.Rent.get_rent(id=rent_id)  # получаем объект Rent
        logger.bind(user_id=user_id, action='extend_rent').log("USER_ACTION",
                                                               f"Запрос к БД: получение аренды с ID={rent_id}")
        # Получаем состояние аренды через OnlineSimRentAPI
        api_client = OnlineSimRentAPI()
        rent_state = await api_client.get_rent_state(tzid=rented.rent_id)
        logger.bind(user_id=user_id, action='extend_rent').log("USER_ACTION",
                                                               f"Результат API: состояние аренды {rent_state}")
        # Проверяем, если список пуст или extend отсутствует
        if not rent_state or not rent_state.get("list") or not rent_state["list"]:
            await callback_query.answer(text=bt.RENTAL_CANCELED_OR_NOT_FOUND, show_alert=True)
            return
        if "extend" not in rent_state["list"][0]:
            await callback_query.answer(text=bt.FAILED_TO_GET_AVAILABLE_DAYS, show_alert=True)
            return
        rent_country_code = rented.country.country_id
        country = rented.country.name
        # Извлекаем тарифы для выбранной страны
        data = await api_client.get_tariffs()
        tariffs = data.get(str(rent_country_code), {})
        # Преобразуем тарифы: умножаем цены на DOLLAR_RATE
        if tariffs:  # Проверяем, есть ли данные
            updated_tariffs = {days: round(price * DOLLAR_ONLINESIM) for days, price in tariffs.items()}
        else:
            await callback_query.answer(text=bt.FAILED_TO_GET_AVAILABLE_DAYS, show_alert=True)
            return
        context_data = {
            "selected_country": {
                "rent_country_code": rent_country_code,
                "country": country,
                "tariffs": updated_tariffs,  # Сохраняем только нужные тарифы
                "tzid": rented.rent_id,
            }}
        logger.bind(user_id=user_id, action='extend_rent').log("USER_ACTION",
                                                               f"Переход к деталям страны для продления аренды, баланс = {user.balance} ₽")
        await dialog_manager.start(
            RentCountryMenu.country_details,  # Состояние для выбора страны
            context_data  # Передаем только нужные данные
        )
    except Exception as e:
        logger.opt(exception=e).error(f"Ошибка в хэндлере /extend_rent: {e}")


# Пополнение баланса
@router.callback_query(F.data.startswith('top_up_balance'))
async def top_up_balance(callback_query: types.CallbackQuery, dialog_manager: DialogManager):
    """
    Обработка пополнения баланса
    """
    user_id = callback_query.from_user.id
    logger.bind(user_id=user_id, action='top_up_balance').log("USER_ACTION", f"Пользователь начал пополнение баланса")
    try:
        user = await models.User.get_user(user_id)
        logger.bind(user_id=user_id, action='top_up_balance').log("USER_ACTION",
                                                                 f"Запрос к БД: получение данных пользователя {user_id}, баланс = {user.balance} ₽")
        context_data = {
            'user_id': user.telegram_id,
            'auto_renewal': True,
        }
        logger.bind(user_id=user_id, action='top_up_balance').log("USER_ACTION",
                                                                 f"Переход к окну пополнения баланса")
        await dialog_manager.start(
            PersonalMenu.deposit,  # Состояние для выбора страны
            context_data  # Передаем только нужные данные
        )
    except Exception as e:
        logger.opt(exception=e).error(f"Ошибка в хэндлере /top_up_balance: {e}")

app\handlers\report.py
from aiogram import types
from aiogram.filters import Command
from aiogram.fsm.context import FSMContext
from tortoise.functions import Sum
import tempfile
from datetime import datetime
from app.db import models
from app.dependencies import ADMINS, bot
import pytz
from aiogram import Router, types, F
from loguru import logger

router = Router()


@router.message(Command('user_report'))
async def user_report(message: types.Message):
    user_id = message.from_user.id
    logger.bind(user_id=user_id, action="user_report").log("USER_ACTION", "Запрос на генерацию отчёта по пользователю")

    if user_id not in ADMINS:
        logger.warning(f"Пользователь {user_id} не является администратором")
        return

    args = message.text.split()
    if len(args) != 2:
        logger.bind(user_id=user_id, action="user_report").warning("Неверное количество аргументов")
        await message.answer("Использование: /user_report [telegram_id]")
        return

    try:
        telegram_id = int(args[1])
        logger.bind(user_id=user_id, action="user_report").info(f"Получен Telegram ID: {telegram_id}")
    except ValueError:
        logger.bind(user_id=user_id, action="user_report").warning("Некорректный Telegram ID")
        await message.answer("Некорректный Telegram ID")
        return

    user = await models.User.get_or_none(telegram_id=telegram_id)
    if not user:
        logger.bind(user_id=user_id, action="user_report").info(f"Пользователь с ID={telegram_id} не найден")
        await message.answer("Пользователь с таким Telegram ID не найден.")
        return

    logger.bind(user_id=user_id, action="user_report").info(f"Генерация отчёта для пользователя {telegram_id}")
    try:
        html_path = await generate_user_report_html(user)
        logger.bind(user_id=user_id, action="user_report").success(
            f"Отчёт успешно сгенерирован для пользователя {telegram_id}")
        await message.answer_document(types.FSInputFile(html_path), caption=f"Отчёт по пользователю {user.mention}")
    except Exception as e:
        logger.bind(user_id=user_id, action="user_report").opt(exception=e).error("Ошибка при генерации отчёта")
        await message.answer("Произошла ошибка при генерации отчёта.")


async def generate_user_report_html(user):
    tz = pytz.timezone('Europe/Moscow')

    # Получаем данные
    logger.bind(user_id=user.telegram_id, action="generate_user_report").debug("Запрос данных из БД для отчёта")
    payments = await models.Payment.filter(user=user, is_success=True).order_by("-created_at")
    withdraws = await models.Withdraw.filter(user=user).order_by("-created_at")
    activations = await models.Activation.filter(user=user, sms_text__isnull=False).order_by(
        "-created_at").prefetch_related("country", "service", "service_2")
    rents = await models.Rent.filter(user=user, sms_text__isnull=False).order_by("-created_at").prefetch_related(
        "country")
    mails = await models.Mail.filter(user=user).order_by("-created_at")
    letters = await models.Letter.filter(user=user).order_by("-created_at")

    # Подсчёты
    total_payments = sum([p.amount for p in payments])
    total_spent = sum([a.cost for a in activations]) + sum([r.cost for r in rents if r.sms_text])  # Только аренды с SMS
    total_rents = len([r for r in rents if r.sms_text])  # Только аренды с SMS
    total_sms = len(activations)
    total_mails = len(mails)
    total_letters = len(letters)

    # Формат времени
    def fmt(dt):
        if dt:
            localized_dt = dt.astimezone(tz)
            return localized_dt.strftime("%d.%m.%Y %H:%M")
        return "-"

    # HTML-таблицы
    def make_table(headers, rows):
        head_html = "".join([f"<th>{h}</th>" for h in headers])
        rows_html = "".join([
            f"<tr>{''.join(f'<td>{c}</td>' for c in row)}</tr>"
            for row in rows
        ])
        return f"<table><thead><tr>{head_html}</tr></thead><tbody>{rows_html}</tbody></table><br>"

    logger.bind(user_id=user.telegram_id, action="generate_user_report").debug("Формирование HTML-отчёта")
    html_content = f"""
    <html>
    <head>
        <meta charset="UTF-8">
        <style>
            table {{ border-collapse: collapse; width: 100%; margin-bottom: 20px; }}
            th, td {{ border: 1px solid #ccc; padding: 6px; text-align: left; }}
            th {{ background-color: #f4f4f4; }}
        </style>
    </head>
    <body>
        <h2>Отчёт по пользователю {user.mention} ({user.telegram_id})</h2>

        <h3>Общие данные:</h3>
        <p>Баланс: {user.balance:.2f} ₽<br>
        Бонусный баланс: {user.ref_balance:.2f} ₽<br>
        Всего заработано на рефералах: {user.total_ref_earnings:.2f} ₽<br>
        В канале: {'Да' if user.in_channel else 'Нет'}<br>
        Дата регистрации: {fmt(user.created_at)}<br>
        Последний запрос: {fmt(user.last_request_time)}</p>

        <h3>Пополнения (всего {len(payments)} на сумму {total_payments:.2f} ₽):</h3>
        {make_table(['Сумма', 'Метод', 'Дата'], [[f"{p.amount:.2f} ₽", p.method.value, fmt(p.created_at)] for p in payments])}

        <h3>Выводы (всего {len(withdraws)}):</h3>
        {make_table(['Сумма', 'Реквизиты', 'Статус', 'Дата'], [[f"{w.amount:.2f} ₽", w.requisites, '✅' if w.is_success else '❌', fmt(w.created_at)] for w in withdraws])}

        <h3>Активации SMS (всего {total_sms}):</h3>
        {make_table(['Номер', 'Сервис', 'Страна', 'Цена', 'Текст SMS', 'Дата'], [
        [
            a.phone_number,
            (lambda a: "-" if not a.service and not a.service_2 else a.service.name if a.service else a.service_2.name)(a),
            a.country.name if a.country else "-",
            f"{a.cost:.2f} ₽",
            a.sms_text or '-',
            fmt(a.created_at)
        ]
        for a in activations
        ])}

        <h3>Аренды номеров (всего {total_rents}):</h3>
        {make_table(['Номер', 'Страна', 'Цена', 'SMS', 'Дата', 'Автопродление'], [
        [r.phone_number, r.country.name, f"{r.cost:.2f} ₽", r.sms_text or '-', fmt(r.created_at), 'Да' if r.autorenew else 'Нет']
        for r in rents
    ])}

        <h3>Почты (всего {total_mails}):</h3>
        {make_table(['Email', 'Платная', 'Создана', 'Истекает'], [
        [m.email, 'Да' if m.is_paid_mail else 'Нет', fmt(m.created_at), fmt(m.expire_at)]
        for m in mails
    ])}

        <h3>Письма (всего {total_letters}):</h3>
        {make_table(['Текст', 'Дата'], [
        [l.text, fmt(l.created_at)]
        for l in letters
    ])}

        <h3>Итоги:</h3>
        <p>Всего пополнено: {total_payments:.2f} ₽<br>
        Всего потрачено: {total_spent:.2f} ₽<br>
        Аренд: {total_rents}<br>
        SMS: {total_sms}<br>
        Почт: {total_mails}<br>
        Писем: {total_letters}</p>
    </body>
    </html>
    """

    # Сохраняем временный файл
    with tempfile.NamedTemporaryFile(mode='w+', suffix='.html', delete=False, encoding='utf-8') as f:
        f.write(html_content)
        f.flush()
        file_path = f.name

    logger.bind(user_id=user.telegram_id, action="generate_user_report").success("HTML-файл отчёта успешно сохранён")
    return file_path

app\handlers\start_handler.py
from typing import Union
import logging
from aiogram import types, F, Router
from aiogram.filters import Command, CommandObject
from aiogram_dialog import DialogManager, StartMode
from app.db import models
from app.dependencies import bot
from app.dialogs.personal_cabinet.states import PersonalMenu
from app.dialogs.receive_email.states import ReceiveEmailMenu
from app.dialogs.receive_sms.selected import send_country_info
from app.services import bot_texts as bt
from app.services.keyboards import start_kb
from app.services.need_subscribe import check_subscribe, send_subscribe_msg
from loguru import logger
from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton

from app.services.periodic_tasks import balance_replenishment_notification

router = Router()


@router.message(F.text == '/id')
async def get_id(message: types.Message):
    try:
        user_id = message.from_user.id
        logger.bind(user_id=user_id, action='get_id').log(
            "USER_ACTION",
            f"Пользователь запросил свой ID"
        )
        await message.answer(text=str(message.chat.id))
    except Exception as e:
        logger.opt(exception=e).error(f"Ошибка в хэндлере /id: {e}")


@router.callback_query(F.data == 'start')
@router.message(Command('start'))
async def start(message: Union[types.Message, types.CallbackQuery], dialog_manager: DialogManager,
                command: CommandObject):
    try:
        user_id = message.from_user.id
        logger.bind(user_id=user_id, action='start').log(
            "USER_ACTION",
            f"Пользователь начал взаимодействие с ботом"
        )

        user = await models.User.get_user(user_id)
        if not user:
            refer_id = command.args
            if refer_id and refer_id.isdigit():
                logger.bind(user_id=user_id, action='start').log(
                    "USER_ACTION",
                    f"Обнаружен реферальный ID: {refer_id}"
                )
                refer_id = int(refer_id)
                refer = await models.User.get_or_none(telegram_id=refer_id)
                user = await models.User.add_user(message.from_user, refer)

                if refer and not refer.disable_ref_notifications:
                    keyboard = InlineKeyboardMarkup(inline_keyboard=[
                        [InlineKeyboardButton(text="🔕 Отключить уведомление",
                                              callback_data=f"disable_notify:{refer.telegram_id}")]
                    ])
                    await bot.send_message(
                        chat_id=refer.telegram_id,
                        text=f"📈 У Вас новый реферал\n└ Аккаунт: {user.telegram_id}",
                        reply_markup=keyboard
                    )

            else:
                logger.bind(user_id=user_id, action='start').log(
                    "USER_ACTION",
                    f"Реферальный ID отсутствует или некорректен"
                )
                user = await models.User.add_user(message.from_user)

        if isinstance(message, types.CallbackQuery):
            logger.bind(user_id=user_id, action='start').log(
                "USER_ACTION",
                f"Удаление сообщения после нажатия кнопки 'start'"
            )
            await message.message.delete()

        sub = await check_subscribe(user)
        if not sub:
            logger.bind(user_id=user_id, action='start').log(
                "USER_ACTION",
                f"Подписка не оформлена"
            )
            await send_subscribe_msg(user)
            return

        logger.bind(user_id=user_id, action='start').log(
            "USER_ACTION",
            f"Отправка главного меню"
        )
        await message.answer(text=bt.MAIN_MENU, reply_markup=start_kb())
    except Exception as e:
        logger.opt(exception=e).error(f"Ошибка в хэндлере /start: {e}")


@router.callback_query(F.data.startswith("disable_notify:"))
async def disable_notify_callback(callback: types.CallbackQuery):
    try:
        _, user_id = callback.data.split(":")
        user = await models.User.get_or_none(telegram_id=int(user_id))
        if user:
            user.disable_ref_notifications = True
            await user.save()
            await callback.message.edit_reply_markup()
            await callback.answer("Уведомления о рефералах отключены.", show_alert=True)
    except Exception as e:
        logger.opt(exception=e).error("Ошибка при отключении уведомлений")


@router.callback_query(F.data.startswith("enable_ref_notify:"))
async def enable_ref_notify(callback: types.CallbackQuery):
    print("Уведомления о рефералах включены.")
    try:
        _, user_id = callback.data.split(":")
        user = await models.User.get_or_none(telegram_id=int(user_id))
        if user:
            user.disable_ref_notifications = False
            await user.save()
            await callback.answer("Уведомления о рефералах включены.", show_alert=True)
    except Exception as e:
        logger.opt(exception=e).error("Ошибка при включении уведомлений")



@router.callback_query(F.data == 'check_subscribe')
async def check_subscribe_handler(call: types.CallbackQuery):
    try:
        user_id = call.from_user.id
        # logger.bind(user_id=user_id, action='check_subscribe').log(
        #     "USER_ACTION",
        #     f"Проверка подписки пользователя"
        # )

        user = await models.User.get_user(user_id)
        sub = await check_subscribe(user)
        if sub:
            # logger.bind(user_id=user_id, action='check_subscribe').log(
            #     "USER_ACTION",
            #     f"Подписка подтверждена"
            # )
            await call.message.delete()
            await call.message.answer(text=bt.MAIN_MENU, reply_markup=start_kb())
        else:
            # logger.bind(user_id=user_id, action='check_subscribe').log(
            #     "USER_ACTION",
            #     f"Подписка не найдена"
            # )
            await call.answer(text='Вы не подписаны на канал', show_alert=True)
    except Exception as e:
        logger.opt(exception=e).error(f"Ошибка в хэндлере check_subscribe: {e}")


@router.message(Command("account"))
@router.message(F.text == bt.PERSONAL_CABINET_BTN)
async def personal_cabinet(message: types.Message, dialog_manager: DialogManager):
    try:
        user_id = message.from_user.id
        logger.bind(user_id=user_id, action='personal_cabinet').log(
            "USER_ACTION",
            f"Переход в личный кабинет"
        )

        user = await models.User.get_user(user_id)
        sub = await check_subscribe(user)
        if not sub:
            logger.bind(user_id=user_id, action='personal_cabinet').log(
                "USER_ACTION",
                f"Подписка не оформлена"
            )
            await send_subscribe_msg(user)
            return

        logger.bind(user_id=user_id, action='personal_cabinet').log(
            "USER_ACTION",
            f"Запуск диалога PersonalMenu.user_info"
        )
        await dialog_manager.start(PersonalMenu.user_info, mode=StartMode.RESET_STACK)
    except Exception as e:
        logger.opt(exception=e).error(f"Ошибка в хэндлере personal_cabinet: {e}")


@router.callback_query(F.data.startswith('mail:'))
async def mail_info(call: types.CallbackQuery):
    try:
        user_id = call.from_user.id
        mail_id = int(call.data.split(':')[1])
        logger.bind(user_id=user_id, action='mail_info').log(
            "USER_ACTION",
            f"Пользователь запросил информацию о почте с ID={mail_id}"
        )

        mail = await models.Mail.get_or_none(id=mail_id)
        if not mail:
            logger.bind(user_id=user_id, action='mail_info').log(
                "USER_ACTION",
                f"Почта с ID={mail_id} не найдена"
            )
            await call.answer()
            return

        msg_text = bt.PAID_EMAIL_INFO.format(email=mail.email, expire_at=mail.expire_at.strftime('%d.%m.%Y'))
        mk = types.InlineKeyboardMarkup(
            inline_keyboard=[
                [
                    types.InlineKeyboardButton(text=bt.RECEIVE_MY_EMAIL_BTN, callback_data=f'receive_my_mail:{mail.id}'),
                ],
                [
                    types.InlineKeyboardButton(text=bt.EXTEND_EMAIL_BTN, callback_data=f'extend_email:{mail.id}')
                ],
                [
                    types.InlineKeyboardButton(text=bt.BACK_BTN, callback_data='my_rent_emails')
                ]
            ]
        )
        logger.bind(user_id=user_id, action='mail_info').log(
            "USER_ACTION",
            f"Отображение информации о почте '{mail.email}'"
        )
        await call.message.edit_text(text=msg_text, reply_markup=mk)
    except Exception as e:
        logger.opt(exception=e).error(f"Ошибка в хэндлере mail_info: {e}")


@router.callback_query(F.data.startswith('continue_payment:'))
async def continue_payment(call: types.CallbackQuery, dialog_manager: DialogManager):
    try:
        user_id = call.from_user.id
        payment_id = int(call.data.split(':')[1])
        logger.bind(user_id=user_id, action='continue_payment').log(
            "USER_ACTION",
            f"Продолжение оплаты для платежа ID={payment_id}"
        )

        payment = await models.Payment.get_or_none(id=payment_id)
        if not payment:
            logger.bind(user_id=user_id, action='continue_payment').log(
                "USER_ACTION",
                f"Платёж с ID={payment_id} не найден"
            )
            await call.answer()
            return

        if 'email' in payment.continue_data:
            logger.bind(user_id=user_id, action='continue_payment').log(
                "USER_ACTION",
                f"Старт диалога ReceiveEmailMenu.rent_email_confirm"
            )
            await dialog_manager.start(ReceiveEmailMenu.rent_email_confirm, data=payment.continue_data,
                                       mode=StartMode.RESET_STACK)
        else:
            logger.bind(user_id=user_id, action='continue_payment').log(
                "USER_ACTION",
                f"Вызов send_country_info для продолжения оплаты"
            )
            await send_country_info(payment.continue_data['service_code'], call, dialog_manager)
    except Exception as e:
        logger.opt(exception=e).error(f"Ошибка в хэндлере continue_payment: {e}")


@router.callback_query(F.data.startswith('bonus_price:'))
async def bonus_price(call: types.CallbackQuery, dialog_manager: DialogManager):
    try:
        user_id = call.from_user.id
        price = call.data.split(':')[1]
        logger.bind(user_id=user_id, action='bonus_price').log(
            "USER_ACTION",
            f"Выбрана сумма бонуса: {price}"
        )

        user = await models.User.get_user(user_id)
        if not user:
            logger.bind(user_id=user_id, action='bonus_price').log(
                "USER_ACTION",
                f"Пользователь не найден"
            )
            return

        if price == 'other':
            logger.bind(user_id=user_id, action='bonus_price').log(
                "USER_ACTION",
                f"Запрос ввода произвольной суммы"
            )
            await call.message.edit_reply_markup()
            await dialog_manager.start(PersonalMenu.enter_amount, mode=StartMode.RESET_STACK)
        else:
            logger.bind(user_id=user_id, action='bonus_price').log(
                "USER_ACTION",
                f"Отправка клавиатуры оплаты на сумму {price}"
            )
            from app.dialogs.personal_cabinet.selected import send_payment_keyboard
            await send_payment_keyboard(call, price=float(price))
    except Exception as e:
        logger.opt(exception=e).error(f"Ошибка в хэндлере bonus_price: {e}")


@router.message(Command('rent'))
async def rent(message: types.Message, dialog_manager: DialogManager):
    try:
        user_id = message.from_user.id
        logger.bind(user_id=user_id, action='rent').log(
            "USER_ACTION",
            f"Пользователь начал процесс аренды"
        )
        from app.dialogs.receive_email.selected import on_rent_email_check_discount
        await on_rent_email_check_discount(message, dialog_manager)
    except Exception as e:
        logger.opt(exception=e).error(f"Ошибка в хэндлере /rent: {e}")


@router.callback_query(lambda c: c.data and c.data.startswith('rental'))
async def process_rent_callback(message: types.Message, dialog_manager: DialogManager):
    try:
        user_id = message.from_user.id
        logger.bind(user_id=user_id, action='process_rent_callback').log(
            "USER_ACTION",
            f"Обработка inline-кнопки 'Продлить аренду'"
        )
        from app.dialogs.receive_email.selected import on_rent_email_check_discount
        await on_rent_email_check_discount(message, dialog_manager)
    except Exception as e:
        logger.opt(exception=e).error(f"Ошибка в хэндлере process_rent_callback: {e}")


@router.message(Command("test_notify"))
async def test_balance_notify(m: types.Message):
    user = await models.User.get_or_none(telegram_id=m.from_user.id)
    if not user:
        await m.answer("Пользователь не найден в базе.")
        return

    # Пример: создаём тестовый платеж (не сохраняем в БД, можно мокнуть)
    class DummyPayment:
        def __init__(self, user):
            self.user = user
            self.amount = 123.45

    payment = DummyPayment(user=user)

    # Название сервиса может быть "LAVA", "YOOMONEY", и т.д.
    await balance_replenishment_notification(payment, service="LAVA")
    await m.answer("Тестовое уведомление отправлено.")

app\handlers\__init__.py


app\services\anypay.py
import requests
import hashlib
import json

from app.dependencies import ANY_PAY_ID, ANY_PAY_API_KEY, ANY_PAY_PROJECT_ID


class AnypayAPI:
    """
    Класс для работы с API Anypay.

    Предоставляет методы для выполнения различных операций через API Anypay,
    включая проверку баланса, получение курсов валют, создание платежей и выплат.
    """

    def __init__(self):
        self.anypay_id = ANY_PAY_ID
        self.anypay_api_key = ANY_PAY_API_KEY
        self.anypay_project_id = ANY_PAY_PROJECT_ID

    def _generate_sign(self, operation, *args):
        """
        Генерирует подпись для API запроса.

        :param operation: Название операции
        :param args: Дополнительные аргументы для формирования подписи
        :return: SHA-256 хеш строки подписи
        """
        sign_str = f'{operation}{self.anypay_id}' + ''.join(str(arg) for arg in args) + self.anypay_api_key
        return hashlib.sha256(sign_str.encode()).hexdigest()

    async def get_balance(self):
        """
        Получает текущий баланс пользователя.

        :return: Строка с ответом сервера
        """
        sign = self._generate_sign('balance')
        response = requests.get(f"https://anypay.io/api/balance/{self.anypay_id}", params={"sign": sign})
        return response.text

    async def get_rates(self):
        """
        Получает текущие курсы валют.

        :return: Строка с ответом сервера
        """
        sign = self._generate_sign('rates')
        response = requests.get(f"https://anypay.io/api/rates/{self.anypay_id}", params={"sign": sign})
        return response.text

    async def get_commissions(self, project_id):
        """
        Получает комиссии для указанного проекта.

        :param project_id: ID проекта
        :return: Строка с ответом сервера
        """
        sign = self._generate_sign('commissions', project_id)
        response = requests.get(f"https://anypay.io/api/commissions/{self.anypay_id}?project_id={project_id}",
                                params={"sign": sign})
        return response.text

    async def create_payment(self, amount, desc, method, currency='RUB', email='test@mail.ru'):
        """
        Создает новый платеж.

        :param amount: Сумма платежа
        :param currency: Валюта платежа
        :param desc: Описание платежа
        :param method: Метод оплаты (по умолчанию 'card')
        :param email: Email плательщика (по умолчанию 'test@mail.ru')
        :return: URL для оплаты или сообщение об ошибке
        """
        try:
            pay_id = await self.get_last_pay_id()
            sign = self._generate_sign('create-payment', self.anypay_project_id, pay_id, amount, currency, desc, method)
            response = requests.get(
                f"https://anypay.io/api/create-payment/{self.anypay_id}?project_id={self.anypay_project_id}&pay_id={pay_id}&amount={amount}&currency={currency}&desc={desc}&method={method}&email={email}",
                params={"sign": sign}
            )
            response.raise_for_status()

            json_data = response.json()

            if "error" in json_data:
                error_code = json_data["error"].get("code")
                error_message = json_data["error"].get("message", "Неизвестная ошибка")
                return f"Ошибка {error_code}: {error_message}"

            return json_data["result"]["payment_url"]

        except requests.exceptions.RequestException as e:
            return f"Ошибка при запросе: {e}"
        except KeyError:
            return "Ошибка в структуре ответа от сервера."
        except Exception as e:
            return f"Непредвиденная ошибка: {e}"

    async def get_payments(self):
        """
        Получает список платежей.

        :return: Строка с ответом сервера
        """
        sign = self._generate_sign('payments', self.anypay_project_id)
        response = requests.get(f"https://anypay.io/api/payments/{self.anypay_id}?project_id={self.anypay_project_id}",
                                params={"sign": sign})
        return response.text

    async def create_payout(self, payout_id, payout_type, amount, wallet):
        """
        Создает новую выплату.

        :param payout_id: ID выплаты
        :param payout_type: Тип выплаты
        :param amount: Сумма выплаты
        :param wallet: Кошелек для выплаты
        :return: Строка с ответом сервера
        """
        sign = self._generate_sign('create-payout', payout_id, payout_type, amount, wallet)
        response = requests.get(
            f"https://anypay.io/api/create-payout/{self.anypay_id}?payout_id={payout_id}&payout_type={payout_type}&amount={amount}&wallet={wallet}",
            params={"sign": sign})
        return response.text

    async def get_payouts(self):
        """
        Получает список выплат.

        :return: Строка с ответом сервера
        """
        sign = self._generate_sign('payouts')
        response = requests.get(f"https://anypay.io/api/payouts/{self.anypay_id}", params={"sign": sign})
        return response.text

    async def get_ip_notification(self):
        """
        Получает IP-адрес для уведомлений.

        :return: Строка с ответом сервера
        """
        sign = self._generate_sign('ip-notification')
        response = requests.get(f"https://anypay.io/api/ip-notification/{self.anypay_id}", params={"sign": sign})
        return response.text

    async def check_payment(self, comment):
        """
        Проверяет статус платежа по комментарию.

        :param comment: Комментарий к платежу
        :return: Кортеж (статус оплаты)
        """
        payments = json.loads(await self.get_payments())["result"]["payments"]
        for payment in payments.values():
            if payment["desc"] == comment and payment["status"] == "paid":
                return True

        return False

    async def get_last_pay_id(self):
        """
        Получает последний использованный ID платежа.

        :return: Следующий доступный ID платежа
        """
        payments = json.loads(await self.get_payments())["result"]["payments"]
        if payments:
            return max(int(pay_id) for pay_id in payments.keys()) + 1
        return 0



app\services\bot_texts.py
# ========================= Messages =========================

MAIN_MENU = """
Привет👋🏻 

Выбери нужное действие⤵️
"""

SELECT_COUNTRY = 'Выберите страну⤵️'
SELECT_COUNTRY_RENT = ('— Длительная аренда от 3 до 30 дней с возможностью продления\n'
                       '— Неограниченное количество для приема СМС по любым сервисам, доступным в боте\n'
                       '— Если на арендованный номер поступит звонок для подтверждения регистрации, бот укажет звонивший номер\n\n'
                       'Выберите страну⤵️')

SELECT_SERVICE = ('Подходит для приема одного СМС от конкретного сервиса\n'
                  'Срок аренды 20 минут\n'
                  'Повторно воспользоваться номером невозможно!\n\n'
                  'Выберите сервис⤵️')
SELECT_RENTAL_PERIOD = "Выберите срок аренды⤵️"
ENTER_COUNTRY = "Введите наименование страны на русском языке⤵️"
ENTER_SERVICE = "Введите название необходимого сервиса⤵️"

ENTER_COUNTRY_ERROR = "Страна не найдена. Проверьте правильность ввода"

ENTER_SERVICE_ERROR = """
Данный сервис не найден. 

Проверьте правильность ввода, либо введите <b>«Любой другой»</b>
"""


SERVICE_INFO = """
<b>Ваш номер</b> <code>+{phone}</code> (Кликабельно)

<b>Страна:</b> {country}
<b>Сервис:</b> {service}

Ожидаем SMS...

<i>- Срок жизни номера 20 минут.</i>
"""

SERVICE_INFO_TELEGRAM = """
<b>Ваш номер</b> <code>+{phone}</code> (Кликабельно)

<b>Страна:</b> {country}
<b>Сервис:</b> {service}

Ожидаем SMS...

<i>- Срок жизни номера 20 минут</i>
<b>- Если при вводе кода из смс приложение Телеграм выдает ошибку или аккаунт защищен облачным паролем - обязательно отправляйте скриншот в <a href="https://t.me/emailfastsupportbot">@emailfastsupportbot</a></b>
"""

NUMBER_INFO = """
<b>Ваш арендованный номер:</b> <code>+{phone}</code>

<b>Страна:</b> {country}

<i>- Прием первого СМС должен быть совершен в течение первых 20 минут, иначе номер будет отменен, а средства вернутся на баланс.
- После приема первого сообщения номер будет доступен на весь заказанный срок.</i>
"""

RENT_DETAILS = """
<b>Ваш арендованный номер:</b> <code>+{phone_number}</code>

<b>Страна:</b> {flag} {country}

<b>Срок аренды до:</b> {expiry_date} мск

<i>- Убедитесь, что номер используется в течение указанного срока.
- После истечения срока номер станет недоступен.</i>
"""


RENT_SUCCESS_MESSAGE = "✅ Номер успешно арендован на {days}"
NUMBER_RENTAL_CLOSED = "Срок аренды номера {number} истек"

SERVICE_CANCEL_MONEY_RETURNED = """
⛔️Номер отменен

💰Деньги вернулись на баланс.
"""

SERVICE_CANCEL = """
⛔️Номер отменен
"""

NOT_ENOUGH_BALANCE = """
<b>Недостаточно средств</b>

Для оплаты требуется <code>{cost}</code> руб.

Ваш баланс: <code>{balance}</code> руб.
"""

NOT_ENOUGH_BALANCE_ALERT = "Недостаточно средств"

RENT_EMAIL_DISCOUNT_PROMO = """
Специально для вас мы подготовили персональную скидку!
Выберите подходящий срок аренды для продления⤵️
"""

RENT_EMAIL_NO_DISCOUNT = """
Выберите подходящий срок аренды для продления⤵️
"""

MY_EMAIL = """
<b>Ваш почтовый ящик⤵️</b>
{email}

<i>Ожидаем письмо...</i>

⚠️ Срок жизни почтового ящика - <b>30 минут.</b>
"""

MY_RENT_EMAIL = """
<b>Ваш почтовый ящик⤵️</b>
{email}

<i>Ожидаем письмо...</i>

⚠️ Арендован до: <b>{expire_at}</b>
"""

CONFIRM_RENT_EMAIL = """
<b>Вы собираетесь арендовать почтовый ящик ⤵️</b>
{dialog_data[email]}

Срок: <b>{dialog_data[rent_text]}</b>
Стоимость: <b>{dialog_data[cost]}₽</b>
"""

CONFIRM_EXTEND_EMAIL = """
<b>Вы собираетесь продлить почтовый ящик:</b>
{email}

Срок: <b>{rent_text}</b>
Стоимость: <b>{cost}₽</b>
"""

RENT_EMAIL_SUCCESS = """
Почтовый ящик <b>{dialog_data[email]}</b> успешно арендован!
Срок: {dialog_data[rent_text]}
"""

EXTEND_EMAIL_SUCCESS = """
Вы успешно продлили почтовый ящик <b>{email}</b> на <b>{rent_text}</b>
"""

PAID_EMAIL_INFO = """
<b>Почтовый ящик:</b> {email}

Арендован до: <b>{expire_at}</b>
"""

CREATING_EMAIL = "<b>Создание почтового ящика...</b>"

PERSONAL_CABINET = """
<b>ID:</b> <code>{user_id}</code>

<b>Мой кошелек:</b> <code>{balance}₽</code>
<b>Мой партнерский счет:</b> <code>{ref_balance}₽</code>
"""

SELECT_DEPOSIT_PRICE = "Выберите сумму пополнения⤵️"
SELECT_DEPOSIT_METHOD = "Выберите способ пополнения⤵️"
SELECT_DEPOSIT_METHOD_ANYPAY = "Способы оплаты AnyPay⤵️"
ENTER_DEPOSIT_AMOUNT = "Введите сумму пополнения"
FOLLOW_THE_LINK_TO_PAY = "Перейдите по ссылке для оплаты:"
PAYMENT = "Оплата"

ERROR_PAYMENT_METHOD = 'Возникла ошибка, воспользуйтесь другим методом оплаты'

PAYMENT_INFO_MSG = """
<b>Оплата счета №{payment_id}</b>

<b>Сумма:</b> <code>{amount}₽</code>
<b>Способ оплаты:</b> <code>{method}</code>

<i>Для оплаты нажмите кнопку <b>"Оплатить"</b></i>
"""

PAYMENT_SUCCESS = """
<b>💰Баланс успешно пополнен на <code>{amount}₽</code></b>
"""

AFFILIATE_PROGRAM_TEXT = """
🤝<b>Партнёрская программа</b>

Приводи друзей и зарабатывай 10% с их пополнений, пожизненно!

⬇️<b>Твоя реферальная ссылка:</b>
└ {link}

🏅Статистика:
├ Лично приглашённых: <b>{ref_count}</b>
├ Количество оплат: <b>{payment_count}</b>
├ Повторные оплаты: <b>{repeat_payment_count}</b>
├ Всего заработано: <b>{ref_balance_total}₽</b>
└ Доступно к выводу: <b>{ref_balance}₽</b>
"""

SHARE_BOT_TEXT = """

Пользователь {mention} приглашает вас в сервис приема СМС и Email сообщений.
{link}"""

WITHDRAW_TEXT = """
Вы можете вывести средства в криптовалюте или на баланс бота для оплаты наших услуг.
"""
ENTER_WITHDRAW_AMOUNT = "Введите сумму вывода"
ENTER_WITHDRAW_CARD = "Отправьте реквизиты банковской карты"
MIN_CRYPT_AMOUNT = 350 # минимальная сумма вывода в криптовалюте

WITHDRAW_INFO = """
<b>Вывод средств</b>

<b>Сумма:</b> <code>{amount}₽</code>
<b>Реквизиты:</b> <code>{requisites}</code>

<i>Для подтверждения вывода нажмите кнопку <b>"Подтвердить"</b></i>
"""

ADMIN_STAT = """
<b>👥 Количество пользователей:</b> {users_count}
<b>За сегодня:</b> {users_count_today}

━━━━━━━━━━━━━━━━━━━━━━━━
<b>📩 Статистика Email:</b>
<b>Получено:</b> {received_email_count}
<b>За сегодня:</b> {received_email_count_today}
<b>Арендованных Email:</b> {rent_email_count}
<b>За сегодня:</b> {rent_email_count_today}

━━━━━━━━━━━━━━━━━━━━━━━━
<b>📲 Статистика SMS:</b>
<b>Всего SMS запрошено:</b> {rented_sms_total}
<b>За месяц:</b> {rented_sms_month}
<b>За сегодня:</b> {rented_sms_today}

<b>Доставлено SMS:</b> {delivered_sms_total}
<b>За месяц:</b> {delivered_sms_month}
<b>За сегодня:</b> {delivered_sms_today}

━━━━━━━━━━━━━━━━━━━━━━━━
<b>📞Аренда номеров:</b>
<b>Всего арендовано номеров:</b> {rented_number_total}
<b>За месяц:</b> {rented_number_month}
<b>За сегодня:</b> {rented_number_today}
<b>Повторно:</b> {repeat_purchases_total}

━━━━━━━━━━━━━━━━━━━━━━━━
<b>💳 Пополнения:</b>
<b>Всего:</b> {payments_count}
<b>Повторные оплаты:</b> {payments_repeat_count}
<b>За сегодня:</b> {payments_count_today} (<b>{payments_amount_today} руб.</b>)
<b>За {month_name}:</b> {payments_count_month} (<b>{payments_amount_month} руб.</b>)
<b>За {last_month_name}:</b> {payments_count_last_month} (<b>{payments_amount_last_month} руб.</b>)

━━━━━━━━━━━━━━━━━━━━━━━━
<b>⭐️ Статистика STARS:</b>
<b>За сегодня:</b> {stars_count_today} (<b>{stars_amount_today:.0f} руб.</b>)
<b>За {month_name}:</b> {stars_month_count} (<b>{stars_month_amount:.0f} руб.</b>)
<b>За {last_month_name}:</b> {stars_last_month_count} (<b>{stars_last_month_amount:.0f} руб.</b>)
"""

AFFILIATE_STAT = """
<b>Партнерская статистика:</b>

<code>{stat}</code>
"""

LOW_BALANCE_ALERT = """
⚠️Заканчивается баланс!

Успей пополнить в течение 24 часов и получи на счёт +10% от суммы пополнения ⤵️
"""

NOT_NUMBERS_ALERT = "Для данного сервиса нет доступных номеров. Попробуйте позже"

NUMBER_REQUEST_SENT = "Запрос на получение номера отправлен, пожалуйста ожидайте..."

PLEASE_WAIT_SECONDS = "Пожалуйста, подождите 5 секунд перед повторным запросом."

# Для продолжения подпишитесь на наш канал
SUBSCRIBE_CHANNEL = """
Для продолжения подпишитесь на наш канал
"""

# ========================= Buttons =========================

# Default
CONFIRM_BTN = '✅Подтвердить'
DECLINE_BTN = '❌Отклонить'
CONTINUE_BTN = '🔁Продолжить'
BACK_BTN = '« Назад'

# Start menu
RECEIVE_SMS_BTN = '📲Принять SMS'
RENT_NUMBER = '📞Длительная аренда'
RECEIVE_EMAIL_BTN = '📩Принять Email'
PERSONAL_CABINET_BTN = '👤Личный кабинет'
AFFILIATE_PROGRAM_BTN = '💰Партнерская программа'

# Country menu
SEARCH_COUNTRY_BTN = '🔎Поиск страны'
ENTER_AGAIN_BTN = 'Ввести заново'

# Service menu
SEARCH_SERVICE_BTN = '🔎Поиск сервиса'
OTHER_SERVICE_BTN = 'Другой сервис'
CANCEL_SERVICE_BTN = '❌Отменить аренду номера'
REQUEST_ANOTHER_CODE = '➕Принять SMS для другого сервиса'
RECEIVE_ANOTHER_SMS_TO_NUMBER = '📩Принять новое SMS на этот же номер'

# Personal cabinet
DEPOSIT_BTN = '💵Пополнить баланс'
INSTRUCTIONS = "📖 Инструкция"
LINK_TO_BUTTON = "https://telegra.ph/Rekomendacii-dlya-priema-SMS-11-14"
SUPPORT_BTN = '🙋‍♂️Поддержка'

# Receive email
CHANGE_EMAIL_BTN = '🔄Сменить почтовый ящик'
RENT_EMAIL_BTN = '📬Арендовать почтовый ящик'
MY_RENT_EMAILS_BTN = '📨Мои ящики'
EXTEND_THE_LEASE = 'Продлить аренду'

GET_FULL_MESSAGE = "Получить полный текст сообщения"

# Константы для сообщений об аренде номера
RENT_NEW_ROOM = "📞Арендовать новый номер"
RENT_NOT_FOUND_MSG = "Аренда не найдена."
RENT_ALREADY_CANCELED_MSG = "Аренда уже отменена."
RENT_CANCEL_SUCCESS_MSG = "Аренда успешно отменена."
RENT_CANCEL_FAILED_MSG = "Аренда отменена"
ERROR_NO_OPERATIONS_MSG = "Ошибка: операция уже завершена или не найдена."
ERROR_OCCURED_MSG = "Произошла ошибка при отмене аренды. Попробуйте позже."
RENTAL_CANCELED_OR_NOT_FOUND = "Невозможно продлить аренду: аренда отменена или не найдена."
FAILED_TO_GET_AVAILABLE_DAYS = "Не удалось получить доступные дни для продления аренды."
NOT_ENOUGH_FUNDS_FOR_RENT = "Недостаточно средств для автопродления аренды\nПополните баланс по кнопке⤵"
RENT_WEEK_EXPIRING = """⏳ Срок бесплатной аренды недели заканчивается.
Хотите продлить аренду? Выберите подходящий тариф ниже."""

# Аренда электронной почты
RENT_EMAIL_WEEK_BTN = 'Неделя, 0₽'
RENT_EMAIL_MONTH_BTN = 'Месяц, 199₽'
RENT_EMAIL_SIX_MONTHS_BTN = '6 месяцев, 599₽'
RENT_EMAIL_YEAR_BTN = 'Год, 999₽'

# Константы для данных аренды
RENT_EMAIL_WEEK = (0, 7, '1 неделя')
RENT_EMAIL_MONTH = (199, 30, '1 месяц')
RENT_EMAIL_SIX_MONTHS = (599, 183, '6 месяцев')
RENT_EMAIL_YEAR = (999, 365, '1 год')

# Аренда электронной почты со скидкой
RENT_EMAIL_WEEK_BTN_DISCOUNT = 'Неделя 0₽'
RENT_EMAIL_MONTH_BTN_DISCOUNT = 'Месяц 199₽ > 169₽ (-15%)'
RENT_EMAIL_SIX_MONTHS_BTN_DISCOUNT = '6 месяцев 599₽ > 459₽ (-23%)'
RENT_EMAIL_YEAR_BTN_DISCOUNT = 'Год 999₽ > 749₽ (-25%)'

# Константы для данных аренды с учетом скидок
RENT_EMAIL_WEEK_DISCOUNT = (0, 7, '1 неделя с учетом скидки')
RENT_EMAIL_MONTH_DISCOUNT = (169, 30, '1 месяц с учетом скидки')
RENT_EMAIL_SIX_MONTHS_DISCOUNT = (459, 183, '6 месяцев с учетом скидки')
RENT_EMAIL_YEAR_DISCOUNT = (749, 365, '1 год с учетом скидки')

# Словари аренды
RENT_DATA = {
    'rent_email_week': RENT_EMAIL_WEEK,
    'rent_email_month': RENT_EMAIL_MONTH,
    'rent_email_six_months': RENT_EMAIL_SIX_MONTHS,
    'rent_email_year': RENT_EMAIL_YEAR,
}

RENT_DATA_DISCOUNT = {
    'rent_email_week_discount': RENT_EMAIL_WEEK_DISCOUNT,
    'rent_email_month_discount': RENT_EMAIL_MONTH_DISCOUNT,
    'rent_email_six_months_discount': RENT_EMAIL_SIX_MONTHS_DISCOUNT,
    'rent_email_year_discount': RENT_EMAIL_YEAR_DISCOUNT,
}

# Personal cabinet
OTHER_DEPOSIT_PRICE_BTN = 'Другая сумма'

METHOD_STREAMPAY = 'Оплата переводом (от 300 руб)'
METHOD_CKASSA = 'Банковская карта'
METHOD_YOOMONEY = 'Юmoney'
METHOD_LAVA = 'СБП (от 2000 руб)'
METHOD_ANYPAY = 'Оплата переводом (от 1000 руб)'
METHOD_STARS_BTN = 'Telegram Stars'
METHOD_CRYPTO_BTN = 'Криптовалюта'
METHOD_OTHER_BTN = 'Другие способы'

METHOD_BANK_CARD = 'Банковская карта'
METHOD_BANK_SBP = 'СБП'
METHOD_BANK_CRYPTOCURRENCY = 'Криптовалюта'

PAY_BTN = 'Оплатить'

# Affiliate program
SHARE_LINK_BTN = 'Поделиться ссылкой'
WITHDRAW_BTN = 'Вывод средств'

ON_BANK_CARD_BTN = 'На банковскую карту'
ON_CRYPTOCURRENCY_BTN = 'Криптовалюта'
ON_BALANCE_BTN = 'На баланс бота'

# My emails
RECEIVE_MY_EMAIL_BTN = '✉️Принять Email'
EXTEND_EMAIL_BTN = '📬Продлить аренду'

# Subscribe channel
SUBSCRIBE_CHANNEL_BTN = '↗️Перейти и подписаться'
READY_SUBSCRIBE_CHANNEL_BTN = '✅Я подписался'

# ========================= Data =========================
prices_data = [
    {'id': 1, 'price': 300},
    {'id': 2, 'price': 500},
    {'id': 3, 'price': 1000},
    {'id': 4, 'price': 5000}
]

CHANNEL_LINK = 'https://t.me/neuronbo'

# процент, который накидывает сервис
INTEREST = 1.5

DOLLAR_ONLINESIM = 78 * 1.5

DOLLAR_SMS_ACTIVATE = 100 * 1.5

# Словарь для перевода сокращений из названия сервисов в таблице services в названия сервисов таблицы onlinesim
SERVICES_TRANSLATION = {
    "tg": "telegram",
    "vk": "vkcom",
}

SERVICE_ONLINESIM = ['LinkedIn', 'Uber', 'Twitter|X', 'GroupMe', 'WeChat', 'Coinbase', 'Bumble', 'Instagram',
                     'Facebook', 'Airbnb', 'Bitstamp', 'Huobi Global', 'Binance', 'Google (Youtube, Gmail)',
                     'LINE', 'ICQ', 'HQ Trivia', 'Discord', 'TanTan', 'Jiayuan', 'WhatsApp', 'Tinder', 'ДругВокруг',
                     'Telegram', 'Дром', 'lino_network', 'Viber', 'Apple', 'MeetMe', 'Yalla', 'Одноклассники',
                     'Crypto.com', 'ChatGPT | OpenAI', 'ВКонтакте + Mail.ru', 'Рамблер', 'Yahoo', 'Amazon', 'Яндекс',
                     'AOL', 'QQ', 'Hinge', 'NAVER', 'Kucoin', 'KakaoTalk', 'Microsoft', 'Мамба', 'Bolt', 'LiveScore',
                     'eBay|Kleinanzeigen.', 'Seosprint', 'taxiMaxim', 'Steam', 'Gett', 'Gemini.com', 'Юла', 'OLX',
                     'ftx.com', 'Happn']

# SMSActivate
SMS_ACTIVATE_SERVICE_CODES_AT_ONLINESIM = ["ot", "ts"] # "ot" - Любой другой  "ts" - PayPal


# возвращает первый ключ, соответствующий значению
REVERSE_SERVICES_TRANSLATION = {v: k for k, v in SERVICES_TRANSLATION.items()}
key = REVERSE_SERVICES_TRANSLATION.get("telegram")


country_flags = {
    "Россия": "\U0001F1F7\U0001F1FA",  # 🇷🇺
    "Украина": "\U0001F1FA\U0001F1E6",  # 🇺🇦
    "Казахстан": "\U0001F1F0\U0001F1FF",  # 🇰🇿
    "Китай": "\U0001F1E8\U0001F1F3",  # 🇨🇳
    "Филиппины": "\U0001F1F5\U0001F1ED",  # 🇵🇭
    "Мьянма": "\U0001F1F2\U0001F1F2",  # 🇲🇲
    "Индонезия": "\U0001F1EE\U0001F1E9",  # 🇮🇩
    "Малайзия": "\U0001F1F2\U0001F1FE",  # 🇲🇾
    "Кения": "\U0001F1F0\U0001F1EA",  # 🇰🇪
    "Танзания": "\U0001F1F9\U0001F1FF",  # 🇹🇿
    "Вьетнам": "\U0001F1FB\U0001F1F3",  # 🇻🇳
    "Кыргызстан": "\U0001F1F0\U0001F1EC",  # 🇰🇬
    "США (виртуальные)": "\U0001F1FA\U0001F1F8",  # 🇺🇸
    "Израиль": "\U0001F1EE\U0001F1F1",  # 🇮🇱
    "Гонконг": "\U0001F1ED\U0001F1F0",  # 🇭🇰
    "Польша": "\U0001F1F5\U0001F1F1",  # 🇵🇱
    "Англия": "\U0001F1EC\U0001F1E7",  # 🇬🇧
    "Мадагаскар": "\U0001F1F2\U0001F1EC",  # 🇲🇬
    "Дем. Конго": "\U0001F1E8\U0001F1E9",  # 🇨🇩
    "Нигерия": "\U0001F1F3\U0001F1EC",  # 🇳🇬
    "Макао": "\U0001F1F2\U0001F1F4",  # 🇲🇴
    "Египет": "\U0001F1EA\U0001F1EC",  # 🇪🇬
    "Индия": "\U0001F1EE\U0001F1F3",  # 🇮🇳
    "Ирландия": "\U0001F1EE\U0001F1EA",  # 🇮🇪
    "Камбоджа": "\U0001F1F0\U0001F1ED",  # 🇰🇭
    "Лаос": "\U0001F1F1\U0001F1E6",  # 🇱🇦
    "Гаити": "\U0001F1ED\U0001F1F9",  # 🇭🇹
    "Кот д'Ивуар": "\U0001F1E8\U0001F1EE",  # 🇨🇮
    "Гамбия": "\U0001F1EC\U0001F1F2",  # 🇬🇲
    "Сербия": "\U0001F1F7\U0001F1F8",  # 🇷🇸
    "Йемен": "\U0001F1FE\U0001F1EA",  # 🇾🇪
    "ЮАР": "\U0001F1FF\U0001F1E6",  # 🇿🇦
    "Румыния": "\U0001F1F7\U0001F1F4",  # 🇷🇴
    "Колумбия": "\U0001F1E8\U0001F1F4",  # 🇨🇴
    "Эстония": "\U0001F1EA\U0001F1EA",  # 🇪🇪
    "Азербайджан": "\U0001F1E6\U0001F1FF",  # 🇦🇿
    "Канада": "\U0001F1E8\U0001F1E6",  # 🇨🇦
    "Марокко": "\U0001F1F2\U0001F1E6",  # 🇲🇦
    "Гана": "\U0001F1EC\U0001F1ED",  # 🇬🇭
    "Аргентина": "\U0001F1E6\U0001F1F7",  # 🇦🇷
    "Узбекистан": "\U0001F1FA\U0001F1FF",  # 🇺🇿
    "Камерун": "\U0001F1E8\U0001F1F2",  # 🇨🇲
    "Чад": "\U0001F1F9\U0001F1E9",  # 🇹🇩
    "Германия": "\U0001F1E9\U0001F1EA",  # 🇩🇪
    "Литва": "\U0001F1F1\U0001F1F9",  # 🇱🇹
    "Хорватия": "\U0001F1ED\U0001F1F7",  # 🇭🇷
    "Швеция": "\U0001F1F8\U0001F1EA",  # 🇸🇪
    "Ирак": "\U0001F1EE\U0001F1F6",  # 🇮🇶
    "Нидерланды": "\U0001F1F3\U0001F1F1",  # 🇳🇱
    "Латвия": "\U0001F1F1\U0001F1FB",  # 🇱🇻
    "Австрия": "\U0001F1E6\U0001F1F9",  # 🇦🇹
    "Беларусь": "\U0001F1E7\U0001F1FE",  # 🇧🇾
    "Таиланд": "\U0001F1F9\U0001F1ED",  # 🇹🇭
    "Сауд. Аравия": "\U0001F1F8\U0001F1E6",  # 🇸🇦
    "Мексика": "\U0001F1F2\U0001F1FD",  # 🇲🇽
    "Тайвань": "\U0001F1F9\U0001F1FC",  # 🇹🇼
    "Испания": "\U0001F1EA\U0001F1F8",  # 🇪🇸
    "Иран": "\U0001F1EE\U0001F1F7",  # 🇮🇷
    "Алжир": "\U0001F1E9\U0001F1FF",  # 🇩🇿
    "Словения": "\U0001F1F8\U0001F1EE",  # 🇸🇮
    "Бангладеш": "\U0001F1E7\U0001F1E9",  # 🇧🇩
    "Сенегал": "\U0001F1F8\U0001F1F3",  # 🇸🇳
    "Турция": "\U0001F1F9\U0001F1F7",  # 🇹🇷
    "Чехия": "\U0001F1E8\U0001F1FF",  # 🇨🇿
    "Шри-Ланка": "\U0001F1F1\U0001F1F0",  # 🇱🇰
    "Перу": "\U0001F1F5\U0001F1EA",  # 🇵🇪
    "Пакистан": "\U0001F1F5\U0001F1F0",  # 🇵🇰
    "Новая Зеландия": "\U0001F1F3\U0001F1FF",  # 🇳🇿
    "Гвинея": "\U0001F1EC\U0001F1F3",  # 🇬🇳
    "Мали": "\U0001F1F2\U0001F1F1",  # 🇲🇱
    "Венесуэла": "\U0001F1FB\U0001F1EA",  # 🇻🇪
    "Эфиопия": "\U0001F1EA\U0001F1F9",  # 🇪🇹
    "Монголия": "\U0001F1F2\U0001F1F3",  # 🇲🇳
    "Бразилия": "\U0001F1E7\U0001F1F7",  # 🇧🇷
    "Афганистан": "\U0001F1E6\U0001F1EB",  # 🇦🇫
    "Уганда": "\U0001F1FA\U0001F1EC",  # 🇺🇬
    "Ангола": "\U0001F1E6\U0001F1F4",  # 🇦🇴
    "Кипр": "\U0001F1E8\U0001F1FE",  # 🇨🇾
    "Франция": "\U0001F1EB\U0001F1F7",  # 🇫🇷
    "Папуа-Новая Гвинея": "\U0001F1F5\U0001F1EC",  # 🇵🇬
    "Мозамбик": "\U0001F1F2\U0001F1FF",  # 🇲🇿
    "Непал": "\U0001F1F3\U0001F1F5",  # 🇳🇵
    "Бельгия": "\U0001F1E7\U0001F1EA",  # 🇧🇪
    "Болгария": "\U0001F1E7\U0001F1EC",  # 🇧🇬
    "Венгрия": "\U0001F1ED\U0001F1FA",  # 🇭🇺
    "Молдова": "\U0001F1F2\U0001F1E9",  # 🇲🇩
    "Италия": "\U0001F1EE\U0001F1F9",  # 🇮🇹
    "Парагвай": "\U0001F1F5\U0001F1FE",  # 🇵🇾
    "Гондурас": "\U0001F1ED\U0001F1F3",  # 🇭🇳
    "Тунис": "\U0001F1F9\U0001F1F3",  # 🇹🇳
    "Никарагуа": "\U0001F1F3\U0001F1EE",  # 🇳🇮
    "Тимор-Лесте": "\U0001F1F9\U0001F1F1",  # 🇹🇱
    "Боливия": "\U0001F1E7\U0001F1F4",  # 🇧🇴
    "Коста Рика": "\U0001F1E8\U0001F1F7",  # 🇨🇷
    "Гватемала": "\U0001F1EC\U0001F1F9",  # 🇬🇹
    "ОАЭ": "\U0001F1E6\U0001F1EA",  # 🇦🇪
    "Зимбабве": "\U0001F1FF\U0001F1FC",  # 🇿🇼
    "Пуэрто-Рико": "\U0001F1F5\U0001F1F7",  # 🇵🇷
    "Судан": "\U0001F1F8\U0001F1E9",  # 🇸🇩
    "Того": "\U0001F1F9\U0001F1EC",  # 🇹🇬
    "Кувейт": "\U0001F1F0\U0001F1FC",  # 🇰🇼
    "Сальвадор": "\U0001F1F8\U0001F1FB",  # 🇸🇻
    "Ливия": "\U0001F1F1\U0001F1FE",  # 🇱🇾
    "Ямайка": "\U0001F1EF\U0001F1F2",  # 🇯🇲
    "Тринидад и Тобаго": "\U0001F1F9\U0001F1F9",  # 🇹🇹
    "Эквадор": "\U0001F1EA\U0001F1E8",  # 🇪🇨
    "Свазиленд": "\U0001F1F8\U0001F1FF",  # 🇸🇿
    "Оман": "\U0001F1F4\U0001F1F2",  # 🇴🇲
    "Босния и Герцеговина": "\U0001F1E7\U0001F1E6",  # 🇧🇦
    "Доминиканская Республика": "\U0001F1E9\U0001F1F4",  # 🇩🇴
    "Сирия": "\U0001F1F8\U0001F1FE",  # 🇸🇾
    "Катар": "\U0001F1F6\U0001F1E6",  # 🇶🇦
    "Панама": "\U0001F1F5\U0001F1E6",  # 🇵🇦
    "Куба": "\U0001F1E8\U0001F1FA",  # 🇨🇺
    "Мавритания": "\U0001F1F2\U0001F1F7",  # 🇲🇷
    "Сьерра-Леоне": "\U0001F1F8\U0001F1F1",  # 🇸🇱
    "Иордания": "\U0001F1EF\U0001F1F4",  # 🇯🇴
    "Португалия": "\U0001F1F5\U0001F1F9",  # 🇵🇹
    "Барбадос": "\U0001F1E7\U0001F1E7",  # 🇧🇧
    "Бурунди": "\U0001F1E7\U0001F1EE",  # 🇧🇮
    "Бенин": "\U0001F1E7\U0001F1EF",  # 🇧🇯
    "Бруней": "\U0001F1E7\U0001F1F3",  # 🇧🇳
    "Багамы": "\U0001F1E7\U0001F1F8",  # 🇧🇸
    "Ботсвана": "\U0001F1E7\U0001F1FC",  # 🇧🇼
    "Белиз": "\U0001F1E7\U0001F1FF",  # 🇧🇿
    "ЦАР": "\U0001F1E8\U0001F1EB",  # 🇨🇫
    "Доминика": "\U0001F1E9\U0001F1F2",  # 🇩🇲
    "Гренада": "\U0001F1EC\U0001F1E9",  # 🇬🇩
    "Грузия": "\U0001F1EC\U0001F1EA",  # 🇬🇪
    "Греция": "\U0001F1EC\U0001F1F7",  # 🇬🇷
    "Гвинея-Бисау": "\U0001F1EC\U0001F1FC",  # 🇬🇼
    "Гайана": "\U0001F1EC\U0001F1FE",  # 🇬🇾
    "Исландия": "\U0001F1EE\U0001F1F8",  # 🇮🇸
    "Коморы": "\U0001F1F0\U0001F1F2",  # 🇰🇲
    "Сент-Китс и Невис": "\U0001F1F0\U0001F1F3",  # 🇰🇳
    "Либерия": "\U0001F1F1\U0001F1F7",  # 🇱🇷
    "Лесото": "\U0001F1F1\U0001F1F8",  # 🇱🇸
    "Малави": "\U0001F1F2\U0001F1FC",  # 🇲🇼
    "Намибия": "\U0001F1F3\U0001F1E6",  # 🇳🇦
    "Нигер": "\U0001F1F3\U0001F1EA",  # 🇳🇪
    "Руанда": "\U0001F1F7\U0001F1FC",  # 🇷🇼
    "Словакия": "\U0001F1F8\U0001F1F0",  # 🇸🇰
    "Суринам": "\U0001F1F8\U0001F1F7",  # 🇸🇷
    "Таджикистан": "\U0001F1F9\U0001F1EF",  # 🇹🇯
    "Монако": "\U0001F1F2\U0001F1E8",  # 🇲🇨
    "Бахрейн": "\U0001F1E7\U0001F1ED",  # 🇧🇭
    "Реюньон": "\U0001F1F7\U0001F1EA",  # 🇷🇪
    "Замбия": "\U0001F1FF\U0001F1F2",  # 🇿🇲
    "Армения": "\U0001F1E6\U0001F1F2",  # 🇦🇲
    "Сомали": "\U0001F1F8\U0001F1F4",  # 🇸🇴
    "Конго": "\U0001F1E8\U0001F1EC",  # 🇨🇬
    "Чили": "\U0001F1E8\U0001F1F1",  # 🇨🇱
    "Буркина-Фасо": "\U0001F1E7\U0001F1EB",  # 🇧🇫
    "Ливан": "\U0001F1F1\U0001F1E7",  # 🇱🇧
    "Габон": "\U0001F1EC\U0001F1E6",  # 🇬🇦
    "Албания": "\U0001F1E6\U0001F1F1",  # 🇦🇱
    "Уругвай": "\U0001F1FA\U0001F1FE",  # 🇺🇾
    "Маврикий": "\U0001F1F2\U0001F1FA",  # 🇲🇺
    "Бутан": "\U0001F1E7\U0001F1F9",  # 🇧🇹
    "Мальдивы": "\U0001F1F2\U0001F1FB",  # 🇲🇻
    "Гваделупа": "\U0001F1EC\U0001F1F5",  # 🇬🇵
    "Туркменистан": "\U0001F1F9\U0001F1F2",  # 🇹🇲
    "Французская Гвиана": "\U0001F1EC\U0001F1EB",  # 🇬🇫
    "Финляндия": "\U0001F1EB\U0001F1EE",  # 🇫🇮
    "Сент-Люсия": "\U0001F1F1\U0001F1E8",  # 🇱🇨
    "Люксембург": "\U0001F1F1\U0001F1FA",  # 🇱🇺
    "Сент-Винсент и Гренадины": "\U0001F1FB\U0001F1E8",  # 🇻🇨
    "Экваториальная Гвинея": "\U0001F1EC\U0001F1F6",  # 🇬🇶
    "Джибути": "\U0001F1E9\U0001F1EF",  # 🇩🇯
    "Антигуа и Барбуда": "\U0001F1E6\U0001F1EC",  # 🇦🇬
    "Острова Кайман": "\U0001F1F0\U0001F1FE",  # 🇰🇾
    "Черногория": "\U0001F1F2\U0001F1EA",  # 🇲🇪
    "Дания": "\U0001F1E9\U0001F1F0",  # 🇩🇰
    "Швейцария": "\U0001F1E8\U0001F1ED",  # 🇨🇭
    "Норвегия": "\U0001F1F3\U0001F1F4",  # 🇳🇴
    "Австралия": "\U0001F1E6\U0001F1FA",  # 🇦🇺
    "Эритрея": "\U0001F1EA\U0001F1F7",  # 🇪🇷
    "Южный Судан": "\U0001F1F8\U0001F1F8",  # 🇸🇸
    "Сан-Томе и Принсипи": "\U0001F1F8\U0001F1F9",  # 🇸🇹
    "Аруба": "\U0001F1E6\U0001F1FC",  # 🇦🇼
    "Монтсеррат": "\U0001F1F2\U0001F1F8",  # 🇲🇸
    "Ангилья": "\U0001F1E6\U0001F1EE",  # 🇦🇮
    "Япония": "\U0001F1EF\U0001F1F5",  # 🇯🇵
    "Северная Македония": "\U0001F1F2\U0001F1F0",  # 🇲🇰
    "Республика Сейшелы": "\U0001F1F8\U0001F1E8",  # 🇸🇨
    "Новая Каледония": "\U0001F1F3\U0001F1E8",  # 🇳🇨
    "Кабо-Верде": "\U0001F1E8\U0001F1FB",  # 🇨🇻
    "США": "\U0001F1FA\U0001F1F8",  # 🇺🇸
    "Палестина": "\U0001F1F5\U0001F1F8",  # 🇵🇸
    "Фиджи": "\U0001F1EB\U0001F1EF",  # 🇫🇯
    "Южная Корея": "\U0001F1F0\U0001F1F7",  # 🇰🇷
    "Северная Корея": "\U0001F1F0\U0001F1F5",  # 🇰🇵
    "Западная Сахара": "\U0001F1EA\U0001F1ED",  # 🇪🇭
    "Соломоновы острова": "\U0001F1F8\U0001F1E7",  # 🇸🇧
    "Джерси": "\U0001F1EF\U0001F1EA",  # 🇯🇪
    "Бермуды": "\U0001F1E7\U0001F1F2",  # 🇧🇲
    "Сингапур": "\U0001F1F8\U0001F1EC",  # 🇸🇬
    "Тонга": "\U0001F1F9\U0001F1F4",  # 🇹🇴
    "Самоа": "\U0001F1FC\U0001F1F8",  # 🇼🇸
    "Мальта": "\U0001F1F2\U0001F1F9",  # 🇲🇹
    "Лихтенштейн": "\U0001F1F1\U0001F1EE",  # 🇱🇮
    "Гибралтар": "\U0001F1EC\U0001F1EE",  # 🇬🇮
    "Фарерские острова": "\U0001F1EB\U0001F1F4",  # 🇫🇴
    "Косово": "\U0001F1FD\U0001F1F0"  # 🇽🇰
}

sort_countries = {
    # первыми
    33: "Колумбия",
    151: "Чили",
    43: "Германия",
    0: "Россия",
    187: "США",
    16: "Англия",
    73: "Бразилия",
    7: "Малайзия",
    6: "Индонезия",
    4: "Филиппины",

    # Европейские страны
    1: "Украина",
    15: "Польша",
    23: "Ирландия",
    29: "Сербия",
    32: "Румыния",
    34: "Эстония",
    44: "Литва",
    45: "Хорватия",
    46: "Швеция",
    48: "Нидерланды",
    49: "Латвия",
    50: "Австрия",
    51: "Беларусь",
    56: "Испания",
    59: "Словения",
    63: "Чехия",
    77: "Кипр",
    78: "Франция",
    82: "Бельгия",
    83: "Болгария",
    84: "Венгрия",
    85: "Молдова",
    86: "Италия",
    108: "Босния и Герцеговина",
    117: "Португалия",
    129: "Греция",
    132: "Исландия",
    141: "Словакия",
    144: "Монако",
    163: "Финляндия",
    165: "Люксембург",
    171: "Черногория",
    172: "Дания",
    173: "Швейцария",
    174: "Норвегия",
    183: "Северная Македония",
    199: "Мальта",
    200: "Лихтенштейн",
    203: "Косово",

    # Остальные страны (сортировка по популярности/значимости)
    2: "Казахстан",
    3: "Китай",
    182: "Япония",
    22: "Индия",
    36: "Канада",
    175: "Австралия",
    190: "Южная Корея",
    196: "Сингапур",
    13: "Израиль",
    62: "Турция",
    35: "Азербайджан",
    40: "Узбекистан",
    11: "Кыргызстан",
    143: "Таджикистан",
    161: "Туркменистан",
    148: "Армения",
    128: "Грузия",
    57: "Иран",
    47: "Ирак",
    110: "Сирия",
    188: "Палестина",
    53: "Сауд. Аравия",
    95: "ОАЭ",
    100: "Кувейт",
    111: "Катар",
    145: "Бахрейн",
    107: "Оман",
    30: "Йемен",
    153: "Ливан",
    116: "Иордания",
    5: "Мьянма",
    10: "Вьетнам",
    14: "Гонконг",
    20: "Макао",
    24: "Камбоджа",
    25: "Лаос",
    52: "Таиланд",
    55: "Тайвань",
    60: "Бангладеш",
    64: "Шри-Ланка",
    66: "Пакистан",
    72: "Монголия",
    74: "Афганистан",
    81: "Непал",
    121: "Бруней",
    158: "Бутан",
    159: "Мальдивы",
    191: "Северная Корея",

    # Америка
    12: "США (виртуальные)",
    26: "Гаити",
    39: "Аргентина",
    54: "Мексика",
    65: "Перу",
    70: "Венесуэла",
    87: "Парагвай",
    88: "Гондурас",
    90: "Никарагуа",
    92: "Боливия",
    93: "Коста Рика",
    94: "Гватемала",
    97: "Пуэрто-Рико",
    101: "Сальвадор",
    103: "Ямайка",
    104: "Тринидад и Тобаго",
    105: "Эквадор",
    109: "Доминиканская Республика",
    112: "Панама",
    113: "Куба",
    118: "Барбадос",
    122: "Багамы",
    124: "Белиз",
    126: "Доминика",
    127: "Гренада",
    131: "Гайана",
    134: "Сент-Китс и Невис",
    142: "Суринам",
    156: "Уругвай",
    160: "Гваделупа",
    162: "Французская Гвиана",
    164: "Сент-Люсия",
    166: "Сент-Винсент и Гренадин",
    169: "Антигуа и Барбуда",
    170: "Острова Кайман",
    179: "Аруба",
    180: "Монтсеррат",
    181: "Ангилья",

    # Африканские страны
    8: "Кения",
    9: "Танзания",
    17: "Мадагаскар",
    18: "Дем. Конго",
    19: "Нигерия",
    21: "Египет",
    27: "Кот д'Ивуар",
    28: "Гамбия",
    31: "ЮАР",
    37: "Марокко",
    38: "Гана",
    41: "Камерун",
    42: "Чад",
    58: "Алжир",
    61: "Сенегал",
    68: "Гвинея",
    69: "Мали",
    71: "Эфиопия",
    75: "Уганда",
    76: "Ангола",
    80: "Мозамбик",
    89: "Тунис",
    96: "Зимбабве",
    98: "Судан",
    99: "Того",
    102: "Ливия",
    106: "Свазиленд",
    114: "Мавритания",
    115: "Сьерра-Леоне",
    119: "Бурунди",
    120: "Бенин",
    123: "Ботсвана",
    125: "ЦАР",
    130: "Гвинея-Бисау",
    133: "Коморы",
    135: "Либерия",
    136: "Лесото",
    137: "Малави",
    138: "Намибия",
    139: "Нигер",
    140: "Руанда",
    147: "Замбия",
    149: "Сомали",
    150: "Конго",
    152: "Буркина-Фасо",
    154: "Габон",
    167: "Экваториальная Гвинея",
    168: "Джибути",
    176: "Эритрея",
    177: "Южный Судан",
    178: "Сан-Томе и Принсипи",
    184: "Республика Сейшелы",
    186: "Кабо-Верде",
    192: "Западная Сахара",

    # Океания и прочие территории
    67: "Новая Зеландия",
    79: "Папуа-Новая Гвинея",
    91: "Тимор-Лесте",
    146: "Реюньон",
    157: "Маврикий",
    185: "Новая Каледония",
    189: "Фиджи",
    193: "Соломоновы острова",
    194: "Джерси",
    195: "Бермуды",
    197: "Тонга",
    198: "Самоа",
    201: "Гибралтар",
    202: "Фарерские острова"
}


list_for_sorting_countries_for_telegram = [
    "Эстония", "Россия", "Молдова", "Англия", "Швеция", "Сербия",
    "Германия", "Латвия", "США", "Италия", "Чехия", "Румыния", "Польша",
    "Нидерланды", "Испания", "Индия", "Ирландия", "Литва", "Канада",
    "Колумбия", "Узбекистан", "Хорватия", "Болгария", "Кот д'Ивуар",
    "Северная Македония", "Япония", "Кения", "Сьерра-Леоне", "Греция", "Марокко"
]

app\services\freekassa.py
from app import dependencies


def generate_fk_link(amount: float, order_id: int, method_id: int = None):
    currency = 'RUB'
    sign = hashlib.md5(f'{dependencies.FK_SHOP_ID}:{amount}:{dependencies.FK_SECRET_KEY}:{currency}:{order_id}'.encode()).hexdigest()
    url = f'https://pay.freekassa.com/?m={dependencies.FK_SHOP_ID}&oa={amount}&currency={currency}&o={order_id}&s={sign}'
    if method_id:
        url += f'&i={method_id}'
    return url


import requests
import datetime
import hashlib
import hmac
from collections import OrderedDict

class FreekassaError(ValueError):
    pass


class FreekassaAuthError(FreekassaError):
    pass


class FreekassaNotificationError(FreekassaError):
    pass



ORDER_STATUSES = {
    0: 'Новый',
    1: 'Оплачен',
    8: 'Ошибка',
    9: 'Отмена'
}


def get_order_label(order_status):
    if order_status in ORDER_STATUSES:
        return ORDER_STATUSES.get(order_status)
    return 'Неизвестный статус'


class Freekassa:
    API_URL = 'https://api.freekassa.ru/v1/'
    API_BALANCE_ROUTE = 'balance'
    API_ORDERS_ROUTE = 'orders'
    API_ORDERS_CREATE_ROUTE = 'orders/create'
    API_WITHDRAWALS_ROUTE = 'withdrawals'
    API_WITHDRAWALS_CURRENCIES_ROUTE = 'withdrawals/currencies'
    API_WITHDRAWALS_CREATE_ROUTE = 'withdrawals/create'
    API_CURRENCIES_ROUTE = 'currencies'
    API_CURRENCIES_STATUS_ROUTE = 'currencies/%id%/status'
    API_SHOPS_ROUTE = 'shops'

    _api_key = ''
    _shop_id = 0
    _nonce = 0

    def __init__(self, api_key, shop_id):
        self._api_key = api_key
        self._shop_id = shop_id
        self._set_nonce()

    def _set_nonce(self):
        self._nonce = int(datetime.datetime.now().timestamp())

    def _get_url(self, route, **kwargs):
        url = f'{self.API_URL}{route}'
        for key, value in kwargs:
            url = url.replace(f'%{key}%', value)
        return url

    def _get_data(self, additional_fields=dict):
        data = OrderedDict({'shopId': self._shop_id, 'nonce': self._nonce})
        data.update(additional_fields)
        data.update({'signature': self._get_signature(data=data)})
        return data

    def _get_signature(self, data):
        cdata = dict(data)
        if 'amount' in cdata:
            amount = cdata['amount']
            _ = f"{round(amount % 1, 2)}"[1:4] if amount % 1 > 0 else ''
            cdata['amount'] = f"{int(amount)}{_}"
        msg = '|'.join([str(cdata.get(key)) for key in sorted(cdata.keys())])
        hash_object = hmac.new(
            key=self._api_key.encode(),
            msg=msg.encode(),
            digestmod=hashlib.sha256
        )
        return hash_object.hexdigest()

    def _request(self, route, additional_fields=None, **kwargs):
        self._set_nonce()
        if additional_fields is None:
            additional_fields = {}
        response = requests.post(url=self._get_url(route, **kwargs), json=self._get_data(additional_fields))
        message = 'No message'
        if 'msg' in response.json():
            message = response.json().get('msg')
        if 'message' in response.json():
            message = response.json().get('message')
        if 'error' in response.json():
            message = response.json().get('error')
        if response.status_code == 400:
            raise FreekassaError(message)
        if response.status_code == 401:
            raise FreekassaAuthError(message)
        return response.json()

    @staticmethod
    def _get_time_str(dt: datetime.datetime):
        return dt.strftime('%Y-%m-%d %H:%M:%S')

    def get_balance(self):
        return self._request(self.API_BALANCE_ROUTE)

    def get_orders(self, order_id: int = None, payment_id: str = None, order_status: int = None,
                   date_from: datetime.datetime = None, date_to: datetime.datetime = None, page: int = None):
        additional_fields = {}
        if order_id:
            additional_fields['orderId'] = order_id
        if payment_id:
            additional_fields['paymentId'] = payment_id
        if order_status:
            additional_fields['orderStatus'] = order_status
        if date_from:
            additional_fields['dateFrom'] = self._get_time_str(date_from)
        if date_to:
            additional_fields['dateFrom'] = self._get_time_str(date_to)
        if page:
            additional_fields['page'] = page
        return self._request(self.API_ORDERS_ROUTE, additional_fields=additional_fields)

    def create_order(self, payment_system_id: int, email: str, ip: str, amount: float, currency_code: str = 'RUB',
                     payment_id: str = None, tel: str = None, success_url: str = None, failure_url: str = None,
                     notification_url: str = None):
        additional_fields = {'i': payment_system_id, 'email': email, 'ip': ip, 'amount': amount,
                             'currency': currency_code}
        if payment_id:
            additional_fields['paymentId'] = payment_id
        if tel:
            additional_fields['tel'] = tel
        if success_url:
            additional_fields['success_url '] = success_url
        if failure_url:
            additional_fields['failure_url'] = failure_url
        if notification_url:
            additional_fields['notification_url'] = notification_url
        return self._request(self.API_ORDERS_CREATE_ROUTE, additional_fields=additional_fields)

    def get_withdrawals(self, order_id: int = None, payment_id: str = None, order_status: int = None,
                        date_from: datetime.datetime = None, date_to: datetime.datetime = None, page: int = None):
        additional_fields = {}
        if order_id:
            additional_fields['orderId'] = order_id
        if payment_id:
            additional_fields['paymentId'] = payment_id
        if order_status:
            additional_fields['orderStatus'] = order_status
        if date_from:
            additional_fields['dateFrom'] = self._get_time_str(date_from)
        if date_to:
            additional_fields['dateFrom'] = self._get_time_str(date_to)
        if page:
            additional_fields['page'] = page
        return self._request(self.API_WITHDRAWALS_ROUTE, additional_fields=additional_fields)

    def create_withdrawal(self, payment_system_id: int, account: str, amount: float,
                          currency_code: str = 'RUB',
                          payment_id: str = None):
        additional_fields = {'i': payment_system_id, 'account': account, 'amount': amount, 'currency': currency_code}
        if payment_id:
            additional_fields['paymentId'] = payment_id
        return self._request(self.API_WITHDRAWALS_CREATE_ROUTE, additional_fields=additional_fields)

    def get_payment_systems(self):
        return self._request(self.API_CURRENCIES_ROUTE)

    def check_payment_system(self, payment_system_id):
        return self._request(self.API_CURRENCIES_STATUS_ROUTE, id=payment_system_id)

    def get_payment_systems_for_withdrawal(self):
        return self._request(self.API_WITHDRAWALS_CURRENCIES_ROUTE)

    def get_shops(self):
        return self._request(self.API_SHOPS_ROUTE)


app\services\info.py
def info():
    import inspect
    frame = inspect.currentframe().f_back
    locals_snapshot = frame.f_locals  # Получаем локальные переменные
    func_name = frame.f_code.co_name  # Имя вызывающей функции

    print(f"Функция {func_name}:\n")
    for name, value in locals_snapshot.items():
        (print(f"{name} = {value}\n"))

app\services\keyboards.py
from aiogram import types
from aiogram.types import ReplyKeyboardMarkup, KeyboardButton
from aiogram.utils.keyboard import ReplyKeyboardBuilder, InlineKeyboardBuilder

from app.services import bot_texts as bt


def start_kb():
    builder = ReplyKeyboardBuilder()

    builder.row(
        KeyboardButton(text=bt.RECEIVE_SMS_BTN)
    )
    builder.add(
        KeyboardButton(text=bt.RENT_NUMBER)
    )
    builder.row(
        KeyboardButton(text=bt.RECEIVE_EMAIL_BTN)
    )
    builder.add(
        KeyboardButton(text=bt.PERSONAL_CABINET_BTN),
    )
    # builder.row(
    #     KeyboardButton(text=bt.AFFILIATE_PROGRAM_BTN)
    # )

    return builder.as_markup(resize_keyboard=True, is_persistent=False)


def payment_kb(url: str):
    builder = InlineKeyboardBuilder()
    builder.button(
        text=bt.PAY_BTN,
        web_app=types.WebAppInfo(url=url)
    )
    return builder.as_markup()


app\services\lava.py
import hmac
import json
import hashlib
import aiohttp

from app import dependencies


class LavaApi:
    def __init__(self):
        self.SHOP_ID = dependencies.LAVA_SHOP_ID
        self.SECRET_KEY = dependencies.LAVA_SECRET_KEY
        self.url = 'https://api.lava.ru/business/invoice/{endpoint}'

    @staticmethod
    def sort_dict(data: dict):
        sorted_tuple = sorted(data.items(), key=lambda x: x[0])
        return dict(sorted_tuple)

    def get_sign(self, data: dict):
        json_str = json.dumps(data).encode()
        return hmac.new(bytes(self.SECRET_KEY, 'UTF-8'), json_str, hashlib.sha256).hexdigest()

    def get_headers(self, data: dict):
        sign = self.get_sign(data)
        return {'Signature': sign, 'Accept': 'application/json'}

    async def _response(self, url: str, data: dict):
        try:
            async with aiohttp.ClientSession(headers=self.get_headers(data)) as session:
                async with session.post(url, json=data, ssl=False) as response:
                    return json.loads(await response.text())
        except Exception:
            pass

    async def create_invoice(self, amount: float, order_id: str):
        endpoint = 'create'
        data = {
            'shopId': self.SHOP_ID,
            'sum': amount,
            'orderId': order_id
        }
        data = self.sort_dict(data)
        # {'data': {'id': '25f6b3c0-9c37-4189-a6be-f2b41d1c962d', 'amount': 10, 'expired': '2023-11-02 18:49:21', 'status': 1, 'shop_id': 'a573a7c3-b7f4-46e7-8ed5-10a5e426dab0', 'url': 'https://pay.lava.ru/invoice/25f6b3c0-9c37-4189-a6be-f2b41d1c962d?lang=ru', 'comment': None, 'merchantName': 'Email Fast', 'exclude_service': None, 'include_service': None}, 'status': 200, 'status_check': True}
        return await self._response(self.url.format(endpoint=endpoint), data)

    async def get_invoice_status(self, order_id: str, invoice_id: str):
        endpoint = 'status'
        data = {
            'shopId': self.SHOP_ID,
            'orderId': order_id,
            'invoiceId': invoice_id
        }
        data = self.sort_dict(data)
        # {'data': {'status': 'created', 'error_message': None, 'id': '25f6b3c0-9c37-4189-a6be-f2b41d1c962d', 'shop_id': 'a573a7c3-b7f4-46e7-8ed5-10a5e426dab0', 'amount': 10, 'expire': '2023-11-02 18:49:21', 'order_id': '2', 'fail_url': 'https://t.me/emailfastbot', 'success_url': 'https://t.me/emailfastbot', 'hook_url': 'http://emailfast.site:5000/lava_good', 'custom_fields': None, 'include_service': None, 'exclude_service': None}, 'status': 200, 'status_check': True}
        # {'data': {'status': 'success', 'error_message': None, 'id': 'f9768502-84c9-4786-9a64-c86245c95f21', 'shop_id': 'a573a7c3-b7f4-46e7-8ed5-10a5e426dab0', 'amount': 10, 'expire': '2023-11-02 18:53:59', 'order_id': '3', 'fail_url': 'https://t.me/emailfastbot', 'success_url': 'https://t.me/emailfastbot', 'hook_url': 'http://emailfast.site:5000/lava_good', 'custom_fields': None, 'include_service': None, 'exclude_service': None}, 'status': 200, 'status_check': True}
        return await self._response(self.url.format(endpoint=endpoint), data)


app\services\low_balance.py
from datetime import timedelta

from aiogram import types
from aiogram.utils.keyboard import InlineKeyboardBuilder
from tortoise import timezone

from app.db import models
from app.dependencies import bot
from app.services import bot_texts as bt


async def check_low_balance(user: models.User, amount: float):
    if user.balance >= 50 > user.balance - amount:
        return True

    return False


async def send_low_balance_alert(user: models.User):
    user.bonus_end_at = timezone.now() + timedelta(days=1)
    await user.save()
    builder = InlineKeyboardBuilder()
    for price_dict in bt.prices_data:
        builder.button(
            text=str(price_dict['price']) + '₽ (+10%)',
            callback_data=f'bonus_price:{price_dict["price"]}'
        )

    builder.adjust(2)
    builder.row(
        types.InlineKeyboardButton(text=bt.OTHER_DEPOSIT_PRICE_BTN + ' (+10%)', callback_data='bonus_price:other')
    )
    await bot.send_message(
        chat_id=user.telegram_id,
        text=bt.LOW_BALANCE_ALERT,
        reply_markup=builder.as_markup()
    )


app\services\need_subscribe.py
from datetime import timedelta

from aiogram import types
from tortoise import timezone

from app import dependencies
from app.db import models
from app.dependencies import bot, CHECK_CHANNEL
from app.services import bot_texts as bt


async def check_subscribe(user: models.User):
    if not CHECK_CHANNEL:
        return True
    if user.in_channel:
        return True

    if user.last_check_in is None:
        user.last_check_in = timezone.now() - timedelta(minutes=31)
        await user.save()
        return False

    if user.last_check_in < timezone.now() - timedelta(minutes=30):
        member = await bot.get_chat_member(chat_id=dependencies.CHANNEL_ID, user_id=user.telegram_id)
        if member.status in ("creator", "administrator", "member"):
            user.in_channel = True
            user.last_check_in = timezone.now()
            await user.save()
            return True

        return False

    return True


async def send_subscribe_msg(user: models.User):
    msg_text = bt.SUBSCRIBE_CHANNEL
    mk = types.InlineKeyboardMarkup(
        inline_keyboard=[
            [
                types.InlineKeyboardButton(text=bt.SUBSCRIBE_CHANNEL_BTN, url=bt.CHANNEL_LINK)
            ],
            [
                types.InlineKeyboardButton(text=bt.READY_SUBSCRIBE_CHANNEL_BTN, callback_data="check_subscribe")
            ]
        ]
    )
    await bot.send_message(chat_id=user.telegram_id, text=msg_text, reply_markup=mk)


app\services\notify_admins.py
from aiogram import Bot
from app.dependencies import ADMINS


async def notify_wakeup_bot(bot: Bot):
    try:
        await bot.send_message(chat_id=ADMINS[0], text='Успешный запуск бота!')
    except:
        pass

app\services\periodic_tasks.py
import json
from math import floor
from aiogram.utils.keyboard import InlineKeyboardBuilder
from aiogram import types
from aiohttp import ClientSession
from pyonlinesim import OnlineSMS
from tortoise import timezone
from loguru import logger
from app import dependencies
from app.db import models
from app.dependencies import bot, FK_SHOP_ID, FK_FK_API_KEY, CODER, API_KEY_ONLINESIM
from app.dialogs.receive_sms.getters import service_is_smsactivate
from app.dialogs.rent_sms.getters import get_day_string
from app.handlers.get_email_handler import get_extend_email_kb
from app.services.bot_texts import country_flags
from app.services.mail.receive_messages import get_unread_messages
from app.services.onlinesim.rent_number import OnlineSimRentAPI
from app.services.payments.anypay import AnypayAPI
from app.services.payments.ckassa import get_ckassa_payments
from app.services.payments.cryptomus import get_paid_order_ids
from app.services.payments.freekassa import Freekassa
from app.services.payments.lava import LavaApi
from app.services.payments.streampay import get_payment_status_streampay
from app.services.sms_receive import SmsReceive
from app.services.temp_mail import TempMail
from app.services import bot_texts as bt
import pytz
import datetime

from app.services.payments.yoomoney import check_payment_status


async def check_payment_lava():
    """
    Проверяет статус платежей, выполненных через LavaApi, и обновляет соответствующие записи в базе данных.

    Эта функция:
    1. Получает список платежей, ожидающих проверки, из базы данных.
    2. Для каждого платежа запрашивает статус инвойса через LavaApi.
    3. Если платеж успешен:
       - Обновляет статус платежа в базе данных.
       - Увеличивает баланс пользователя на сумму платежа (с бонусом, если применимо).
       - Начисляет реферальный бонус, если есть привязанный реферал.
       - Отправляет пользователю сообщение об успешной оплате с возможностью продолжения операции.
    4. Логирует и обрабатывает исключения, возникающие в процессе выполнения.

    Исключения обрабатываются и записываются в лог, чтобы не прерывать выполнение функции при возникновении ошибки.

    """

    # Получаем список платежей, которые нужно проверить, из базы данных.
    payments = await models.Payment.get_lava_payments()

    # Проходим по каждому платежу в списке.
    for payment in payments:
        # Инициализируем объект LavaApi для взаимодействия с платежной системой.
        lava = LavaApi()
        try:
            # Запрашиваем статус инвойса по order_id и invoice_id.
            response = await lava.get_invoice_status(payment.order_id, payment.invoice_id)

            # Проверяем успешность запроса к API.
            if response['status'] == 200:
                invoice = response['data']

                # Если статус инвойса "success", обрабатываем успешный платеж.
                if invoice['status'] == 'success':
                    # Отмечаем платеж как успешный в базе данных.
                    payment.is_success = True
                    await payment.save()

                    # Проверяем, есть ли у пользователя активный бонус и его срок не истек.
                    if payment.user.bonus_end_at is not None and payment.user.bonus_end_at > timezone.now():
                        # Если бонус активен, увеличиваем сумму платежа на 10%.
                        amount = floor(payment.amount * 1.1)
                        # Сбрасываем срок действия бонуса.
                        payment.user.bonus_end_at = None
                    else:
                        # Если бонус не активен, сумма остается без изменений.
                        amount = payment.amount

                    # Увеличиваем баланс пользователя на сумму платежа (с учетом бонуса, если он был).
                    payment.user.balance += amount
                    await balance_replenishment_notification(payment, "Lava")
                    await bot.send_message(chat_id=payment.user.telegram_id,
                                           text=f'<b>💰Баланс успешно пополнен на {amount}₽</b>')
                    await payment.user.save()

                    # Если у пользователя есть реферал, начисляем реферальный бонус.
                    if payment.user.refer_id:
                        refer = await models.User.get_or_none(id=payment.user.refer_id)
                        if refer:
                            # Рассчитываем реферальный бонус как процент от суммы платежа.
                            ref_bonus = int(dependencies.REF_BONUS) / 100
                            ref_sum = round(payment.amount * ref_bonus, 1)
                            refer.ref_balance += ref_sum
                            refer.total_ref_earnings += ref_sum
                            await refer.save()
                            # Вызываем уведомление о реферальном бонусе
                            await referral_bonus_notification(payment, refer, ref_sum)

                    # try:
                    #     # Подготавливаем клавиатуру для возможного продолжения операции после успешной оплаты.
                    #     builder = InlineKeyboardBuilder()
                    #     if payment.continue_data:
                    #         builder.button(text=bt.CONTINUE_BTN, callback_data=f'continue_payment:{payment.id}')
                    #
                    #     # Отправляем сообщение пользователю об успешной оплате и возможном продолжении операции.
                    #     await bot.send_message(
                    #         chat_id=payment.user.telegram_id,
                    #         text=bt.PAYMENT_SUCCESS.format(amount=int(amount)),
                    #         reply_markup=builder.as_markup()
                    #     )
                    # except:
                    #     # Игнорируем ошибки, возникающие при отправке сообщения пользователю.
                    #     pass
        except Exception as e:
            # Логируем любые исключения, возникшие в процессе обработки платежа.
            pass


async def check_payment_freekassa():
    # Получаем список платежей, которые нужно проверить, из базы данных.
    payments = await models.Payment.get_freekassa_payments()

    # Текущее время и время 5 часов назад
    tz = pytz.timezone('Europe/Moscow')  # Пример для временной зоны Москвы
    now = datetime.datetime.now(tz)
    five_hours_ago = now - datetime.timedelta(hours=1)

    fk = Freekassa(shop_id=FK_SHOP_ID, api_key=FK_FK_API_KEY)
    # Получаем список оплаченных заказов (со статусом 1) за последние hours часов
    try:
        orders = fk.get_orders(order_status=1, date_from=five_hours_ago)
        merchant_order_ids = [order['merchant_order_id'] for order in orders['orders']]
    except Exception as e:
        merchant_order_ids = []
        pass

    if merchant_order_ids:
        for payment in payments:
            try:
                if str(payment.id) in merchant_order_ids:
                    # Отмечаем платеж как успешный в базе данных.
                    payment.is_success = True
                    await payment.save()

                    # Проверяем, есть ли у пользователя активный бонус и его срок не истек.
                    if payment.user.bonus_end_at is not None and payment.user.bonus_end_at > timezone.now():
                        # Если бонус активен, увеличиваем сумму платежа на 10%.
                        amount = floor(payment.amount * 1.1)
                        # Сбрасываем срок действия бонуса.
                        payment.user.bonus_end_at = None
                    else:
                        # Если бонус не активен, сумма остается без изменений.
                        amount = payment.amount

                    # Увеличиваем баланс пользователя на сумму платежа (с учетом бонуса, если он был).
                    payment.user.balance += amount
                    await balance_replenishment_notification(payment, "freekassa")
                    await bot.send_message(chat_id=payment.user.telegram_id,
                                           text=f'<b>💰Баланс успешно пополнен на {amount}₽</b>')
                    await payment.user.save()

                    # Если у пользователя есть реферал, начисляем реферальный бонус.
                    if payment.user.refer_id:
                        refer = await models.User.get_or_none(id=payment.user.refer_id)
                        if refer:
                            # Рассчитываем реферальный бонус как процент от суммы платежа.
                            ref_bonus = int(dependencies.REF_BONUS) / 100
                            ref_sum = round(payment.amount * ref_bonus, 1)
                            refer.ref_balance += ref_sum
                            refer.total_ref_earnings += ref_sum
                            await refer.save()
                            # Вызываем уведомление о реферальном бонусе
                            await referral_bonus_notification(payment, refer, ref_sum)

                        # Подготавливаем клавиатуру для возможного продолжения операции после успешной оплаты.
                        # builder = InlineKeyboardBuilder()
                        # if payment.continue_data:
                        #     builder.button(text=bt.CONTINUE_BTN, callback_data=f'continue_payment:{payment.id}')
                        #
                        # # Отправляем сообщение пользователю об успешной оплате и возможном продолжении операции.
                        # await bot.send_message(
                        #     chat_id=payment.user.telegram_id,
                        #     text=bt.PAYMENT_SUCCESS.format(amount=int(amount)),
                        #     reply_markup=builder.as_markup()
                        # )
            except TelegramBadRequest:
                pass
            except Exception as e:
                # Логируем любые исключения, возникшие в процессе обработки платежа.
                logger.warning(e)
                await replenishment_error_message(payment, "freekassa")


async def check_payment_yoomoney():
    # Получаем список платежей, которые нужно проверить, из базы данных.
    payments = await models.Payment.get_yoomoney_payments()

    for payment in payments:
        try:
            # Получаем список оплаченных заказов
            if await check_payment_status(payment.id):
                # Отмечаем платеж как успешный в базе данных.
                payment.is_success = True
                await payment.save()

                # Проверяем, есть ли у пользователя активный бонус и его срок не истек.
                if payment.user.bonus_end_at is not None and payment.user.bonus_end_at > timezone.now():
                    # Если бонус активен, увеличиваем сумму платежа на 10%.
                    amount = floor(payment.amount * 1.1)
                    # Сбрасываем срок действия бонуса.
                    payment.user.bonus_end_at = None
                else:
                    # Если бонус не активен, сумма остается без изменений.
                    amount = payment.amount

                # Увеличиваем баланс пользователя на сумму платежа (с учетом бонуса, если он был).
                payment.user.balance += amount
                await balance_replenishment_notification(payment, "yoomoney")
                await payment.user.save()
                await bot.send_message(chat_id=payment.user.telegram_id,
                                       text=f'<b>💰Баланс успешно пополнен на {amount}₽</b>')

                # Если у пользователя есть реферал, начисляем реферальный бонус.
                if payment.user.refer_id:
                    refer = await models.User.get_or_none(id=payment.user.refer_id)
                    if refer:
                        # Рассчитываем реферальный бонус как процент от суммы платежа.
                        ref_bonus = int(dependencies.REF_BONUS) / 100
                        ref_sum = round(payment.amount * ref_bonus, 1)
                        refer.ref_balance += ref_sum
                        refer.total_ref_earnings += ref_sum
                        await refer.save()
                        # Вызываем уведомление о реферальном бонусе
                        await referral_bonus_notification(payment, refer, ref_sum)

                    # Подготавливаем клавиатуру для возможного продолжения операции после успешной оплаты.
                    # builder = InlineKeyboardBuilder()
                    # if payment.continue_data:
                    #     builder.button(text=bt.CONTINUE_BTN, callback_data=f'continue_payment:{payment.id}')
                    #
                    # # Отправляем сообщение пользователю об успешной оплате и возможном продолжении операции.
                    # await bot.send_message(
                    #     chat_id=payment.user.telegram_id,
                    #     text=bt.PAYMENT_SUCCESS.format(amount=int(amount)),
                    #     reply_markup=builder.as_markup()
                    # )
        except TelegramBadRequest:
            pass
        except Exception as e:
            # Логируем любые исключения, возникшие в процессе обработки платежа.
            logger.warning(e)
            await replenishment_error_message(payment, "yoomoney")


async def check_payment_anypay():
    # Получаем список платежей, которые нужно проверить, из базы данных.
    payments = await models.Payment.get_anypay_payments()
    api = AnypayAPI()
    for payment in payments:
        try:
            # Получаем список оплаченных заказов
            if await api.check_payment(payment.id):
                # Отмечаем платеж как успешный в базе данных.
                payment.is_success = True
                await payment.save()

                # Проверяем, есть ли у пользователя активный бонус и его срок не истек.
                if payment.user.bonus_end_at is not None and payment.user.bonus_end_at > timezone.now():
                    # Если бонус активен, увеличиваем сумму платежа на 10%.
                    amount = floor(payment.amount * 1.1)
                    # Сбрасываем срок действия бонуса.
                    payment.user.bonus_end_at = None
                else:
                    # Если бонус не активен, сумма остается без изменений.
                    amount = payment.amount

                # Увеличиваем баланс пользователя на сумму платежа (с учетом бонуса, если он был).
                payment.user.balance += amount
                await balance_replenishment_notification(payment, "AnyPay")
                await bot.send_message(chat_id=payment.user.telegram_id,
                                       text=f'<b>💰Баланс успешно пополнен на {amount}₽</b>')
                await payment.user.save()

                # Если у пользователя есть реферал, начисляем реферальный бонус.
                if payment.user.refer_id:
                    refer = await models.User.get_or_none(id=payment.user.refer_id)
                    if refer:
                        # Рассчитываем реферальный бонус как процент от суммы платежа.
                        ref_bonus = int(dependencies.REF_BONUS) / 100
                        ref_sum = round(payment.amount * ref_bonus, 1)
                        refer.ref_balance += ref_sum
                        refer.total_ref_earnings += ref_sum
                        await refer.save()
                        # Вызываем уведомление о реферальном бонусе
                        await referral_bonus_notification(payment, refer, ref_sum)

                    # Подготавливаем клавиатуру для возможного продолжения операции после успешной оплаты.
                    # builder = InlineKeyboardBuilder()
                    # if payment.continue_data:
                    #     builder.button(text=bt.CONTINUE_BTN, callback_data=f'continue_payment:{payment.id}')
                    #
                    # # Отправляем сообщение пользователю об успешной оплате и возможном продолжении операции.
                    # await bot.send_message(
                    #     chat_id=payment.user.telegram_id,
                    #     text=bt.PAYMENT_SUCCESS.format(amount=int(amount)),
                    #     reply_markup=builder.as_markup()
                    # )

        except TelegramBadRequest:
            pass
        except Exception as e:
            # Логируем любые исключения, возникшие в процессе обработки платежа.
            logger.warning(e)
            await replenishment_error_message(payment, "AnyPay")


async def check_payment_streampay():
    # Получаем список платежей, которые нужно проверить, из базы данных.
    payments = await models.Payment.get_streampay_payments()
    for payment in payments:
        try:
            # Получаем оплаченные заказы
            if await get_payment_status_streampay(payment.invoice_id) == 'success':
                # Отмечаем платеж как успешный в базе данных.
                payment.is_success = True
                await payment.save()

                # Проверяем, есть ли у пользователя активный бонус и его срок не истек.
                if payment.user.bonus_end_at is not None and payment.user.bonus_end_at > timezone.now():
                    # Если бонус активен, увеличиваем сумму платежа на 10%.
                    amount = floor(payment.amount * 1.1)
                    # Сбрасываем срок действия бонуса.
                    payment.user.bonus_end_at = None
                else:
                    # Если бонус не активен, сумма остается без изменений.
                    amount = payment.amount

                # Увеличиваем баланс пользователя на сумму платежа (с учетом бонуса, если он был).
                payment.user.balance += amount
                await balance_replenishment_notification(payment, "streampay")
                await bot.send_message(chat_id=payment.user.telegram_id,
                                       text=f'<b>💰Баланс успешно пополнен на {amount}₽</b>')
                await payment.user.save()

                # Если у пользователя есть реферал, начисляем реферальный бонус.
                if payment.user.refer_id:
                    refer = await models.User.get_or_none(id=payment.user.refer_id)
                    if refer:
                        # Рассчитываем реферальный бонус как процент от суммы платежа.
                        ref_bonus = int(dependencies.REF_BONUS) / 100
                        ref_sum = round(payment.amount * ref_bonus, 1)
                        refer.ref_balance += ref_sum
                        refer.total_ref_earnings += ref_sum
                        await refer.save()
                        # Вызываем уведомление о реферальном бонусе
                        await referral_bonus_notification(payment, refer, ref_sum)

                    # Подготавливаем клавиатуру для возможного продолжения операции после успешной оплаты.
                    # builder = InlineKeyboardBuilder()
                    # if payment.continue_data:
                    #     builder.button(text=bt.CONTINUE_BTN, callback_data=f'continue_payment:{payment.id}')
                    #
                    # # Отправляем сообщение пользователю об успешной оплате и возможном продолжении операции.
                    # await bot.send_message(
                    #     chat_id=payment.user.telegram_id,
                    #     text=bt.PAYMENT_SUCCESS.format(amount=int(amount)),
                    #     reply_markup=builder.as_markup()
                    # )
        except TelegramBadRequest:
            pass
        except Exception as e:
            # Логируем любые исключения, возникшие в процессе обработки платежа.
            logger.warning(e)
            await replenishment_error_message(payment, "streampay")


async def check_payment_ckassa():
    """
    Асинхронная функция для проверки статуса платежей CKassa.
    """
    # Получаем список платежей, которые нужно проверить, из базы данных.
    payments = await models.Payment.get_ckassa_payments()

    for payment in payments:
        try:
            # Получаем статус платежа через CKassa
            payment_data = await get_ckassa_payments(payment.invoice_id)

            # Проверяем, успешен ли платеж
            if payment_data and payment_data.get('state') == 'PAYED':
                # Отмечаем платеж как успешный в базе данных.
                payment.is_success = True
                await payment.save()

                # Проверяем, есть ли у пользователя активный бонус и его срок не истек.
                if payment.user.bonus_end_at is not None and payment.user.bonus_end_at > timezone.now():
                    # Если бонус активен, увеличиваем сумму платежа на 10%.
                    amount = floor(payment.amount * 1.1)
                    # Сбрасываем срок действия бонуса.
                    payment.user.bonus_end_at = None
                else:
                    # Если бонус не активен, сумма остается без изменений.
                    amount = payment.amount

                # Увеличиваем баланс пользователя на сумму платежа (с учетом бонуса).
                payment.user.balance += amount
                await payment.user.save()
                await balance_replenishment_notification(payment, "ckassa")
                # Отправляем сообщение пользователю об успешном пополнении баланса.
                await bot.send_message(chat_id=payment.user.telegram_id,
                                       text=f'<b>💰Баланс успешно пополнен на {amount}₽</b>')

                # Если у пользователя есть реферал, начисляем реферальный бонус.
                if payment.user.refer_id:
                    refer = await models.User.get_or_none(id=payment.user.refer_id)
                    if refer:
                        # Рассчитываем реферальный бонус как процент от суммы платежа.
                        ref_bonus = int(dependencies.REF_BONUS) / 100
                        ref_sum = round(payment.amount * ref_bonus, 1)
                        refer.ref_balance += ref_sum
                        refer.total_ref_earnings += ref_sum
                        await refer.save()
                        # Вызываем уведомление о реферальном бонусе
                        await referral_bonus_notification(payment, refer, ref_sum)

                # # Если есть данные для продолжения операции после успешной оплаты, отправляем клавиатуру.
                # builder = InlineKeyboardBuilder()
                # if payment.continue_data:
                #     builder.button(text=bt.CONTINUE_BTN, callback_data=f'continue_payment:{payment.id}')
                #     await bot.send_message(
                #         chat_id=payment.user.telegram_id,
                #         text=bt.PAYMENT_SUCCESS.format(amount=int(amount)),
                #         reply_markup=builder.as_markup()
                #     )
        except TelegramBadRequest:
            pass
        except Exception as e:
            # Логгируем любые исключения.
            logger.warning(e)
            await replenishment_error_message(payment, "CKassa")


async def check_payment_cryptomus():
    # Получаем список платежей, которые нужно проверить, из базы данных.
    payments = await models.Payment.get_cryptomus_payments()
    # Получаем список оплаченных инвойсов
    payments_cryptomus = get_paid_order_ids()
    for payment in payments:
        try:
            # Получаем список оплаченных заказов
            if str(payment.id) in payments_cryptomus:
                # Отмечаем платеж как успешный в базе данных.
                payment.is_success = True
                await payment.save()

                # Проверяем, есть ли у пользователя активный бонус и его срок не истек.
                if payment.user.bonus_end_at is not None and payment.user.bonus_end_at > timezone.now():
                    # Если бонус активен, увеличиваем сумму платежа на 10%.
                    amount = floor(payment.amount * 1.1)
                    # Сбрасываем срок действия бонуса.
                    payment.user.bonus_end_at = None
                else:
                    # Если бонус не активен, сумма остается без изменений.
                    amount = payment.amount

                # Увеличиваем баланс пользователя на сумму платежа (с учетом бонуса, если он был).
                payment.user.balance += amount
                await balance_replenishment_notification(payment, "Cryptomus")
                await bot.send_message(chat_id=payment.user.telegram_id,
                                       text=f'<b>💰Баланс успешно пополнен на {amount}₽</b>')
                await payment.user.save()

                # Если у пользователя есть реферал, начисляем реферальный бонус.
                if payment.user.refer_id:
                    refer = await models.User.get_or_none(id=payment.user.refer_id)
                    if refer:
                        # Рассчитываем реферальный бонус как процент от суммы платежа.
                        ref_bonus = int(dependencies.REF_BONUS) / 100
                        ref_sum = round(payment.amount * ref_bonus, 1)
                        refer.ref_balance += ref_sum
                        refer.total_ref_earnings += ref_sum
                        await refer.save()
                        # Вызываем уведомление о реферальном бонусе
                        await referral_bonus_notification(payment, refer, ref_sum)

                    # Подготавливаем клавиатуру для возможного продолжения операции после успешной оплаты.
                    # builder = InlineKeyboardBuilder()
                    # if payment.continue_data:
                    #     builder.button(text=bt.CONTINUE_BTN, callback_data=f'continue_payment:{payment.id}')
                    #
                    # # Отправляем сообщение пользователю об успешной оплате и возможном продолжении операции.
                    # await bot.send_message(
                    #     chat_id=payment.user.telegram_id,
                    #     text=bt.PAYMENT_SUCCESS.format(amount=int(amount)),
                    #     reply_markup=builder.as_markup()
                    # )
        except TelegramBadRequest:
            pass
        except Exception as e:
            # Логируем любые исключения, возникшие в процессе обработки платежа.
            logger.warning(e)
            await replenishment_error_message(payment, "Cryptomus")


import re


async def check_sms():
    try:
        # Получаем все активные активации
        activations = await models.Activation.get_active_activations()

        # Обрабатываем каждую активную активацию
        for activation in activations:
            # Получаем статус активации по её идентификатору
            if len(str(activation.activation_id)) > 9:
                sms = SmsReceive()
                status = str(await sms.get_activation_status(activation.activation_id))
                try:
                    name = activation.service.name
                except Exception:
                    name = None
                # STATUS_OK:1231
            else:
                client = OnlineSMS(api_key=API_KEY_ONLINESIM)
                order_info = await client.get_order_info(operation_id=activation.activation_id, get_full_message=True)
                for_information = order_info
                name = await activation.get_service_2_name()

                if order_info and isinstance(order_info, list) and 'msg' in order_info[0]:
                    sms_code = order_info[0]['msg']
                    status = f'STATUS_OK:{sms_code}'
                else:
                    continue

            # Проверяем, начинается ли статус с 'STATUS_OK'
            if status.startswith(models.StatusResponse.STATUS_OK.name):
                # Обновляем статус активации на 'STATUS_OK'
                activation.status = models.StatusResponse.STATUS_OK

                # Смотрим какая смс в БД
                current_sms = activation.sms_text if activation.sms_text is not None else '1'

                # Извлекаем текст SMS из статуса
                sms_from_status = status.split(':', 1)[1]  # используем split только один раз

                # Применяем регулярное выражение для извлечения цифр из текста
                # sms_digits = re.findall(r'\d+', sms_from_status)
                #
                # if sms_digits:
                #     # Если цифры найдены, берем первую
                #     sms_from_status = sms_digits[0]
                # else:
                #     # Если цифры не найдены — оставляем оригинальный текст SMS
                #     sms_from_status = sms_from_status.strip()

                activation.sms_text = sms_from_status
                # Сохраняем изменения в базе данных
                await activation.save()

                # Загружаем связанные данные пользователя и сервиса
                if await service_is_smsactivate():
                    await activation.fetch_related('user', 'service')
                else:
                    await activation.fetch_related('user', 'service_2')

                # Формируем текст сообщения для отправки пользователю если смс новая
                if current_sms != sms_from_status:
                    if name:
                        msg_text = (
                            f"💬<b>Новое SMS</b> на номер: +{activation.phone_number}\n\n"
                            f"Ваш код активации для <b>{name}</b>:\n"
                            f"<code>{activation.sms_text}</code>"
                        )

                    else:
                        msg_text = (
                            f"💬<b>Новое SMS</b> на номер: +{activation.phone_number}\n\n"
                            f"Ваш код активации:\n"
                            f"<code>{activation.sms_text}</code>"
                        )

                    # Отправляем сообщение пользователю в Telegram
                    await bot.send_message(
                        chat_id=activation.user.telegram_id,
                        text=msg_text
                    )
                    await notice_of_arraignment("Получение смс", activation, name)
                    logger.bind(
                        user_id=activation.user.telegram_id,
                        action="new_sms"
                    ).log("USER_ACTION", f"Получено новое SMS для номера {activation.phone_number}, код: {sms_from_status}")


        # Получаем все истекшие активации
        activations = await models.Activation.get_expired_activations()

        # Обрабатываем каждую истекшую активацию
        for activation in activations:
            # Обновляем статус активации на 'STATUS_CANCEL'
            activation.status = models.StatusResponse.STATUS_CANCEL
            # Сохраняем изменения в базе данных
            await activation.save()

            # Возвращаем стоимость активации пользователю
            activation.user.balance += activation.cost
            # Сохраняем изменения баланса пользователя в базе данных
            await activation.user.save()

            # Логируем возврат средств за истёкшую активацию
            logger.bind(
                user_id=activation.user.telegram_id,
                action="refund_activation"
            ).log("USER_ACTION", f"Возврат средств за истёкшую активацию: Номер: {activation.phone_number}, сумма {activation.cost}₽, Баланс = {activation.user.balance} ₽")

    except asyncio.CancelledError:
        pass
    except Exception as e:
        error_info = f"""
        ❌ Ошибка в check_sms
        ───────────────────
        🔹 Пользователь: {activation.user.telegram_id if 'activation' in locals() and activation.user else 'Неизвестно'}
        🔹 Номер: {activation.phone_number if 'activation' in locals() else 'Неизвестно'}
        🔹 Сервис: {name if 'name' in locals() else 'Неизвестно'}
        🔹 ID активации: {activation.activation_id if 'activation' in locals() else 'Неизвестно'}
        🔹 Статус: {activation.status.name if 'activation' in locals() else 'Неизвестно'}

        ⚠️ Ошибка: {e}
        """

        await send_coder(error_info)
        logger.opt(exception=e).error("Необработанная ошибка в check_sms")


import asyncio
from aiogram.exceptions import TelegramBadRequest


async def check_email():
    """
    Функция проверяет электронные почты на наличие новых сообщений и уведомляет пользователей через Telegram.

    1. Деактивирует просроченные почтовые ящики.
    2. Проверяет активные почтовые ящики на наличие новых сообщений.
    3. Сохраняет новые сообщения в базе данных и отправляет уведомления пользователям через Telegram.

    Исключения:
        TelegramBadRequest: В случае ошибки при отправке сообщения через Telegram API.
    """
    try:
        # Получаем список просроченных почтовых ящиков
        expired_emails = await models.Mail.get_expired_mails()

        for mail in expired_emails:
            # Деактивируем просроченные почтовые ящики
            mail.is_active = False
            await mail.save()
            logger.bind(
                user_id=mail.user.telegram_id,
                action="deactivate_mail"
            ).log("USER_ACTION", f"Почтовый ящик {mail.email} деактивирован (истёк срок аренды)")
            await asyncio.sleep(0)  # Позволяет другим задачам выполняться

        # Получаем список активных почтовых ящиков и связанных с ними пользователей
        mails = await models.Mail.filter(is_active=True).all().prefetch_related('user')
        for mail in mails:
            unread_messages = await get_unread_messages(mail.token)
            for unread_message in unread_messages:
                # Если ящик бесплатный и сообщений больше 10, выходим из функции
                if not mail.is_paid_mail and len(mail.old_messages_id) > 10:
                    logger.warning(f"Бесплатный ящик {mail.email} превысил лимит сообщений")
                    return

                # Проверяем, было ли сообщение уже обработано
                if unread_message['id'] not in mail.old_messages_id:

                    # Обновляем список старых сообщений и сохраняем изменения
                    mail.old_messages_id.append(unread_message['id'])
                    await mail.save()

                    # Сохраняем новое сообщение в базе данных
                    await models.Letter.add_letter(
                        mail=mail,
                        user=mail.user,
                        text=unread_message['content']
                    )

                    mk = types.InlineKeyboardMarkup(
                        inline_keyboard=[
                            [types.InlineKeyboardButton(
                                text=bt.GET_FULL_MESSAGE,
                                callback_data=f"full_unread_message|{unread_message['id']}|{mail.id}"
                            )]
                        ]
                    )

                    # Формируем текст уведомления для пользователя
                    msg_text = (
                        f'📩<b>Новое сообщение</b> на почту: <b>{mail.email}</b>\n\n'
                        f'<b>От кого:</b> {unread_message["from"]}\n<b>Тема:</b> {unread_message["subject"]}\n\n'
                        f'{unread_message["content"]}'
                    )

                    try:
                        # Пытаемся отправить уведомление пользователю через Telegram
                        await bot.send_message(
                            chat_id=mail.user.telegram_id,
                            text=msg_text,
                            reply_markup=mk
                        )
                        # Логгируем успешное получение нового письма
                        logger.bind(
                            user_id=mail.user.telegram_id,
                            action="new_email"
                        ).log("USER_ACTION", f"Новое сообщение на ящике {mail.email}: {unread_message['subject']}")

                    except TelegramBadRequest as e:
                        # Логируем ошибку отправки Telegram-сообщения
                        logger.opt(exception=e).warning(
                            f"Ошибка при отправке сообщения пользователю {mail.user.telegram_id}: {e}"
                        )

                await asyncio.sleep(0)  # Уступаем управление другим задачам

    except asyncio.CancelledError:
        pass

    except Exception as e:
        # Логируем любую необработанную ошибку
        # logger.opt(exception=e).error("Необработанная ошибка в check_email()")
        logger.error(e)


async def get_services_names():
    try:
        data = {
            'act': 'getServicesList',
            'csrf': ''
        }
        url = 'https://sms-activate.org/api/api.php'
        async with ClientSession() as session:
            async with session.post(url=url, data=data) as response:
                data = json.loads(await response.text())

        services_dict = {}
        for service in data['data']:
            services_dict[service['code']] = service['name'].replace('<small>+переадресация</small>', '')
            await asyncio.sleep(0)

        return services_dict
    except Exception as e:
        logger.opt(exception=e).error("Критическая ошибка при получении списка сервисов из SMS-Activate")
        await send_coder(f"❌ Ошибка получения сервисов из SMS-Activate:\n{e}")


async def update_countries_and_services():
    sms = SmsReceive()
    countries = await sms.get_countries()
    countries_db_ids = await models.CountriesSmsActivate.get_country_id_list()
    for country in countries:
        await models.CountriesSmsActivate.get_or_create(country_id=country["id"], name=country["name"])
        try:
            countries_db_ids.remove(int(country["id"]))
        except ValueError:
            pass

        await asyncio.sleep(0)

    for country_id in countries_db_ids:
        country = await models.CountriesSmsActivate.get_country_by_id(country_id)
        await country.delete()

    services = await sms.get_services()
    services_dict = await get_services_names()
    services_db_codes = await models.ServicesSmsActivate.get_codes_list()
    for service in services:
        service_obj = await models.ServicesSmsActivate.get_service(code=service["code"])
        if service_obj is None:
            await models.ServicesSmsActivate.add_service(
                code=service["code"],
                name=services_dict[service["code"]],
                search_names=service["search_names"]
            )
        else:
            service_obj.name = services_dict[service["code"]]
            service_obj.search_names = service["search_names"]
            await service_obj.save()

        try:
            services_db_codes.remove(service["code"])
        except ValueError:
            pass

        await asyncio.sleep(0)

    for service_code in services_db_codes:
        service = await models.ServicesSmsActivate.get_service(code=service_code)
        await service.delete()


async def check_mail_expiration_and_notify():
    """
    Проверяет почтовые ящики, срок аренды которых истекает через 24 часа, и уведомляет пользователей.
    """
    # Определяем временную зону +3
    tz = pytz.timezone('Europe/Moscow')

    # Получаем текущее время в UTC и переводим в нужную временную зону
    now = datetime.datetime.now(pytz.utc).astimezone(tz)
    next_day = now + datetime.timedelta(days=1)

    # Округляем до начала часа
    now_rounded = now.replace(minute=0, second=0, microsecond=0)
    next_day_rounded = next_day.replace(minute=0, second=0, microsecond=0)

    # Получаем все ID почтовых ящиков, которые истекают ровно через 24 часа и еще не уведомлены
    expiring_mail_ids = await models.Mail.filter(
        expire_at__gte=now_rounded,
        expire_at__lte=next_day_rounded,
        is_active=True,
        is_paid_mail=True,
        notification_sent=False
    ).values_list('id', flat=True)

    # Проходим по каждому ID и получаем почту вместе с пользователем
    for mail_id in expiring_mail_ids:
        mail = await models.Mail.get(id=mail_id).prefetch_related('user')
        user = mail.user
        inline_kb = types.InlineKeyboardMarkup(
            inline_keyboard=[
                [
                    types.InlineKeyboardButton(text='Продлить аренду', callback_data='rental')
                ]
            ]
        )

        try:

            # Пытаемся отправить уведомление пользователю через Telegram с inline-кнопкой
            await bot.send_message(
                chat_id=mail.user.telegram_id,
                text=f'У вас истекает срок аренды почтового ящика <b>{mail.email}</b>️\n'
                     f'Чтобы продлить аренду нажмите кнопку⤵️',
                reply_markup=inline_kb
            )

            # Обновляем флаг уведомления
            mail.notification_sent = True
            await mail.save()
            logger.bind(user_id=user.telegram_id, action="mail_expiration_notification").log(
                "USER_ACTION",
                f"Пользователь {user.telegram_id} получил уведомление об истечении срока аренды ящика {mail.email}"
            )
        except TelegramBadRequest as e:
            # Обрабатываем исключение, если возникает ошибка при отправке сообщения
            await send_coder(f"❌ Ошибка при отправке уведомления о сроке аренды ящика:\n"
                             f"Пользователь: {user.telegram_id}\nОшибка: {e}")


async def notify_week_expiration():
    tz = pytz.timezone('Europe/Moscow')
    now = datetime.datetime.now(pytz.utc).astimezone(tz)
    notify_start = now + datetime.timedelta(hours=23, minutes=50)
    notify_end = now + datetime.timedelta(hours=24, minutes=10)

    mails = await models.Mail.filter(
        is_active=True,
        is_free_week=True,
        notification_sent=False,
        expire_at__gte=notify_start,
        expire_at__lte=notify_end
    ).prefetch_related("user")

    for mail in mails:
        try:
            mail.notification_sent = True
            await mail.save()
            await bot.send_message(
                chat_id=mail.user.telegram_id,
                text="⏰ Бесплатная неделя аренды почты заканчивается через 24 часа!\n"
                     "Для продления аренды выберите тариф:",
                reply_markup=get_extend_email_kb(mail.id, False)
            )
        except Exception as e:
            logger.opt(exception=e).error("Ошибка уведомления о завершении недели")
            continue

    # отключение флага is_free_week, если неделя уже истекла
    expired = await models.Mail.filter(
        is_active=False,
        is_free_week=True,
        expire_at__lt=now
    )

    for mail in expired:
        mail.is_free_week = False
        await mail.save()




async def send_coder(msg_text):
    if CODER:
        await bot.send_message(chat_id=CODER, text=msg_text)


async def check_rent_sms():
    try:
        # Получаем все активные аренды
        activations = await models.Rent.get_all_active_rents()

        # Обрабатываем каждую активную аренду
        for activation in activations:
            # Получаем состояние аренды через OnlineSimRentAPI
            api_client = OnlineSimRentAPI()
            rent_state = await api_client.get_rent_state(tzid=activation.rent_id)

            # Проверяем, есть ли данные в 'list'
            if rent_state.get("response") == 1 and "list" in rent_state:
                if rent_state["list"]:  # Проверяем, что список не пуст
                    rent_info = rent_state["list"][0]  # Обрабатываем первую запись в списке

                    # Извлекаем сообщения
                    messages = rent_info.get("messages", [])
                    minutes = rent_info.get("time", 0)
                    # Формируем строку для сравнения
                    new_sms_text = "\n".join([f"{msg.get('service', 'Unknown')}: {msg.get('code', '')}" for msg in messages])

                    # Проверяем, отличается ли новое сообщение от текущего
                    if activation.sms_text == new_sms_text:
                        continue

                    # Сохраняем новый текст в sms_text
                    activation.sms_text = new_sms_text

                    # Обновляем время аренды
                    activation.rent_expire_at = (
                            datetime.datetime.now(pytz.timezone("Europe/Moscow")).replace(microsecond=0)
                            + datetime.timedelta(minutes=minutes)
                    )
                    await activation.save()

                    if messages:
                        activation.status = models.StatusResponse.STATUS_OK
                        await activation.save()
                        # Получаем последнее сообщение
                        last_message = messages[0]
                        service = last_message.get("service", "Unknown")
                        text = last_message.get("code", "")

                        # Формируем текст для отправки пользователю
                        msg_text = f"""
                        💬 <b>Новое SMS</b> на номер: +{activation.phone_number}\nВаш код активации для сервиса <b>{service}</b>: <code>{text}</code>
                        """

                        # Отправляем сообщение пользователю в Telegram
                        await bot.send_message(
                            chat_id=activation.user.telegram_id,
                            text=msg_text,
                            parse_mode="HTML"
                        )

                        # Логгируем событие аренды (или получения SMS)
                        name = service
                        await notice_of_arraignment("Аренда номера",activation, name)

        # Если в течение 20 минут не воспользовался номером
        expired_activations = await models.Rent.get_expired_activations()

        # Обрабатываем каждую истекшую аренду
        for expired_activation in expired_activations:
            # Обновляем статус аренды на 'STATUS_CANCEL'
            expired_activation.status = models.StatusResponse.STATUS_CANCEL
            expired_activation.is_canceled = True
            expired_activation.purchase_count -= 1
            await expired_activation.save()

            # Здесь важно, чтобы user был загружен
            user = await expired_activation.user
            if expired_activation.sms_text == '' and not expired_activation.refund_processed:
                user.balance += expired_activation.cost
                expired_activation.refund_processed = True
                await expired_activation.save()
                await user.save()
                # Логируем возврат средств за истёкшую аренду
                logger.bind(
                    user_id=user.telegram_id,
                    action="refund_rent"
                ).log(
                    "USER_ACTION",
                    f"Возврат средств за истёкшую аренду номера {expired_activation.phone_number}: {expired_activation.cost}₽"
                )


    except asyncio.CancelledError:
        pass
    except Exception as e:
        logger.opt(exception=True).error(f"Критическая ошибка в check_rent_sms(): {e}")


async def rents_ending_soon():
    try:
        # Получает список аренд, для которых срок истекает ровно через 5 часов
        rents_ending = await models.Rent.get_rents_ending_soon()
        for ending in rents_ending:
            user_id = ending.user.telegram_id
            if not ending.autorenew:
                msg_text = f"""
                    💬 <b>Скоро закончится срок аренды номера +{ending.phone_number}.\nУспейте продлить срок аренды или арендовать новый номер⤵️</b>
                """

                inline_kb = types.InlineKeyboardMarkup(
                    inline_keyboard=[
                        [
                            types.InlineKeyboardButton(text='🔄Продлить аренду', callback_data=f"extend_rent_{ending.id}")
                        ],
                        [
                            types.InlineKeyboardButton(text=bt.RENT_NEW_ROOM, callback_data="new_number")
                        ]
                    ]
                )

                # Отправляем сообщение пользователю
                await bot.send_message(chat_id=user_id, text=msg_text, reply_markup=inline_kb)
                # Логгируем действие пользователя
                logger.bind(
                    user_id=user_id,
                    action="rent_expiration_notification"
                ).log(
                    "USER_ACTION",
                    f"Пользователь {user_id} получил уведомление об истечении срока аренды номера +{ending.phone_number}"
                )
                # Обновляем статус уведомления
                ending.is_notified = True
                await ending.save(update_fields=["is_notified"])  # Сохраняем только это поле

    except asyncio.CancelledError:
        pass
    except Exception as e:
        logger.opt(exception=True).error(f"Критическая ошибка в rents_ending_soon(): {e}")


async def auto_renewal_of_rent():
    try:
        # Получает список аренд, для которых срок истекает ровно через 2 часа
        rents_ending = await models.Rent.get_rents_ending_soon()
        for ending in rents_ending:
            user_id = ending.user.telegram_id
            if ending.autorenew:
                if ending.user.balance < ending.cost:
                    inline_replenish = types.InlineKeyboardMarkup(
                        inline_keyboard=[
                            [
                                types.InlineKeyboardButton(text=bt.DEPOSIT_BTN, callback_data=f"top_up_balance")
                            ],
                        ]
                    )
                    # Отправляем сообщение пользователю
                    await bot.send_message(chat_id=user_id, text=bt.NOT_ENOUGH_FUNDS_FOR_RENT, reply_markup=inline_replenish)

                    # Логируем недостаток средств
                    logger.bind(
                        user_id=user_id,
                        action="autorenew_not_enough_funds"
                    ).log("USER_ACTION", f"Недостаточно средств для автопродления аренды номера +{ending.phone_number}")

                    # Обновляем статус уведомления
                    ending.is_notified = True
                    await ending.save(update_fields=["is_notified"])

                else:
                    # Создаем экземпляр API клиента и делаем запрос аренды
                    api_client = OnlineSimRentAPI()
                    try:
                        rent_result = await api_client.extend_rent_state(tzid=ending.rent_id, days=ending.days)
                    except Exception as e:
                        error_msg = f"Ошибка при продлении аренды через API: {str(e)}"
                        logger.opt(exception=e).error(f"{error_msg} (user_id={user_id})")

                        await bot.send_message(chat_id=user_id, text=f"Ошибка при аренде: {str(e)}", show_alert=True)
                        return

                    if rent_result is None:
                        no_numbers_msg = "Не удалось продлить аренду: нет доступных номеров"
                        logger.warning(f"{no_numbers_msg} (user_id={user_id}, phone={ending.phone_number})")

                        await bot.send_message(chat_id=user_id, text=bt.NOT_NUMBERS_ALERT, show_alert=True)
                        return

                    # Извлекаем данные активации
                    rent_id = int(rent_result.get("tzid", 0))
                    phone_number = rent_result.get("number", None)
                    minutes = int(rent_result.get("time", 0))

                    if phone_number is None:
                        no_numbers_msg = "Не удалось продлить аренду: отсутствует номер"
                        logger.warning(f"{no_numbers_msg} (user_id={user_id}, phone={ending.phone_number})")

                        await bot.send_message(chat_id=user_id, text=bt.NOT_NUMBERS_ALERT, show_alert=True)
                        return

                    # Добавляем запись об активации в базу данных
                    activation = await models.Rent.add_rent(
                        user=ending.user,
                        rent_id=ending.rent_id,
                        country=ending.country,
                        cost=ending.cost,
                        phone_number=ending.phone_number,
                        rent_expire_at=datetime.datetime.now(pytz.timezone("Europe/Moscow")).replace(microsecond=0)
                                       + datetime.timedelta(minutes=minutes),
                        is_notified=False,
                        days=ending.days,
                        autorenew=ending.autorenew
                    )

                    # Логируем успешное продление аренды
                    logger.bind(
                        user_id=user_id,
                        action="autorenew_rent_success"
                    ).log("USER_ACTION", f"Аренда номера +{activation.phone_number} продлена на {activation.days} дней. Списано: {activation.cost}₽")

                    # Отправляем пользователю сообщение о номере телефона
                    country = activation.country.name.strip()
                    flag = country_flags.get(country, "")
                    flag_and_country = f"{flag} {country}"

                    # Сообщение о количестве дней аренды
                    days_text = get_day_string(ending.days)

                    await bot.send_message(chat_id=user_id, text=bt.RENT_SUCCESS_MESSAGE.format(days=days_text))
                    await bot.send_message(chat_id=user_id,
                                           text=bt.NUMBER_INFO.format(country=flag_and_country, phone=activation.phone_number))


                    # Списываем средства с баланса пользователя
                    ending.user.balance -= ending.cost
                    await ending.user.save(update_fields=['balance'])

                    # Логируем событие списания средств за автопродление аренды
                    logger.bind(
                        user_id=ending.user.telegram_id,
                        action="autorenew_rent_payment"
                    ).log(
                        "USER_ACTION",
                        f"Списано {activation.cost}₽ за автопродление аренды номера +{activation.phone_number}. "
                        f"Новый баланс: {ending.user.balance}₽"
                    )

    except asyncio.CancelledError:
        pass
    except Exception as e:
        logger.opt(exception=e).error(f"Критическая ошибка в auto_renewal_of_rent(): {e}")


async def close_rent():
    """
    Обработка закрытия аренды номера срок действия которых заканчивается через 5 минут.
    """
    rents_closes = await models.Rent.close_rent_before_end()

    for rent in rents_closes:
        user_id = rent.user.telegram_id if rent.user else None

        # Обновляем статус аренды в базе данных
        rent.is_canceled = True
        await rent.save()
        # Используем API для отмены аренды
        api = OnlineSimRentAPI()  # Создаем экземпляр API
        try:
            response = await api.close_rent_num(tzid=rent.rent_id)  # Передаем ID операции аренды
            if response.get("response"):
                logger.bind(
                    user_id=user_id,
                    action="close_rent_success"
                ).log("USER_ACTION", f"Аренда номера {rent.phone_number} успешно закрыта")
                await bot.send_message(chat_id=rent.user.telegram_id, text=bt.NUMBER_RENTAL_CLOSED.format(number=rent.phone_number))
            else:
                # Если API вернул неизвестный ответ
                msg_text = f'Неизвестный ответ закрытия аренды {response}\nпользователь {rent.user.id} номер {rent.phone_number}'
                await send_coder(msg_text)
        except Exception as e:
            # Проверяем на конкретную ошибку API
            if str(e) == "Ошибка API: {'response': '1'}":
                await bot.send_message(chat_id=rent.user.telegram_id,
                                       text=bt.NUMBER_RENTAL_CLOSED.format(number=rent.phone_number))
                logger.bind(
                    user_id=user_id,
                    action="close_rent_already_closed"
                ).log("USER_ACTION", f"Срок аренды номера {rent.phone_number} истек")
            else:
                # Обработка остальных ошибок
                logger.bind(
                    user_id=rent.user.id,
                    action="close_rent_error"
                ).opt(exception=e).error(
                    f"Ошибка при закрытии аренды номера {rent.phone_number}: {str(e)}"
                )
                await bot.send_message(chat_id=rent.user.telegram_id,
                                       text=bt.NUMBER_RENTAL_CLOSED.format(number=rent.phone_number))


async def checking_inactive_rent():
    """
    Проверяем все активные аренды на сервисе и если по БД какая-то из них закрыта, тогда закрываем ее принудительно
    :return:
    """
    api_client = OnlineSimRentAPI()
    rent_state = await api_client.get_rent_state()
    # Проверяем, есть ли данные в 'list'
    if rent_state:
        for rent_info in rent_state:
            # Извлекаем tzid
            tzid = rent_info.get("tzid", 0)
            rent = await models.Rent.inactive_rent(tzid)
            if rent:
                rent.status = models.StatusResponse.STATUS_CANCEL
                await rent.save()
                try:
                    await api_client.close_rent_num(tzid)
                except Exception as e:
                    if str(e) == "Ошибка API: {'response': '1'}":
                        continue


async def balance_replenishment_notification(payment, service):
    user = payment.user
    msg_text = (
        f'💰💰💰\n'
        f'Пополнение {service}\n'
        f'пользователь {user.mention}\n'
        f'id {user.telegram_id}\n'
        f'сумма {payment.amount}\n'
        f'баланс: {user.balance}'
    )
    await send_coder(msg_text)

    # Уведомление рефереру
    if user.refer_id:
        referrer = await models.User.get_or_none(id=user.refer_id)
        if referrer and not referrer.disable_ref_notifications:
            bonus = round(payment.amount * 0.1)

            # === Кнопка для отключения уведомлений ===
            keyboard = types.InlineKeyboardMarkup(inline_keyboard=[
                [
                    types.InlineKeyboardButton(
                        text="🔕 Отключить уведомления",
                        callback_data=f"disable_notify:{referrer.telegram_id}"
                    )
                ]
            ])

            await bot.send_message(
                chat_id=referrer.telegram_id,
                text=(
                    "✅Партнерское вознаграждение\n"
                    f"├ Аккаунт: {user.telegram_id}\n"
                    f"├ Сумма зачисления: {payment.amount} ₽\n"
                    f"└ Ваш доход: {bonus}₽ (10%)"
                ),
                reply_markup=keyboard
            )

    logger.bind(
        user_id=user.telegram_id,
        action=f"top_up_balance_{service.lower()}"
    ).log("USER_ACTION", f"Пополнение баланса на {payment.amount}₽ через {service}, Баланс={user.balance}₽")


async def replenishment_error_message(payment, service):
    user = payment.user
    # msg_text = (
    #     f'❌ ошибка\n'
    #     f'{service} \n'
    #     f'пользователь {user.mention}\n'
    #     f'id {user.telegram_id}\n'
    #     f'сумма {payment.amount}\n'
    #     f'баланс: {user.balance}'
    # )
    # await send_coder(msg_text)
    #
    # logger.bind(
    #     user_id=user.telegram_id,
    #     action=f"top_up_balance_{service.lower()}_error"
    # ).error(f"Ошибка пополнения баланса через {service}, сумма: {payment.amount}₽, Баланс={user.balance}₽")


async def notice_of_arraignment(name_rent, activation, name):
    user = activation.user
    msg_text = (
        f'✅ {name_rent}\n'
        f'{name} \n'
        f'пользователь {user.mention}\n'
        f'id {user.telegram_id}\n'
        f'сумма аренды {activation.cost}\n'
        f'баланс: {user.balance}'
    )
    await send_coder(msg_text)

    logger.bind(
        user_id=user.telegram_id,
        action="rent_number"
    ).log("USER_ACTION", f"Аренда номера сервиса '{name}', Стоимость: {activation.cost}₽, Баланс={user.balance}₽")


async def referral_bonus_notification(payment, referrer, ref_sum):
    """
    Логгирует и уведомляет о начислении реферального бонуса.

    :param payment: объект платежа
    :param referrer: пользователь-реферал
    :param ref_sum: сумма бонуса
    """
    user = payment.user
    msg_text = (
        f'🧾 <b>Начислен реферальный бонус</b>\n'
        f'Реферер: {referrer.mention}\n'
        f'id: {referrer.telegram_id}\n'
        f'Пользователь: {user.mention} (id: {user.telegram_id})\n'
        f'Сумма платежа: {payment.amount}₽\n'
        f'Бонус: {ref_sum}₽\n'
        f'Текущий реф. баланс: {round(referrer.ref_balance)}₽'
    )
    await send_coder(msg_text)

    # Логгируем в системные логи
    logger.bind(
        user_id=referrer.telegram_id,
        action="referral_bonus"
    ).log(
        "REFERRAL_BONUS",
        f"Реферальный бонус {ref_sum}₽ за пользователя {user.telegram_id}, "
        f"платёж на сумму {payment.amount}₽"
    )

app\services\ping_scheduler.py
from app.dependencies import USER_BOT, bot

async def userbot_ping():
    await bot.send_message(chat_id=USER_BOT, text="ping")

app\services\qr_code.py
import asyncio
from io import BytesIO

import qrcode


def _generate_qr_code(link: str):
    qr = qrcode.QRCode(version=1, box_size=10, border=5)
    qr.add_data(link)
    bytes_io = BytesIO()
    qr.make_image().save(bytes_io, 'PNG')
    bytes_io.seek(0)
    return bytes_io


async def generate_qr_code(link: str):
    loop = asyncio.get_event_loop()
    return await loop.run_in_executor(None, _generate_qr_code, link)


app\services\set_bot_commands.py
from aiogram import types, Bot
from app.dependencies import ADMINS


async def set_default_commands(bot: Bot):
    user_commands = [
        types.BotCommand(command="start", description="Перезапустить"),
        types.BotCommand(command="get_sms", description="Принять SMS"),
        types.BotCommand(command="rent_number", description="Длительная аренда"),
        types.BotCommand(command="get_email", description="Принять Email"),
        types.BotCommand(command="account", description="Аккаунт")
    ]
    await bot.set_my_commands(user_commands,
                              scope=types.BotCommandScopeAllPrivateChats())

    admin_commands = [
        types.BotCommand(command="start", description="Перезапустить"),
        types.BotCommand(command="stat", description="Статистика"),
        types.BotCommand(command="send", description="Рассылка"),
        types.BotCommand(command="help_admin", description="Список доступных команд"),
    ]

    for chat_id in ADMINS:
        try:
            await bot.set_my_commands(admin_commands,
                                      scope=types.BotCommandScopeChat(chat_id=chat_id))

        except:
            pass


app\services\sms_activate_async.py
import json
from locale import currency
from loguru import logger
import aiohttp
from smsactivate.api import SMSActivateAPI
from yarl import URL


class SMSActivateAPIAsync(SMSActivateAPI):

    def __init__(self, api_key):
        super().__init__(api_key)
        self.__api_url = 'https://api.sms-activate.io/stubs/handler_api.php'
        self.__CODES = self._SMSActivateAPI__CODES

        self.__RENT_CODES = self._SMSActivateAPI__RENT_CODES

        self.__ERRORS = self._SMSActivateAPI__ERRORS

    def version(self):
        return "1.5"

    def check_error(self, response):
        if self.__ERRORS.get(response) == None:
            return False
        return True

    def get_error(self, error):
        return self.__ERRORS.get(error)

    def __debugLog(self, data):
        if self.debug_mode:
            print('[Debug]', data)

    def response(self, action, response):
        self.__debugLog(response)
        if self.check_error(response):
            return {"error": response, "message": self.get_error(response)}
        elif not str(response):
            return {"error": response, "message": "Server error, try again"}

        if action == "getNumbersStatus":
            result = json.loads(response)
            return result

        elif action == "getBalance":
            response = str(response[15:])
            result = {"balance": response}
            return result

        elif action == "getBalanceAndCashBack":
            response = str(response[15:])
            result = {"balance": response}
            return result

        elif action == "getNumber":
            # response = str(response[14:])
            # data = response.split(":")
            # activation_id = int(data[0])
            # phone = int(data[1])
            # result = {"activation_id": activation_id, "phone": phone}
            # return result

            result = json.loads(response)
            return result

        elif action == "getNumberV2":
            result = json.loads(response)
            return result

        elif action == "getMultiServiceNumber":
            result = json.loads(response)
            return result

        elif action == "getPrices":
            result = json.loads(response)
            return result

        elif action == "getCountries":
            result = json.loads(response)
            return result

        elif action == "getQiwiRequisites":
            result = json.loads(response)
            return result

        elif action == "getAdditionalService":
            response = str(response[11:])
            data = response.split(":")
            id = int(data[0])
            phone = int(data[1])
            result = {"id": id, "phone": phone}
            return result

        elif action == "getRentServicesAndCountries":
            result = json.loads(response)
            return result

        elif action == "getRentNumber":
            result = json.loads(response)
            return result

        elif action == "getRentStatus":
            result = json.loads(response)
            return result

        elif action == "setRentStatus":
            result = json.loads(response)
            return result
        elif action == "getRentList":
            result = json.loads(response)
            return result

        elif action == "continueRentNumber":
            result = json.loads(response)
            return result

        elif action == "getContinueRentPriceNumber":
            result = json.loads(response)
            return result

        elif action == "getTopCountriesByService":
            result = json.loads(response)
            return result

        elif action == "getIncomingCallStatus":
            result = json.loads(response)
            return result

        elif action == "getOperators":
            result = json.loads(response)
            return result

        elif action == "getActiveActivations":
            result = json.loads(response)
            return result

        elif action == "createTaskForCall":
            result = json.loads(response)
            if 'msg' in result:
                result['message'] = result.pop('msg')
            return result
        elif action == "getOutgoingCalls":
            result = json.loads(response)
            return result
        elif action == "getExtraActivation":
            # Пример обработки ответа для getExtraActivation
            response = str(response[15:])
            data = response.split(":")
            if data[0] == "ACCESS_NUMBER":
                activation_id = int(data[1])
                phone = int(data[2])
                result = {"activation_id": activation_id, "phone": phone}
            else:
                result = {"error": response}
            return result

        elif action == "checkExtraActivation":
            # Пример обработки ответа для checkExtraActivation
            result = json.loads(response)
            return result
        else:
            return response

    def activationStatus(self, status):
        return {"status": status, "message": self.__CODES.get(status)}

    def rentStatus(self, status):
        return self.__RENT_CODES.get(status)

    async def get_request(self, url, params):
        # Создаем URL с параметрами
        full_url = URL(url).with_query(params)

        # Логгируем полный URL запроса
        # logger.info(f"[SMSActivateAPI] Sending request: {full_url}")

        async with aiohttp.ClientSession() as session:
            async with session.get(str(full_url)) as response:
                response_text = await response.text()
                # logger.info(f"[SMSActivateAPI] Response: {response_text}")
                return response_text

    async def getBalance(self):
        payload = {'api_key': self.api_key, 'action': 'getBalance'}
        data = await self.get_request(self.__api_url, params=payload)
        return self.response("getBalance", data)

    async def getBalanceAndCashBack(self):
        payload = {'api_key': self.api_key, 'action': 'getBalanceAndCashBack'}
        data = await self.get_request(self.__api_url, params=payload)
        return self.response("getBalanceAndCashBack", data)

    async def getNumbersStatus(self, country=None, operator=None):
        payload = {'api_key': self.api_key, 'action': 'getNumbersStatus'}
        if country is not None:
            payload['country'] = country
        if operator:
            payload['operator'] = operator
        data = await self.get_request(self.__api_url, params=payload)
        return self.response("getNumbersStatus", data)

    async def getPricesVerification(self, service=None):
        payload = {'api_key': self.api_key, 'action': 'getPricesVerification'}
        if service:
            payload['service'] = service
        data = await self.get_request(self.__api_url, params=payload)
        return self.response("getPricesVerification", data)

    async def getNumber(self, service=None, forward=None, freePrice=None, maxPrice=None, phoneException=None,
                        operator=None, ref=None, country=None, verification=None):
        payload = {'api_key': self.api_key, 'action': 'getNumberV2'}
        if service:
            payload['service'] = service
        if forward:
            payload['forward'] = forward
        if freePrice:
            payload['freePrice'] = freePrice
        if maxPrice:
            payload['maxPrice'] = maxPrice
        if phoneException:
            payload['phoneException'] = phoneException
        if operator:
            payload['operator'] = operator
        if ref:
            payload['ref'] = ref
        if country is not None:
            payload['country'] = country
        if verification:
            payload['verification'] = verification

        data = await self.get_request(self.__api_url, params=payload)
        return self.response("getNumber", data)

    async def getNumberV2(self, service=None, forward=None, freePrice=None, maxPrice=None, phoneException=None,
                          operator=None,
                          ref=None, country=None, verification=None):
        payload = {'api_key': self.api_key, 'action': 'getNumberV2'}
        if service:
            payload['service'] = service
        if forward:
            payload['forward'] = forward
        if freePrice:
            payload['freePrice'] = freePrice
        if maxPrice:
            payload['maxPrice'] = maxPrice
        if phoneException:
            payload['phoneException'] = phoneException
        if operator:
            payload['operator'] = operator
        if ref:
            payload['ref'] = ref
        if country is not None:
            payload['country'] = country
        if verification:
            payload['verification'] = verification

        data = await self.get_request(self.__api_url, params=payload)
        return self.response("getNumberV2", data)

    async def getMultiServiceNumber(self, service=None, forward=None, operator=None, ref=None, country=None):
        payload = {'api_key': self.api_key, 'action': 'getMultiServiceNumber'}
        if service:
            payload['multiService'] = service
        if forward:
            payload['forward'] = forward
        if operator:
            payload['operator'] = operator
        if ref:
            payload['ref'] = ref
        if country is not None:
            payload['country'] = country
        data = await self.get_request(self.__api_url, params=payload)
        return self.response("getMultiServiceNumber", data)

    async def setStatus(self, id=None, forward=None, status=None, ):
        # print(f'Setting status: id: {id}, forward: {forward}, status: {status}')
        payload = {'api_key': self.api_key, 'action': 'setStatus'}
        if id:
            payload['id'] = id
        if forward:
            payload['forward'] = forward
        if status:
            payload['status'] = status
        data = await self.get_request(self.__api_url, params=payload)
        return self.response("setStatus", data)

    async def getStatus(self, id=None):
        payload = {'api_key': self.api_key, 'action': 'getStatus'}
        if id:
            payload['id'] = id
        data = await self.get_request(self.__api_url, params=payload)
        return self.response("getStatus", data)

    async def getFullSms(self, id=None):
        payload = {'api_key': self.api_key, 'action': 'getFullSms'}
        if id:
            payload['id'] = id
        data = await self.get_request(self.__api_url, params=payload)
        return self.response("getFullSms", data)

    async def getPrices(self, service=None, country=None):
        payload = {'api_key': self.api_key, 'action': 'getPrices'}
        if service:
            payload['service'] = service
        if country is not None:
            payload['country'] = country
        data = await self.get_request(self.__api_url, params=payload)
        price = self.response("getPrices", data)
        return price

    async def getCountries(self):
        payload = {'api_key': self.api_key, 'action': 'getCountries'}
        data = await self.get_request(self.__api_url, params=payload)
        return self.response("getCountries", data)

    async def get_top_countries_by_service(self, service, free_price=True):
        payload = {
            'api_key': self.api_key,
            'action': 'getTopCountriesByService',
            'service': service,
            'freePrice': 'true' if free_price else 'false',
            # 'currency': '643' # присылает в рублях
        }
        data = await self.get_request(self.__api_url, params=payload)
        top_countries = self.response("getTopCountriesByService", data)
        return top_countries

    async def getAdditionalService(self, service=None, id=None):
        payload = {'api_key': self.api_key, 'action': 'getAdditionalService'}
        if service:
            payload['service'] = service
        if id:
            payload['id'] = id
        data = await self.get_request(self.__api_url, params=payload)
        return self.response("getAdditionalService", data)

    async def getQiwiRequisites(self):
        payload = {'api_key': self.api_key, 'action': 'getQiwiRequisites'}
        data = await self.get_request(self.__api_url, params=payload)
        return self.response("getQiwiRequisites", data)

    async def getRentServicesAndCountries(self, time=None, operator=None, country=None):
        payload = {'api_key': self.api_key, 'action': 'getRentServicesAndCountries'}
        if time:
            payload['time'] = time
        if operator:
            payload['operator'] = operator
        if country is not None:
            payload['country'] = country

        data = await self.get_request(self.__api_url, params=payload)
        return self.response("getRentServicesAndCountries", data)

    async def getRentNumber(self, service=None, time=None, operator=None, country=None, url=None):
        payload = {'api_key': self.api_key, 'action': 'getRentNumber'}
        if service:
            payload['service'] = service
        if time:
            payload['time'] = time
        if operator:
            payload['operator'] = operator
        if country is not None:
            payload['country'] = country
        if url:
            payload['url'] = url

        data = await self.get_request(self.__api_url, params=payload)
        return self.response("getRentNumber", data)

    async def getRentStatus(self, id=None):
        payload = {'api_key': self.api_key, 'action': 'getRentStatus'}
        if id:
            payload['id'] = id

        data = await self.get_request(self.__api_url, params=payload)
        return self.response("getRentStatus", data)

    async def setRentStatus(self, id=None, status=None):
        payload = {'api_key': self.api_key, 'action': 'setRentStatus'}
        if id:
            payload['id'] = id
        if status:
            payload['status'] = status

        data = await self.get_request(self.__api_url, params=payload)
        return self.response("setRentStatus", data)

    async def getRentList(self):
        payload = {'api_key': self.api_key, 'action': 'getRentList'}
        data = await self.get_request(self.__api_url, params=payload)
        return self.response("getRentList", data)

    async def continueRentNumber(self, id=None, time=None):
        payload = {'api_key': self.api_key, 'action': 'continueRentNumber'}
        if id:
            payload['id'] = id
        if time:
            payload['rent_time'] = time

        data = await self.get_request(self.__api_url, params=payload)
        return self.response("continueRentNumber", data)

    async def getContinueRentPriceNumber(self, id=None):
        payload = {'api_key': self.api_key, 'action': 'getContinueRentPriceNumber'}
        if id:
            payload['id'] = id

        data = await self.get_request(self.__api_url, params=payload)
        return self.response("getContinueRentPriceNumber", data)

    async def getTopCountriesByService(self, service=None, freePrice=None):
        payload = {'api_key': self.api_key, 'action': 'getTopCountriesByService'}
        if service:
            payload['service'] = service
        if freePrice:
            payload['freePrice'] = freePrice

        data = await self.get_request(self.__api_url, params=payload)
        return self.response("getTopCountriesByService", data)

    async def getIncomingCallStatus(self, id=None):
        payload = {'api_key': self.api_key, 'action': 'getIncomingCallStatus'}
        if id:
            payload['activationId'] = id

        data = await self.get_request(self.__api_url, params=payload)
        return self.response("getIncomingCallStatus", data)

    async def getOperators(self, country=None):
        payload = {'api_key': self.api_key, 'action': 'getOperators'}
        if country is not None:
            payload['country'] = country

        data = await self.get_request(self.__api_url, params=payload)
        return self.response("getOperators", data)

    async def getActiveActivations(self):
        payload = {'api_key': self.api_key, 'action': 'getActiveActivations'}
        data = await self.get_request(self.__api_url, params=payload)
        return self.response("getActiveActivations", data)

    async def createTaskForCall(self, activationId):
        payload = {'api_key': self.api_key, 'action': 'createTaskForCall'}
        payload['activationId'] = activationId
        data = await self.get_request(self.__api_url, params=payload)
        return self.response("createTaskForCall", data)

    async def getOutgoingCalls(self, activationId=None, date=None):
        payload = {'api_key': self.api_key, 'action': 'getOutgoingCalls'}
        if activationId is not None:
            payload['activationId'] = activationId
        if date is not None:
            payload['date'] = date
        data = await self.get_request(self.__api_url, params=payload)
        return self.response("getOutgoingCalls", data)

    async def getExtraActivation(self, activationId):
        """
        Дополнительная активация номера.

        Если вы совершили успешную активацию на номере, то вы можете совершить её повторно.

        Параметры:
        - activationId: ID родительской активации

        Возвращает:
        - JSON объект с результатом активации или ошибкой
        """
        # Формируем payload с необходимыми параметрами
        payload = {'api_key': self.api_key, 'action': 'getExtraActivation', 'activationId': activationId}

        # Выполняем асинхронный GET запрос к API
        data = await self.get_request(self.__api_url, params=payload)

        # Обрабатываем и возвращаем ответ API
        return self.response("getExtraActivation", data)

    async def checkExtraActivation(self, activationId):
        """
        Получить цену за дополнительную активацию номера.

        Вы можете узнать доступность номера для совершения дополнительной активации и получить её стоимость.

        Параметры:
        - activationId: ID родительской активации

        Возвращает:
        - JSON объект с информацией о стоимости и доступности активации или ошибкой
        """
        # Формируем payload с необходимыми параметрами
        payload = {'api_key': self.api_key, 'action': 'checkExtraActivation', 'activationId': activationId}

        # Выполняем асинхронный GET запрос к API
        data = await self.get_request(self.__api_url, params=payload)

        # Обрабатываем и возвращаем ответ API
        return self.response("checkExtraActivation", data)


app\services\sms_receive.py
import asyncio
from math import ceil
import json
from app import dependencies
from app.db import models
from app.services.bot_texts import DOLLAR_SMS_ACTIVATE
from app.services.sms_activate_async import SMSActivateAPIAsync

from loguru import logger

class SmsReceive:
    """
    Класс для взаимодействия с API SMSActivate для получения и управления номерами телефонов.
    """

    def __init__(self):
        """
        Инициализация класса SmsReceive.
        """
        # Создаем экземпляр SMSActivateAPIAsync с API ключом
        self.sa = SMSActivateAPIAsync(api_key=dependencies.SMS_ACTIVATE_KEY)
        # self.sa = SMSActivateAPIAsync(api_key='8b16d24393b6c2256f458502b4A0A015')
        self.sa.debug_mode = False

    async def get_balance(self):
        """
        Получает баланс аккаунта в SMSActivate.

        :return: Баланс аккаунта.
        """
        return await self.sa.getBalance()

    async def get_countries(self):
        """
        Получает список стран, поддерживаемых SMSActivate.

        :return: Список стран с их идентификаторами и названиями.
        """
        countries_data = await self.sa.getCountries()
        countries = []
        for country_id, country_data in countries_data.items():
            countries.append({
                'id': country_id,
                'name': country_data['rus']
            })
            # Используем asyncio.sleep(0) для предотвращения блокировки
            await asyncio.sleep(0)

        return countries

    async def get_services(self):
        """
        Получает список сервисов и стран, поддерживаемых для аренды номеров.

        :return: Список сервисов с их кодами и именами для поиска.
        """
        services_data = await self.sa.getRentServicesAndCountries()
        services = []
        for service_code, service_data in services_data['services'].items():
            services.append({
                'code': service_code,
                'search_names': service_data['search_name']
            })
            await asyncio.sleep(0)

        return services

    async def get_services_by_country_id(self, country_id: int):
        """
        Получает список сервисов для указанной страны.

        :param country_id: Идентификатор страны.
        :return: Список сервисов с их кодами, стоимостью и количеством доступных номеров.
        """
        services_data = await self.sa.getPrices(country=country_id)
        services = []
        for service_code, service_data in services_data[str(country_id)].items():
            # Округляем стоимость до ближайшего целого числа, умноженного на процент, который накидывает сервис
            cost = ceil(float(service_data['cost']) * DOLLAR_SMS_ACTIVATE)
            services.append({
                'code': service_code,
                'cost': cost,
                'count': service_data['count']
            })
            # Используем asyncio.sleep(0) для предотвращения блокировки
            await asyncio.sleep(0)

        return services

    async def get_services_by_service_code(self, service_code):
        """
        Получает список стран для указанного сервиса.

        :param service_code: Краткое наименование сервиса
        :return: Список стран, стоимостью и количеством доступных номеров.
        """
        services_data = await self.sa.getPrices(service=service_code)
        services = []
        for country_id, services_for_country in services_data.items():
            # Проверяем, существует ли код сервиса в текущей стране
            if service_code in services_for_country:
                service_data = services_for_country[service_code]
                services.append({
                    'service_code': service_code,
                    'country': country_id,
                    'count': service_data['count'],
                    'price': service_data['cost']
                })
            # Используем asyncio.sleep(0) для предотвращения блокировки
            await asyncio.sleep(0)

        return services

    async def get_verification_services(self, service_code=None):
        """
        Получает список стран и цен для верификации по указанному сервису.

        :param service_code: Код сервиса (необязательный).
        :return: Список стран с их количеством и ценой для верификации.
        """
        services_data = await self.sa.getPricesVerification(service=service_code)
        # Преобразуем JSON-строку в словарь
        services_data = json.loads(services_data)

        services = []

        for service_code, service_data in services_data.items():
            for country, details in service_data.items():
                services.append({
                    'service_code': service_code,
                    'country': country,
                    'count': details['count'],
                    'price': details['price']
                })
                await asyncio.sleep(0)

        return services

    async def get_top_country(self, service):
        """
        Получает список топ стран по сервису.

        :return:
        """
        try:
            services_data = await self.sa.get_top_countries_by_service(service)
            return services_data
        except Exception:
            return None

    async def get_phone_number(self, country_id: int, service_code: str, max_price: float=None):
        """
        Получает номер телефона для указанной страны и сервиса.

        :param country_id: Идентификатор страны.
        :param service_code: Код сервиса.
        :param max_price: Максимальная сумма.
        :return: Данные о номере телефона.
        """
        return await self.sa.getNumber(service=service_code, country=country_id, maxPrice=max_price)

    async def get_activation_status(self, activation_id: int):
        """
        Получает статус активации по идентификатору активации.

        :param activation_id: Идентификатор активации.
        :return: Статус активации.
        """
        return await self.sa.getStatus(id=activation_id)

    async def set_activation_status(self, activation_id: int, status: models.ActivationCode):
        """
        Устанавливает статус активации по идентификатору активации.

        :param activation_id: Идентификатор активации.
        :param status: Новый статус активации.
        :return: Результат установки статуса.
        """
        return await self.sa.setStatus(id=activation_id, status=status.value)

    async def get_number_status(self):
        """
        Получает статус номеров.

        :return: Статус номеров.
        """
        return await self.sa.getNumbersStatus()

app\services\stars_pay.py
""" Оплата Telegram Stars """

from aiogram.types import LabeledPrice
from aiogram_dialog import DialogManager, StartMode
from aiogram.utils.keyboard import InlineKeyboardBuilder
from aiogram import types
from aiogram_dialog.widgets.kbd import Button
from aiogram.types import PreCheckoutQuery
from app.services.bot_texts import PAYMENT
from tortoise import timezone
from math import floor
from app.db import models
from loguru import logger
from app.dialogs.personal_cabinet.states import PersonalMenu
from aiogram.exceptions import TelegramBadRequest

from app.services.periodic_tasks import send_coder, balance_replenishment_notification


def payment_keyboard(amount):
    builder = InlineKeyboardBuilder()
    builder.button(text=f"Оплатить {amount} ⭐️", pay=True)

    return builder.as_markup()


async def send_invoice_handler_stars(c: types.CallbackQuery, button: Button, manager: DialogManager):
    ctx = manager.current_context()
    amount = ctx.dialog_data.get('stars', 0)
    stars = int(round(amount) / 2)
    prices = [LabeledPrice(label="XTR", amount=stars)]

    try:
        await c.message.answer_invoice(
            title=PAYMENT,
            description=f"💰 Сумма: {amount} ₽",
            prices=prices,
            provider_token="",
            payload="payment_in_stars",
            currency="XTR",
            reply_markup=payment_keyboard(stars),
        )
        await manager.start(PersonalMenu.user_info, mode=StartMode.RESET_STACK)
    except TelegramBadRequest as e:
        if "total price must be positive" in str(e):
            await c.message.answer(
                "К сожалению, у вас недостаточно Telegram Stars для этой операции. Пожалуйста, пополните баланс и попробуйте снова.")
        else:
            # Обработка других потенциальных ошибок TelegramBadRequest.
            await c.message.answer(
                "Произошла ошибка при создании счета. Пожалуйста, попробуйте позже или обратитесь в поддержку.")

        # При желании вы можете зарегистрировать ошибку в целях отладки.
        logger.error(f"Ошибка в send_invoice_handler_stars: {e}")

    # Убедитесь, что мы всегда отвечаем на запрос обратного вызова, чтобы избежать состояния «загрузки» в пользовательском интерфейсе.
    await c.answer()


async def pre_checkout_handler(pre_checkout_query: PreCheckoutQuery):
    """
    Обрабатывает PreCheckoutQuery (предварительный запрос на оплату) от пользователя.

    Этот обработчик вызывается при получении предварительного запроса на оплату.
    Он выполняет следующие действия:
    1. Получает пользователя по его идентификатору.
    2. Извлекает сумму последнего платежа пользователя.
    3. Сохраняет информацию о платеже в базу данных.
    4. Отвечает на предварительный запрос с положительным результатом.

    :param pre_checkout_query: Объект PreCheckoutQuery, содержащий информацию о запросе на оплату.
    :param dialog_manager: DialogManager
    """
    # Получаем объект пользователя по его Telegram ID
    user = await models.User.get_user(pre_checkout_query.from_user.id)
    # Извлекаем сумму последнего платежа пользователя
    amount = await models.Payment.get_last_payment_amount(user.id)
    # Сохраняем информацию о платеже в базу данных
    await save_payment_to_database(user, amount)
    # Отправляем подтверждение успешного предварительного запроса на оплату
    await pre_checkout_query.answer(ok=True)


async def save_payment_to_database(user, amount):
    # Проверяем, есть ли у пользователя активный бонус и его срок не истек.
    if user.bonus_end_at and user.bonus_end_at > timezone.now():
        # Если бонус активен, увеличиваем сумму платежа на 10%.
        amount = floor(amount * 1.1)
        # Сбрасываем срок действия бонуса.
        user.bonus_end_at = None

    payment = await models.Payment.create_payment(
        user=user,
        method=models.PaymentMethod.STARS,
        amount=amount,
        continue_data=None
    )
    payment.is_success = True
    await payment.save()
    # Увеличиваем баланс пользователя на сумму платежа (с учетом бонуса, если он был).
    user.balance += amount
    msg_text = (f'💲Пополнение stars⭐️\n'
                f'пользователь {user.mention}\n'
                f'id {user.telegram_id}\n'
                f'сумма {amount}\n'
                f'баланс: {user.balance}')
    await send_coder(msg_text)
    await user.save()



app\services\subscribe_middleware.py
from aiogram import BaseMiddleware
from typing import Callable


class SubscribeMiddleware(BaseMiddleware):
    def __init__(self):
        pass

    async def __call__(
            self,
            handler: Callable[[TelegramObject, Dict[str, Any]], Awaitable[Any]],
            event: TelegramObject,
            data: Dict[str, Any],
    ) -> Any:
        # Ждём указанное количество секунд и передаём управление дальше по цепочке
        # (это может быть как хэндлер, так и следующая мидлварь)
        await asyncio.sleep(self.sleep_sec)
        result = await handler(event, data)
        # Если в хэндлере сделать return, то это значение попадёт в result
        print(f"Handler was delayed by {self.sleep_sec} seconds")
        return result

app\services\temp_mail.py
# import asyncio
# import json
# import random
# from dataclasses import dataclass
# from string import ascii_lowercase, ascii_uppercase, digits
# from typing import List, Dict
#
# from aiohttp import ClientSession
#
#
# async def post_request(url, headers: dict, data=None):
#     async with ClientSession(headers=headers) as session:
#         async with session.post(url=url, data=data) as response:
#             return response.status, json.loads(await response.text())
#
#
# async def get_request(url, headers: dict):
#     async with ClientSession(headers=headers) as session:
#         async with session.get(url=url) as response:
#             return response.status, json.loads(await response.text())
#
#
# async def delete_request(url, headers: dict):
#     async with ClientSession(headers=headers) as session:
#         async with session.delete(url=url) as response:
#             return response.status
#
#
# class Account:
#     def __init__(self, id, address, password):
#         self.auth_headers = None
#         self.id_ = id
#         self.address = address
#         self.password = password
#         self.api_address = MailTm.api_address
#
#     async def set_jwt(self):
#         # Set the JWT
#         jwt = await MailTm._make_account_request("token",
#                                                  self.address, self.password)
#         self.auth_headers = {
#             "accept": "application/ld+json",
#             "Content-Type": "application/json",
#             "Authorization": "Bearer {}".format(jwt["token"])
#         }
#
#     async def get_messages(self, page=1):
#         r = await get_request("{}/messages?page={}".format(self.api_address, page),
#                               headers=self.auth_headers)
#
#         status_code = r[0]
#         json_data = r[1]
#         if status_code != 200:
#             raise Exception
#
#         messages = []
#         for message_data in json_data["hydra:member"]:
#             r = await get_request(
#                 f"{self.api_address}/messages/{message_data['id']}", headers=self.auth_headers)
#             if r[0] != 200:
#                 raise Exception
#
#             full_message_json = r[1]
#             text = full_message_json["text"]
#             html = full_message_json["html"]
#
#             messages.append(Message(
#                 message_data["id"],
#                 message_data["from"],
#                 message_data["to"],
#                 message_data["subject"],
#                 message_data["intro"],
#                 text,
#                 html,
#                 message_data))
#
#         return messages
#
#     async def delete_account(self):
#         r = await delete_request("{}/accounts/{}".format(self.api_address,
#                                                          self.id_), headers=self.auth_headers)
#
#         return r == 204
#
#     async def _get_existing_messages_id(self) -> List[int]:
#         old_messages = await self.get_messages()
#         return list(map(lambda m: m.id_, old_messages))
#
#
#
#
# class MailTm:
#     api_address = "https://api.mail.tm"
#
#     async def _get_domains_list(self):
#         headers = None
#         while True:
#             r = await get_request("{}/domains".format(self.api_address), headers=headers)
#             if r[0] == 200:
#                 response = r[1]
#                 domains = list(map(lambda x: x["domain"], response["hydra:member"]))
#                 return domains
#
#             await asyncio.sleep(2)
#
#     async def _generate_email(self, domain: str = None):
#         if not domain:
#             domains = await self._get_domains_list()
#             domain = random.choice(domains)
#
#         return ''.join(random.choices(ascii_lowercase, k=10)) + '@' + domain
#
#     def _generate_password(self, len: int = 8):
#         return ''.join(random.choices(ascii_uppercase + ascii_lowercase + digits, k=len))
#
#     async def create_account(self, password=None):
#         """Create and return a new account."""
#         address = await self._generate_email()
#         if not password:
#             password = self._generate_password(8)
#         response = await self._make_account_request("accounts", address, password)
#         account = Account(response["id"], response["address"], password)
#         await account.set_jwt()
#         return account
#
#     @staticmethod
#     async def _make_account_request(endpoint, address, password):
#         account = {"address": address, "password": password}
#         headers = {
#             "accept": "application/ld+json",
#             "Content-Type": "application/json"
#         }
#         r = await post_request("{}/{}".format(MailTm.api_address, endpoint),
#                                data=json.dumps(account), headers=headers)
#
#         if r[0] not in [200, 201]:
#             raise Exception
#
#         return r[1]

import json
import re
from dataclasses import dataclass

import aiohttp


@dataclass
class Message:
    id_: int
    from_: str
    subject: str
    text: str


class TempMail:
    def __init__(self):
        self.base_url = 'https://www.1secmail.com/api/v1/?'

    async def _response(self, url):
        async with aiohttp.ClientSession() as session:
            async with session.get(url) as response:
                return await response.text()

    async def generate_email(self):
        url = self.base_url + 'action=genRandomMailbox&count=1'
        response = await self._response(url)
        # print(f'123R: {response}', flush=True)
        email_list = json.loads(response)
        if len(email_list) > 0:
            return email_list[0]

    async def get_message_ids(self, login: str, domain: str):
        url = self.base_url + f'action=getMessages&login={login}&domain={domain}'
        response = await self._response(url)
        # print(f'123R: {response}', flush=True)
        messages = json.loads(response)
        message_ids = [message['id'] for message in messages[:5]]
        return message_ids

    def clean_html_tags(self, text):
        clean_text = re.sub(r'<(?!\/?(b|i|a)\b)[^>]*>', '', text)  # Удаляем все теги, кроме b, i, a
        clean_text = clean_text.replace('<br>', '\n')  # Заменяем <br> на символ новой строки
        return clean_text

    async def read_message(self, login: str, domain: str, message_id: int):
        url = self.base_url + f'action=readMessage&login={login}&domain={domain}&id={message_id}'
        data = json.loads(await self._response(url))
        return Message(
            id_=data['id'],
            from_=data['from'],
            subject=data['subject'],
            text=self.clean_html_tags(data['htmlBody'])
        )


app\services\widgets.py
from aiogram_dialog.widgets.kbd import ScrollingGroup


class ScrollingGroupModified(ScrollingGroup):
    pass


app\services\yoomoney_payment.py
from app.dependencies import YOOMONEY_TOKEN, YOOMONEY_RECEIVER
from app.services.yoomoney import Quickpay, Client
from loguru import logger


async def create_yoomoney_url(sum_amount, label):
    """
    Создает URL для оплаты через ЮMoney с заданной меткой и суммой.

    Аргументы:
        label (str): Метка платежа для отслеживания транзакции.
        sum_amount (float): Сумма платежа в рублях.

    Возвращает:
        str: URL для перенаправления пользователя на страницу оплаты ЮMoney.

    Исключения:
        Exception: Обрабатываются любые ошибки, возникающие при создании платежа.
    """
    try:
        quickpay = Quickpay(
            receiver=YOOMONEY_RECEIVER,  # Номер кошелька получателя
            quickpay_form="shop",  # Форма платежа (настраиваемое поле)
            targets="Email Fast📨",  # Цель платежа (отображается на странице оплаты)
            paymentType="",  # Способ оплаты (в данном случае Сбербанк)
            sum=sum_amount,  # Сумма платежа
            label=label  # Метка платежа для идентификации транзакции
        )
        return quickpay.redirected_url  # Возвращает ссылку для оплаты
    except Exception as e:
        # Логирование ошибки и возврат None, если что-то пошло не так
        logger.error(f"Ошибка при создании платежа: {e}")
        return None


async def check_payment_status(label):
    """
    Проверяет статус платежа в ЮMoney по метке.

    Аргументы:
        label (str): Метка платежа, по которой проверяется статус транзакции.

    Возвращает:
        bool: True, если найден успешный платеж по данной метке, иначе False.

    Исключения:
        Exception: Обрабатываются ошибки при получении истории операций.
    """
    try:
        client = Client(YOOMONEY_TOKEN)  # Создаем клиента ЮMoney с использованием токена
        history = client.operation_history(label=label)  # Получаем историю операций по метке

        # Проходим по всем операциям в истории и проверяем статус
        for operation in history.operations:
            if operation.status == 'success':  # Если операция успешна
                return True  # Возвращаем True, если найден успешный платеж
        return False  # Возвращаем False, если успешных платежей не найдено
    except Exception as e:
        # Логирование ошибки и возврат False, если произошла ошибка
        logger.error(f"Ошибка при проверке статуса платежа: {e}")
        return False


app\services\__init__.py


app\services\api_yoomoney\client.py
import requests
import json
from typing import TYPE_CHECKING, Callable, Dict, List, Optional, Union
from datetime import datetime

from app.services.api_yoomoney import (
    Account,
    History,
    OperationDetails,
)


class Client:
    def __init__(self,
                 token: str = None,
                 base_url: str = None,
                 ):

        if base_url is None:
            self.base_url = "https://yoomoney.ru/api/"

        if token is not None:
            self.token = token



    def account_info(self):
        method = "account-info"
        return Account(base_url=self.base_url,
                       token=self.token,
                       method=method
                       )

    def operation_history(self,
                          type: str = None,
                          label: str = None,
                          from_date: datetime = None,
                          till_date: datetime = None,
                          start_record: str = None,
                          records: int = None,
                          details: bool = None,
                          ):
        method = "operation-history"
        return History(base_url=self.base_url,
                       token=self.token,
                       method=method,
                       type=type,
                       label=label,
                       from_date=from_date,
                       till_date=till_date,
                       start_record=start_record,
                       records=records,
                       details=details,
                       )

    def operation_details(self,
                          operation_id: str
                          ):
        method = "operation-details"
        return OperationDetails(base_url=self.base_url,
                                token=self.token,
                                method=method,
                                operation_id=operation_id,
                                )

app\services\api_yoomoney\exceptions.py


class YooMoneyError(Exception):
    """Basic class"""


class InvalidToken(YooMoneyError):

    message = "Token is not valid, or does not have the appropriate rights"
    def __init__(self, ):
        super().__init__(self.message)


class IllegalParamType(YooMoneyError):

    message = "Invalid parameter value 'type'"
    def __init__(self, ):
        super().__init__(self.message)

class IllegalParamStartRecord(YooMoneyError):

    message = "Invalid parameter value 'start_record'"
    def __init__(self, ):
        super().__init__(self.message)


class IllegalParamRecords(YooMoneyError):

    message = "Invalid parameter value 'records'"
    def __init__(self, ):
        super().__init__(self.message)

class IllegalParamLabel(YooMoneyError):

    message = "Invalid parameter value 'label'"
    def __init__(self, ):
        super().__init__(self.message)

class IllegalParamFromDate(YooMoneyError):

    message = "Invalid parameter value 'from_date'"
    def __init__(self, ):
        super().__init__(self.message)


class IllegalParamTillDate(YooMoneyError):

    message = "Invalid parameter value 'till_date'"
    def __init__(self, ):
        super().__init__(self.message)

class IllegalParamOperationId(YooMoneyError):

    message = "Invalid parameter value 'operation_id'"
    def __init__(self, ):
        super().__init__(self.message)

class TechnicalError(YooMoneyError):

    message = "Technical error, try calling the operation again later"
    def __init__(self, ):
        super().__init__(self.message)

class InvalidRequest(YooMoneyError):

    message = "Required query parameters are missing or have incorrect or invalid values"
    def __init__(self, ):
        super().__init__(self.message)

class UnauthorizedClient(YooMoneyError):

    message = "Invalid parameter value 'client_id' or 'client_secret', or the application" \
              " does not have the right to request authorization (for example, YooMoney blocked it 'client_id')"
    def __init__(self, ):
        super().__init__(self.message)

class InvalidGrant(YooMoneyError):

    message = "In issue 'access_token' denied. YuMoney did not issue a temporary token, " \
              "the token is expired, or this temporary token has already been issued " \
              "'access_token' (repeated request for an authorization token with the same temporary token)"
    def __init__(self, ):
        super().__init__(self.message)

class EmptyToken(YooMoneyError):

    message = "Response token is empty. Repeated request for an authorization token"
    def __init__(self, ):
        super().__init__(self.message)

app\services\api_yoomoney\__init__.py
from .account.account import Account
from .account.balance_details import BalanceDetails

from .operation.operation import Operation

from app.services.api_yoomoney.operation_details.operation_details import OperationDetails
from app.services.api_yoomoney.operation_details.digital_bonus import DigitalBonus
from app.services.api_yoomoney.operation_details.digital_product import DigitalProduct
from app.services.api_yoomoney.operation_details.digital_good import DigitalGood

from .history.history import History

from .authorize.authorize import Authorize

from .quickpay.quickpay import Quickpay

from .client import Client

__all__ = [
    'Client',
    'Account',
    'BalanceDetails',
    'Operation',
    'History',
    'Authorize',
    "OperationDetails",
    "DigitalBonus",
    "DigitalProduct",
    "DigitalGood",
    "Quickpay",
    ]

app\services\api_yoomoney\account\account.py
import requests
import json
from typing import TYPE_CHECKING, Optional, List

from app.services.api_yoomoney.account.balance_details import BalanceDetails
from app.services.api_yoomoney.account.card import Card
from app.services.api_yoomoney.exceptions import InvalidToken

class Account:

    def __init__(self,
                 base_url: str = None,
                 token: str = None,
                 method: str = None,

                 ):

        self.__private_method = method

        self.__private_base_url = base_url
        self.__private_token = token

        data = self._request()

        if len(data) != 0:
            self.account = data['account']
            self.balance = data['balance']
            self.currency = data['currency']
            self.account_status = data['account_status']
            self.account_type = data['account_type']

            self.balance_details = BalanceDetails()
            if 'balance_details' in data:
                if 'available' in data['balance_details']:
                    self.balance_details.available = float(data['balance_details']['available'])
                if 'blocked' in data['balance_details']:
                    self.balance_details.blocked = float(data['balance_details']['blocked'])
                if 'debt' in data['balance_details']:
                    self.balance_details.debt = float(data['balance_details']['debt'])
                if 'deposition_pending' in data['balance_details']:
                    self.balance_details.deposition_pending = float(data['balance_details']['deposition_pending'])
                if 'total' in data['balance_details']:
                    self.balance_details.total = float(data['balance_details']['total'])
                if 'hold' in data['balance_details']:
                    self.balance_details.hold = float(data['balance_details']['hold'])

            self.cards_linked = []
            if 'cards_linked' in data:
                for card_linked in data['cards_linked']:
                    card = Card(pan_fragment=card_linked['pan_fragment'], type=card_linked['type'])
                    self.cards_linked.append(card)
        else:
            raise InvalidToken()

    def _request(self):

        access_token = str(self.__private_token)
        url = self.__private_base_url + self.__private_method

        headers = {
            'Authorization': 'Bearer ' + str(access_token),
            'Content-Type': 'application/x-www-form-urlencoded'
        }

        response = requests.request("POST", url, headers=headers)

        return response.json()


app\services\api_yoomoney\account\balance_details.py


class BalanceDetails:
    def __init__(self,
                 total: float = None,
                 available: float = None,
                 deposition_pending: float = None,
                 blocked: float = None,
                 debt: float = None,
                 hold: float = None,
                 ):

        self.total = total

        self.available = available

        self.deposition_pending = deposition_pending

        self.blocked = blocked

        self.debt = debt

        self.hold = hold






app\services\api_yoomoney\account\card.py



class Card:
    def __init__(self,
                 pan_fragment: str = None,
                 type: str = None,
                 ):
        self.pan_fragment = pan_fragment
        self.type = type



app\services\api_yoomoney\account\__init__.py


app\services\api_yoomoney\authorize\authorize.py
from typing import List
import requests

from app.services.api_yoomoney.exceptions import (
    InvalidRequest,
    UnauthorizedClient,
    InvalidGrant,
    EmptyToken
    )

class Authorize:
    def __init__(
            self,
            client_id: str,
            redirect_uri: str,
            scope: List[str]
                  ):

        url = "https://yoomoney.ru/oauth/authorize?client_id={client_id}&response_type=code" \
              "&redirect_uri={redirect_uri}&scope={scope}".format(client_id=client_id,
                                                                  redirect_uri=redirect_uri,
                                                                  scope='%20'.join([str(elem) for elem in scope]),
                                                                  )

        headers = {
            'Content-Type': 'application/x-www-form-urlencoded'
        }

        response = requests.request("POST", url, headers=headers)

        if response.status_code == 200:
            print("Visit this website and confirm the application authorization request:")
            print(response.url)

        code = str(input("Enter redirected url (https://yourredirect_uri?code=XXXXXXXXXXXXX) or just code: "))
        try:
            code = code[code.index("code=") + 5:].replace(" ","")
        except:
            pass

        url = "https://yoomoney.ru/oauth/token?code={code}&client_id={client_id}&" \
              "grant_type=authorization_code&redirect_uri={redirect_uri}".format(code=str(code),
                                                                                 client_id=client_id,
                                                                                 redirect_uri=redirect_uri,
                                                                                 )

        response = requests.request("POST", url, headers=headers)

        if "error" in response.json():
            error = response.json()["error"]
            if error == "invalid_request":
                raise InvalidRequest()
            elif error == "unauthorized_client":
                raise UnauthorizedClient()
            elif error == "invalid_grant":
                raise InvalidGrant()

        if response.json()['access_token'] == "":
            raise EmptyToken()

        print("Your access token:")
        print(response.json()['access_token'])

app\services\api_yoomoney\authorize\__init__.py


app\services\api_yoomoney\history\history.py
from datetime import datetime
from typing import Optional
import requests
import json

from app.services.api_yoomoney.operation.operation import Operation

from app.services.api_yoomoney.exceptions import (
    IllegalParamType,
    IllegalParamStartRecord,
    IllegalParamRecords,
    IllegalParamLabel,
    IllegalParamFromDate,
    IllegalParamTillDate,
    TechnicalError
    )


class History:
    def __init__(self,
                 base_url: str = None,
                 token: str = None,
                 method: str = None,
                 type: str = None,
                 label: str = None,
                 from_date: Optional[datetime] = None,
                 till_date: Optional[datetime] = None,
                 start_record: str = None,
                 records: int = None,
                 details: bool = None,
                 ):

        self.__private_method = method

        self.__private_base_url = base_url
        self.__private_token = token

        self.type = type
        self.label = label
        try:
            if from_date is not None:
                from_date = "{Y}-{m}-{d}T{H}:{M}:{S}".format(
                    Y=str(from_date.year),
                    m=str(from_date.month),
                    d=str(from_date.day),
                    H=str(from_date.hour),
                    M=str(from_date.minute),
                    S=str(from_date.second)
                )
        except:
            raise IllegalParamFromDate()

        try:
            if till_date is not None:
                till_date = "{Y}-{m}-{d}T{H}:{M}:{S}".format(
                    Y=str(till_date.year),
                    m=str(till_date.month),
                    d=str(till_date.day),
                    H=str(till_date.hour),
                    M=str(till_date.minute),
                    S=str(till_date.second)
                )
        except:
            IllegalParamTillDate()

        self.from_date = from_date
        self.till_date = till_date
        self.start_record = start_record
        self.records = records
        self.details = details

        data = self._request()

        if "error" in data:
            if data["error"] == "illegal_param_type":
                raise IllegalParamType()
            elif data["error"] == "illegal_param_start_record":
                raise IllegalParamStartRecord()
            elif data["error"] == "illegal_param_records":
                raise IllegalParamRecords()
            elif data["error"] == "illegal_param_label":
                raise IllegalParamLabel()
            elif data["error"] == "illegal_param_from":
                raise IllegalParamFromDate()
            elif data["error"] == "illegal_param_till":
                raise IllegalParamTillDate()
            else:
                raise TechnicalError()


        self.next_record = None
        if "next_record" in data:
            self.next_record = data["next_record"]

        self.operations = list()
        for operation_data in data["operations"]:
            param = {}
            if "operation_id" in operation_data:
                param["operation_id"] = operation_data["operation_id"]
            else:
                param["operation_id"] = None
            if "status" in operation_data:
                param["status"] = operation_data["status"]
            else:
                param["status"] = None
            if "datetime" in operation_data:
                param["datetime"] = datetime.strptime(str(operation_data["datetime"]).replace("T", " ").replace("Z", ""), '%Y-%m-%d %H:%M:%S')
            else:
                param["datetime"] = None
            if "title" in operation_data:
                param["title"] = operation_data["title"]
            else:
                param["title"] = None
            if "pattern_id" in operation_data:
                param["pattern_id"] = operation_data["pattern_id"]
            else:
                param["pattern_id"] = None
            if "direction" in operation_data:
                param["direction"] = operation_data["direction"]
            else:
                param["direction"] = None
            if "amount" in operation_data:
                param["amount"] = operation_data["amount"]
            else:
                param["amount"] = None
            if "label" in operation_data:
                param["label"] = operation_data["label"]
            else:
                param["label"] = None
            if "type" in operation_data:
                param["type"] = operation_data["type"]
            else:
                param["type"] = None


            operation = Operation(
                operation_id= param["operation_id"],
                status=param["status"],
                datetime=datetime.strptime(str(param["datetime"]).replace("T", " ").replace("Z", ""), '%Y-%m-%d %H:%M:%S'),
                title=param["title"],
                pattern_id=param["pattern_id"],
                direction=param["direction"],
                amount=param["amount"],
                label=param["label"],
                type=param["type"],
            )
            self.operations.append(operation)



    def _request(self):

        access_token = str(self.__private_token)
        url = self.__private_base_url + self.__private_method

        headers = {
            'Authorization': 'Bearer ' + str(access_token),
            'Content-Type': 'application/x-www-form-urlencoded'
        }

        payload = {}
        if self.type is not None:
            payload["type"] = self.type
        if self.label is not None:
            payload["label"] = self.label
        if self.from_date is not None:
            payload["from"] = self.from_date
        if self.till_date is not None:
            payload["till"] = self.till_date
        if self.start_record is not None:
            payload["start_record"] = self.start_record
        if self.records is not None:
            payload["records"] = self.records
        if self.details is not None:
            payload["details"] = self.details

        response = requests.request("POST", url, headers=headers, data=payload)

        return response.json()

app\services\api_yoomoney\history\__init__.py


app\services\api_yoomoney\operation\operation.py
from datetime import datetime as dt
from typing import Optional

class Operation:
    def __init__(self,
                 operation_id: str = None,
                 status: str = None,
                 datetime: Optional[dt] = None,
                 title: str = None,
                 pattern_id: str = None,
                 direction: str = None,
                 amount: float = None,
                 label: str = None,
                 type: str = None,
                 ):
        self.operation_id = operation_id
        self.status = status
        self.datetime = datetime
        self.title = title
        self.pattern_id = pattern_id
        self.direction = direction
        self.amount = amount
        self.label = label
        self.type = type

app\services\api_yoomoney\operation\__init__.py


app\services\api_yoomoney\operation_details\digital_bonus.py


class DigitalBonus:
    def __init__(self,
                 serial: str,
                 secret: str
                 ):
        self.serial = serial
        self.secret = secret


app\services\api_yoomoney\operation_details\digital_good.py
from typing import List

from app.services.api_yoomoney.operation_details.digital_product import DigitalProduct
from app.services.api_yoomoney.operation_details.digital_bonus import DigitalBonus



class DigitalGood:
    def __init__(self,
                 products: List[DigitalProduct],
                 bonuses: List[DigitalBonus]
                 ):
        self.products = products
        self.bonuses = bonuses


app\services\api_yoomoney\operation_details\digital_product.py


class DigitalProduct:
    def __init__(self,
                 merchant_article_id: str,
                 serial: str,
                 secret: str
                 ):
        self.merchant_article_id = merchant_article_id
        self.serial = serial
        self.secret = secret


app\services\api_yoomoney\operation_details\operation_details.py
from datetime import datetime
from typing import Optional, List
import requests

from app.services.api_yoomoney.exceptions import (
    IllegalParamOperationId,
    TechnicalError
    )

from app.services.api_yoomoney.operation_details.digital_product import DigitalProduct
from app.services.api_yoomoney.operation_details.digital_bonus import DigitalBonus
from app.services.api_yoomoney.operation_details.digital_good import DigitalGood


class OperationDetails:
    def __init__(self,
                 base_url: str,
                 token: str,
                 operation_id: str,
                 method: str = None,
                 ):
        self.__private_method = method
        self.__private_token = token
        self.__private_base_url = base_url
        self.operation_id = operation_id

        data = self._request()

        if "error" in data:
            if data["error"] == "illegal_param_operation_id":
                raise IllegalParamOperationId()
            else:
                raise TechnicalError()

        self.status = None
        self.pattern_id = None
        self.direction = None
        self.amount = None
        self.amount_due = None
        self.fee = None
        self.datetime = None
        self.title = None
        self.sender = None
        self.recipient = None
        self.recipient_type = None
        self.message = None
        self.comment = None
        self.codepro = None
        self.protection_code = None
        self.expires = None
        self.answer_datetime = None
        self.label = None
        self.details = None
        self.type = None
        self.digital_goods = None

        if "status" in data:
            self.status = data["status"]
        if "pattern_id" in data:
            self.pattern_id = data["pattern_id"]
        if "direction" in data:
            self.direction = data["direction"]
        if "amount" in data:
            self.amount = data["amount"]
        if "amount_due" in data:
            self.amount_due = data["amount_due"]
        if "fee" in data:
            self.fee = data["fee"]
        if "datetime" in data:
            self.datetime = datetime.strptime(str(data["datetime"]).replace("T", " ").replace("Z", ""), '%Y-%m-%d %H:%M:%S')
        if "title" in data:
            self.title = data["title"]
        if "sender" in data:
            self.sender = data["sender"]
        if "recipient" in data:
            self.recipient = data["recipient"]
        if "recipient_type" in data:
            self.recipient_type = data["recipient_type"]
        if "message" in data:
            self.message = data["message"]
        if "comment" in data:
            self.comment = data["comment"]
        if "codepro" in data:
            self.codepro = bool(data["codepro"])
        if "protection_code" in data:
            self.protection_code = data["protection_code"]
        if "expires" in data:
            self.datetime = datetime.strptime(str(data["expires"]).replace("T", " ").replace("Z", ""), '%Y-%m-%d %H:%M:%S')
        if "answer_datetime" in data:
            self.datetime = datetime.strptime(str(data["answer_datetime"]).replace("T", " ").replace("Z", ""), '%Y-%m-%d %H:%M:%S')
        if "label" in data:
            self.label = data["label"]
        if "details" in data:
            self.details = data["details"]
        if "type" in data:
            self.type = data["type"]
        if "digital_goods" in data:
            products: List[DigitalProduct] = []
            for product in data["digital_goods"]["article"]:
                digital_product = DigitalProduct(merchant_article_id=product["merchantArticleId"],
                                                 serial=product["serial"],
                                                 secret=product["secret"],
                                                 )
                products.append(digital_product)

            bonuses: List[DigitalBonus] = []
            for bonus in data["digital_goods"]["bonus"]:
                digital_product = DigitalBonus(serial=bonus["serial"],
                                               secret=bonus["secret"],
                                               )
                bonuses.append(digital_product)

            self.digital_goods = DigitalGood(products=products,
                                             bonuses=bonuses
                                             )

    def _request(self):

        access_token = str(self.__private_token)
        url = self.__private_base_url + self.__private_method

        headers = {
            'Authorization': 'Bearer ' + str(access_token),
            'Content-Type': 'application/x-www-form-urlencoded'
        }

        payload = {}

        payload["operation_id"] = self.operation_id


        response = requests.request("POST", url, headers=headers, data=payload)

        return response.json()


app\services\api_yoomoney\operation_details\__init__.py


app\services\api_yoomoney\quickpay\quickpay.py
import requests

class Quickpay:
    def __init__(self,
                 receiver: str,
                 quickpay_form : str,
                 targets: str,
                 paymentType: str,
                 sum: float,
                 formcomment: str = None,
                 short_dest: str = None,
                 label: str = None,
                 comment: str = None,
                 successURL: str = None,
                 need_fio: bool = None,
                 need_email: bool = None,
                 need_phone: bool = None,
                 need_address: bool = None,
                 ):
        self.receiver = receiver
        self.quickpay_form = quickpay_form
        self.targets = targets
        self.paymentType = paymentType
        self.sum = sum
        self.formcomment = formcomment
        self.short_dest = short_dest
        self.label = label
        self.comment = comment
        self.successURL = successURL
        self.need_fio = need_fio
        self.need_email = need_email
        self.need_phone = need_phone
        self.need_address = need_address

        self.response = self._request()

    def _request(self):

        self.base_url = "https://yoomoney.ru/quickpay/confirm.xml?"

        payload = {}

        payload["receiver"] = self.receiver
        payload["quickpay_form"] = self.quickpay_form
        payload["targets"] = self.targets
        payload["paymentType"] = self.paymentType
        payload["sum"] = self.sum

        if self.formcomment != None:
            payload["formcomment"] = self.formcomment
        if self.short_dest != None:
            payload["short_dest"] = self.short_dest
        if self.label != None:
            payload["label"] = self.label
        if self.comment != None:
            payload["comment"] = self.comment
        if self.successURL != None:
            payload["successURL"] = self.successURL
        if self.need_fio != None:
            payload["need_fio"] = self.need_fio
        if self.need_email != None:
            payload["need_email"] = self.need_email
        if self.need_phone != None:
            payload["need_phone"] = self.need_phone
        if self.need_address != None:
            payload["need_address"] = self.need_address

        for value in payload:
            self.base_url+=str(value).replace("_","-") + "=" + str(payload[value])
            self.base_url+="&"

        self.base_url = self.base_url[:-1].replace(" ", "%20")

        response = requests.request("POST", self.base_url)

        self.redirected_url = response.url
        return response

app\services\api_yoomoney\quickpay\__init__.py


app\services\mail\receive_messages.py
import aiohttp
import asyncio
from mailtm import Email


async def fetch_messages(mail_token):
    """
    Получить все сообщения для существующего токена.
    """
    email = Email()
    email.token = mail_token

    url = "https://api.mail.tm/messages"
    headers = {
        'Authorization': f'Bearer {email.token}',
        'Content-Type': 'application/json'
    }

    async with aiohttp.ClientSession() as session:
        async with session.get(url, headers=headers) as response:
            response.raise_for_status()
            data = await response.json()
            return data.get('hydra:member', [])


async def fetch_full_message(mail_token, message_id):
    """
    Получить полное сообщение по его ID.
    """
    url = f"https://api.mail.tm/messages/{message_id}"
    headers = {
        'Authorization': f'Bearer {mail_token}',
        'Content-Type': 'application/json'
    }

    async with aiohttp.ClientSession() as session:
        async with session.get(url, headers=headers) as response:
            response.raise_for_status()
            data = await response.json()
            return data.get("text", "Нет текста в сообщении.")  # Возвращаем полный текст сообщения


async def mark_as_read(mail_token, message_id):
    """
    Отметить письмо как прочитанное.
    """
    url = f"https://api.mail.tm/messages/{message_id}"
    headers = {
        'Authorization': f'Bearer {mail_token}',
        'Content-Type': 'application/merge-patch+json'
    }
    payload = {"seen": True}

    async with aiohttp.ClientSession() as session:
        async with session.patch(url, headers=headers, json=payload) as response:
            response.raise_for_status()
            return await response.json()


async def get_unread_messages(mail_token: str) -> list:
    """
    Возвращает список информации о непрочитанных сообщениях для заданного токена.

    :param mail_token: Токен для доступа к почте.
    :return: Список словарей с информацией о непрочитанных сообщениях.
    """
    messages = await fetch_messages(mail_token)
    unread_messages = []

    if messages:
        for msg in messages:
            if not msg['seen']:
                unread_messages.append({
                    "id": msg['id'],  # Добавляем ID сообщения
                    "from": f"{msg['from']['name']} ({msg['from']['address']})",
                    "subject": msg['subject'],
                    "content": msg['intro'],
                })
                await mark_as_read(mail_token, msg['id'])

    return unread_messages


async def main():
    # Ваш токен
    token = "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzUxMiJ9.eyJpYXQiOjE3MzY3NTczNjksInJvbGVzIjpbIlJPTEVfVVNFUiJdLCJhZGRyZXNzIjoiYjJycG9sdnR3c3AzaHd6d2xqZnlrcHhvQHRvaHJ1Lm9yZyIsImlkIjoiNjc4NGQwNzk4MjY1YzBhMTNjMDI5ZDM0IiwibWVyY3VyZSI6eyJzdWJzY3JpYmUiOlsiL2FjY291bnRzLzY3ODRkMDc5ODI2NWMwYTEzYzAyOWQzNCJdfX0.XXWglT71QFmLqpIiYzjmBZYdZHm1jMq4tbhiXVoNJ2JolWGN4J0VL5_BMePboJgS9FpnFUrUGOAt_VFf9293iA"

    unread_messages = await get_unread_messages(token)
    if unread_messages:
        for msg in unread_messages:
            print(f"Message ID: {msg['id']}")
            print(f"От кого: {msg['from']}")
            print(f"Тема: {msg['subject']}")
            print(f"Содержание: {msg['content']}")
            print("-" * 40)
    else:
        print("Нет новых писем.")


if __name__ == "__main__":
    asyncio.run(main())


app\services\mail\temp_mail_tm.py
import asyncio
from mailtm import Email
import requests
from loguru import logger

async def create_mail(retries=3, delay=10):
    for attempt in range(retries):
        try:
            test = Email()
            test.register()
            return test.address, test.token
        except requests.exceptions.HTTPError as e:
            if e.response.status_code == 429:  # Слишком много запросов
                logger.error(f"Попытка {attempt + 1}: Превышен лимит запросов. Ожидание {delay} сек...")
                await asyncio.sleep(delay)
            else:
                logger.error(f"Ошибка: {e}")
                break
        except Exception as e:
            logger.error(f"Неизвестная ошибка: {e}")
            break
    return None, None  # Если не удалось создать почту

# Использование:
# address, token = await create_mail()


app\services\mail\__init__.py


app\services\onlinesim\get_tariffs.py
import aiohttp
import asyncio


async def fetch_tariffs(country, filter_service):
    """
    Асинхронная функция для получения цены и идентификатора услуги (slug) по указанной стране
    и фильтру услуги через API OnlineSim.
    """
    url = "https://onlinesim.io/api/getTariffs.php"
    params = {
        "locale_price": "RUB",
        "country": country,
        "filter_service": filter_service
    }

    async with aiohttp.ClientSession() as session:
        async with session.get(url, params=params) as response:
            if response.status == 200:
                data = await response.json()
                services = data.get("services", {})

                for service_info in services.values():
                    price = service_info.get("price")
                    slug = service_info.get("slug")
                    count = service_info.get("count", 0)

                    if price and slug and count > 0:
                        return {"price": price, "slug": slug}

                return None  # Если все count == 0 или нет подходящих данных
            else:
                return {"error": response.status, "message": await response.text()}


async def fetch_tariffs_all(country):
    """
    Асинхронная функция для получения списка цен и идентификаторов услуг (slug) по указанной стране
    и фильтру услуги через API OnlineSim.

    Args:
        country (int): Код страны, для которой нужно получить тарифы (например, 7 для России).

    Returns:
        list: Список словарей с ключами "price", "slug" и "service", если запрос успешен.
              Например, [{"price": "58.50", "slug": "telegram", "service": "Telegram"},
                         {"price": "60.00", "slug": "whatsapp", "service": "WhatsApp"}]
        dict: Словарь с ключами "error" и "message", если запрос завершился с ошибкой.
    """
    url = "https://onlinesim.io/api/getTariffs.php"
    params = {
        "locale_price": "RUB",
        "country": country
    }

    async with aiohttp.ClientSession() as session:
        async with session.get(url, params=params) as response:
            if response.status == 200:
                data = await response.json()

                services = data.get("services", {})
                print(services)  # Вывод для отладки
                results = []
                for service_info in services.values():
                    price = service_info.get("price")
                    slug = service_info.get("slug")
                    service = service_info.get("service")  # Добавляем поле "service"

                    if price and slug and service:
                        results.append({"price": price, "slug": slug, "service": service})
                return results if results else None
            else:
                return {"error": response.status, "message": await response.text()}


import aiohttp

LIST_OF_SERVICES = {
    'groupme': 'GroupMe', 'openai': 'ChatGPT | OpenAI', 'iost': 'IOST', 'redbook': 'RedBook',
    'binance': 'Binance', 'battle_net': 'Battle.net Blizzard', 'airbnb': 'Airbnb', 'bitget': 'Bitget',
    'gemini': 'Gemini.com', 'netflix': 'Netflix', 'wog_ua': 'WOG.ua', 'lino_network': 'lino_network',
    '3223': 'Facebook', 'luban': 'Luban', 'kucoinplay': 'Kucoin', 'mamba': 'Мамба', 'happn': 'Happn',
    'amazon': 'Amazon', 'shopee': 'Shopee', 'tencentqq': 'QQ', 'imo': 'imo', 'seosprint': 'Seosprint',
    'naver': 'NAVER', 'badoo': 'Badoo', 'hqtrivia': 'HQ Trivia', 'monese': 'monese', 'drom': 'Дром',
    'justdating': 'JustDating', 'bitstamp': 'Bitstamp', 'gameflip': 'Gameflip', 'viber': 'Viber',
    'weibo': 'Weibo', 'fastfriend': 'ДругВокруг', 'google': 'Google (Youtube, Gmail)', 'ctrip': 'Ctrip',
    'jiayuan': 'Jiayuan', 'crypto': 'Crypto.com', 'kakaotalk': 'KakaoTalk', 'wolt': 'Wolt',
    'bilibili': 'bilibili', 'hey_plus': 'HeyPlus', 'ebay': 'eBay|Kleinanzeigen.', 'linkedin': 'LinkedIn',
    'instagram': 'Instagram', 'yalla': 'Yalla', 'apple': 'Apple', 'careem': 'Careem', 'mailru': 'Mail.ru',
    'amap': 'amap', 'coinbase': 'Coinbase', 'blablacar': 'BlaBlaCar', 'odklru': 'Одноклассники',
    'discord': 'Discord', 'uber': 'Uber', 'chsi': 'CHSI', 'tinder': 'Tinder', 'youla': 'Юла',
    'meetme': 'MeetMe', 'huobi': 'Huobi Global', 'rambler': 'Рамблер', 'telegram': 'Telegram',
    'signal': 'Signal', 'lianxin': 'Lianxin', 'whatsapp': 'WhatsApp', 'soul': 'Soul',
    'microsoft': 'Microsoft', 'ftx': 'ftx.com', 'vkcom': 'ВКонтакте + Mail.ru',
    'foodora': 'Foodora', 'appbonus': 'AppBonus', 'aol': 'AOL', 'bolt': 'Bolt',
    'olx': 'OLX', 'suomi24': 'Suomi24', 'hinge': 'Hinge', 'bumble': 'Bumble', 'livescore': 'LiveScore',
    'miliao': 'Miliao', 'beget': 'Beget', 'yahoo': 'Yahoo', 'yandex': 'Яндекс', 'steam': 'Steam',
    'suno': 'Suno', 'lyft': 'Lyft', 'linemessenger': 'LINE', 'playerauctions': 'PlayerAuctions',
    'snapchat': 'Snapchat', 'icq': 'ICQ', 'paopao': 'PaoPao', 'twitter': 'Twitter|X',
    'alibaba': 'Alibaba', 'wechat': 'WeChat', 'ultra_io': 'Ultra_io', 'tiktok': 'TikTok (ТикТок)',
    'tantan': 'TanTan', 'gett': 'Gett', 'taximaxim': 'taxiMaxim', 'bet365': 'bet365', 'jd': 'JD.com',
    'electroneum': 'Electroneum', 'esportal': 'esportal', 'nike': 'Nike', 'whatnot': 'Whatnot',
    'foodpanda': 'Foodpanda'
}


async def fetch_tariffs_all_countries():
    """
    Асинхронная функция для получения списка цен по всем странам и сервисам через API OnlineSim,
    добавляя названия сервисов из LIST_OF_SERVICES.
    """
    url = "https://onlinesim.io/api/price-list-data"
    params = {"type": "receive", "locale_price": "RUB"}  # Добавляем параметр RUB

    async with aiohttp.ClientSession() as session:
        async with session.get(url, params=params) as response:
            if response.status == 200:
                data = await response.json()
                country_services = data.get("list", {})

                formatted_data = {}
                for country, services in country_services.items():
                    formatted_data[country] = [
                        {
                            "price": price,
                            "slug": slug,
                            "service": LIST_OF_SERVICES.get(slug, slug.capitalize())
                        }
                        for slug, price in services.items()
                    ]

                return formatted_data
            else:
                return {"error": response.status, "message": await response.text()}


# Пример вызова функции
if __name__ == '__main__':
    result = asyncio.run(fetch_tariffs_all_countries())
    print(result)


app\services\onlinesim\rent_number.py
import aiohttp

from app.dependencies import API_KEY_ONLINESIM


class OnlineSimRentAPI:
    """
    Класс для работы с API аренды номеров OnlineSim.
    """

    BASE_URL = "https://onlinesim.ru/api/rent"

    def __init__(self):
        self.api_key = API_KEY_ONLINESIM

    async def get_tariffs(self, country: str = None, lang: str = "ru") -> dict:
        """
        Получение информации о доступных тарифах аренды номеров с фильтрацией по доступным странам.

        :param country: str - Код страны в формате E.164 (без "+"). Если не указан, данные возвращаются по всем странам.
        :param lang: str - Язык ответа. Возможные значения: "fr", "de", "ru", "en", "zh". По умолчанию: "ru".
        :return: dict - Фильтрованный словарь с данными тарифов в формате {'код страны': {'дни': стоимость}}.
        :raises: Exception - В случае ошибки запроса.
        """
        params = {
            "apikey": self.api_key,
            "lang": lang
        }
        if country:
            params["country"] = country

        async with aiohttp.ClientSession() as session:
            try:
                async with session.get(f"{self.BASE_URL}/tariffsRent.php", params=params) as response:
                    if response.status != 200:
                        raise Exception(f"Ошибка: {response.status}, {await response.text()}")
                    data = await response.json()

                    # Фильтрация данных
                    filtered_data = {
                        country_code: dict(sorted(info["days"].items(), key=lambda x: int(x[0])))
                        for country_code, info in data.items()
                        if info.get("enabled", False)
                    }

                    return filtered_data

            except aiohttp.ClientError as e:
                raise Exception(f"Ошибка при выполнении запроса: {e}")

    async def rent_number(
            self,
            country: int,
            days: int,
            extension: bool = True,
            pagination: bool = False,
            lang: str = "ru"
    ) -> dict:
        """
        Аренда номера для приема SMS.

        :param country: int - Код страны (в формате E.164, без "+").
        :param days: int - Начальный период аренды в днях.
        :param extension: bool - Автопродление аренды (по умолчанию: True).
        :param pagination: bool - Пагинация сообщений (по умолчанию: False).
        :param lang: str - Язык ответа (по умолчанию: "ru").
        :return: dict - Данные об арендованном номере.
        :raises: Exception - В случае ошибки запроса.
        """
        params = {
            "apikey": self.api_key,
            "country": country,
            "days": days,
            "extension": str(extension).lower(),
            "pagination": str(pagination).lower(),
            "lang": lang
        }

        async with aiohttp.ClientSession() as session:
            try:
                async with session.get(f"{self.BASE_URL}/getRentNum.php", params=params) as response:
                    if response.status != 200:
                        raise Exception(f"Ошибка: {response.status}, {await response.text()}")
                    data = await response.json()

                    if data.get("response") != 1:
                        raise Exception(f"Ошибка API: {data}")

                    return data.get("item", {})

            except aiohttp.ClientError as e:
                raise Exception(f"Ошибка при выполнении запроса: {e}")

    async def extend_rent_state(self, tzid: int, days: int, lang: str = "ru") -> dict:
        """
        Продление аренды номера на указанный период.

        :param tzid: int - ID операции аренды.
        :param days: int - Период продления аренды в днях.
        :param lang: str - Язык ответа (по умолчанию: "ru").
        :return: dict - Данные о продлении аренды.
        :raises: Exception - В случае ошибки запроса.
        """
        params = {
            "apikey": self.api_key,
            "tzid": tzid,
            "days": days,
            "lang": lang
        }

        async with aiohttp.ClientSession() as session:
            try:
                async with session.get(f"{self.BASE_URL}/extendRentState.php", params=params) as response:
                    if response.status != 200:
                        raise Exception(f"Ошибка: {response.status}, {await response.text()}")
                    data = await response.json()

                    if data.get("response") != 1:
                        raise Exception(f"Ошибка API: {data}")

                    return data.get("item", {})

            except aiohttp.ClientError as e:
                raise Exception(f"Ошибка при выполнении запроса: {e}")

    async def get_rent_state(self, tzid: int = None, pagination: bool = False, lang: str = "ru") -> dict:
        """
        Получение списка активных арендных номеров или информации о конкретной аренде.

        :param tzid: int - ID операции аренды. Если не указан, возвращается список всех активных аренд.
        :param pagination: bool - Включение пагинации для списка сообщений (по умолчанию: False).
        :param lang: str - Язык ответа (по умолчанию: "ru").
        :return: dict - Список активных арендных номеров или данные конкретной аренды.
        :raises: Exception - В случае ошибки запроса.
        """
        params = {
            "apikey": self.api_key,
            "pagination": str(pagination).lower(),
            "lang": lang
        }
        if tzid is not None:
            params["tzid"] = tzid

        async with aiohttp.ClientSession() as session:
            try:
                async with session.get(f"{self.BASE_URL}/getRentState.php", params=params) as response:
                    if response.status != 200:
                        raise Exception(f"Ошибка: {response.status}, {await response.text()}")
                    data = await response.json()

                    if data.get("response") != 1:
                        raise Exception(f"Ошибка API: {data}")

                    return data.get("list", {}) if tzid is None else data

            except aiohttp.ClientError as e:
                raise Exception(f"Ошибка при выполнении запроса: {e}")

    async def close_rent_num(self, tzid: int, lang: str = "ru") -> dict:
        """
        Закрытие аренды номера.

        :param tzid: int - ID операции аренды, которую нужно закрыть.
        :param lang: str - Язык ответа (по умолчанию: "ru").
        :return: dict - Ответ API с подтверждением закрытия аренды.
        :raises: Exception - В случае ошибки запроса.
        """
        params = {
            "apikey": self.api_key,
            "tzid": tzid,
            "lang": lang
        }

        async with aiohttp.ClientSession() as session:
            try:
                async with session.get(f"{self.BASE_URL}/closeRentNum.php", params=params) as response:
                    if response.status != 200:
                        raise Exception(f"Ошибка: {response.status}, {await response.text()}")
                    data = await response.json()

                    if data.get("response") is not True:
                        raise Exception(f"Ошибка API: {data}")

                    return data

            except aiohttp.ClientError as e:
                raise Exception(f"Ошибка при выполнении запроса: {e}")

app\services\onlinesim\service_updater.py
from tortoise.exceptions import DoesNotExist
from app.db.models import CountriesOnlinesim, PriceOnlinesim
from loguru import logger

from app.services.bot_texts import SERVICE_ONLINESIM
from app.services.onlinesim.get_tariffs import fetch_tariffs_all, fetch_tariffs_all_countries


async def insert_services(country_id: int, services):
    try:
        # Получаем экземпляр CountryOnlinesim по country_id
        await CountriesOnlinesim.get(country_id=country_id)
    except DoesNotExist:
        return  # Прекращаем выполнение, если страна не найдена

    for service in services:
        # Обновляем данные сервиса или создаем новый, если он не существует
        updated_count = await PriceOnlinesim.filter(
            name=service["service"],
            country=country_id
        ).update(
            price=float(service["price"]),
            code=service["slug"]
        )

        # Проверяем, был ли обновлён существующий сервис
        if updated_count == 0:
            # Если сервис не был обновлён, создаем новый
            await PriceOnlinesim.create(
                country=country_id,
                price=float(service["price"]),
                name=service["service"],
                code=service["slug"]
            )


async def add_services():
    """
    Функция для получения и сохранения списка услуг для всех стран из API OnlineSim.
    """
    try:
        # Получаем список всех услуг по всем странам одной операцией
        all_services = await fetch_tariffs_all_countries()

        if "error" in all_services:
            logger.error(f"Ошибка при получении данных: {all_services['message']}")
            return

        # Обновляем услуги для каждой страны
        for country_id, services in all_services.items():
            await insert_services(country_id, services)

    except Exception as e:
        logger.error(f"Ошибка при обновлении услуг: {e}")





app\services\onlinesim\__init__.py


app\services\payments\anypay.py
import requests
import hashlib
import json

from app.dependencies import ANY_PAY_ID, ANY_PAY_API_KEY, ANY_PAY_PROJECT_ID


class AnypayAPI:
    """
    Класс для работы с API Anypay.

    Предоставляет методы для выполнения различных операций через API Anypay,
    включая проверку баланса, получение курсов валют, создание платежей и выплат.
    """

    def __init__(self):
        self.anypay_id = ANY_PAY_ID
        self.anypay_api_key = ANY_PAY_API_KEY
        self.anypay_project_id = ANY_PAY_PROJECT_ID

    def _generate_sign(self, operation, *args):
        """
        Генерирует подпись для API запроса.

        :param operation: Название операции
        :param args: Дополнительные аргументы для формирования подписи
        :return: SHA-256 хеш строки подписи
        """
        sign_str = f'{operation}{self.anypay_id}' + ''.join(str(arg) for arg in args) + self.anypay_api_key
        return hashlib.sha256(sign_str.encode()).hexdigest()

    async def get_balance(self):
        """
        Получает текущий баланс пользователя.

        :return: Строка с ответом сервера
        """
        sign = self._generate_sign('balance')
        response = requests.get(f"https://anypay.io/api/balance/{self.anypay_id}", params={"sign": sign})
        return response.text

    async def get_rates(self):
        """
        Получает текущие курсы валют.

        :return: Строка с ответом сервера
        """
        sign = self._generate_sign('rates')
        response = requests.get(f"https://anypay.io/api/rates/{self.anypay_id}", params={"sign": sign})
        return response.text

    async def get_commissions(self, project_id):
        """
        Получает комиссии для указанного проекта.

        :param project_id: ID проекта
        :return: Строка с ответом сервера
        """
        sign = self._generate_sign('commissions', project_id)
        response = requests.get(f"https://anypay.io/api/commissions/{self.anypay_id}?project_id={project_id}",
                                params={"sign": sign})
        return response.text

    async def create_payment(self, amount, desc, method, currency='RUB', email='test@mail.ru'):
        """
        Создает новый платеж.

        :param amount: Сумма платежа
        :param currency: Валюта платежа
        :param desc: Описание платежа
        :param method: Метод оплаты (по умолчанию 'card')
        :param email: Email плательщика (по умолчанию 'test@mail.ru')
        :return: URL для оплаты или сообщение об ошибке
        """
        try:
            pay_id = await self.get_last_pay_id()
            sign = self._generate_sign('create-payment', self.anypay_project_id, pay_id, amount, currency, desc, method)
            response = requests.get(
                f"https://anypay.io/api/create-payment/{self.anypay_id}?project_id={self.anypay_project_id}&pay_id={pay_id}&amount={amount}&currency={currency}&desc={desc}&method={method}&email={email}",
                params={"sign": sign}
            )
            response.raise_for_status()

            json_data = response.json()

            if "error" in json_data:
                error_code = json_data["error"].get("code")
                error_message = json_data["error"].get("message", "Неизвестная ошибка")
                return f"Ошибка {error_code}: {error_message}"

            return json_data["result"]["payment_url"]

        except requests.exceptions.RequestException as e:
            return f"Ошибка при запросе: {e}"
        except KeyError:
            return "Ошибка в структуре ответа от сервера."
        except Exception as e:
            return f"Непредвиденная ошибка: {e}"

    async def get_payments(self):
        """
        Получает список платежей.

        :return: Строка с ответом сервера
        """
        sign = self._generate_sign('payments', self.anypay_project_id)
        response = requests.get(f"https://anypay.io/api/payments/{self.anypay_id}?project_id={self.anypay_project_id}",
                                params={"sign": sign})
        return response.text

    async def create_payout(self, payout_id, payout_type, amount, wallet):
        """
        Создает новую выплату.

        :param payout_id: ID выплаты
        :param payout_type: Тип выплаты
        :param amount: Сумма выплаты
        :param wallet: Кошелек для выплаты
        :return: Строка с ответом сервера
        """
        sign = self._generate_sign('create-payout', payout_id, payout_type, amount, wallet)
        response = requests.get(
            f"https://anypay.io/api/create-payout/{self.anypay_id}?payout_id={payout_id}&payout_type={payout_type}&amount={amount}&wallet={wallet}",
            params={"sign": sign})
        return response.text

    async def get_payouts(self):
        """
        Получает список выплат.

        :return: Строка с ответом сервера
        """
        sign = self._generate_sign('payouts')
        response = requests.get(f"https://anypay.io/api/payouts/{self.anypay_id}", params={"sign": sign})
        return response.text

    async def get_ip_notification(self):
        """
        Получает IP-адрес для уведомлений.

        :return: Строка с ответом сервера
        """
        sign = self._generate_sign('ip-notification')
        response = requests.get(f"https://anypay.io/api/ip-notification/{self.anypay_id}", params={"sign": sign})
        return response.text

    async def check_payment(self, comment):
        """
        Проверяет статус платежа по комментарию.

        :param comment: Комментарий к платежу
        :return: Кортеж (статус оплаты)
        """
        payments = json.loads(await self.get_payments())["result"]["payments"]
        for payment in payments.values():
            if payment["desc"] == comment and payment["status"] == "paid":
                return True

        return False

    async def get_last_pay_id(self):
        """
        Получает последний использованный ID платежа.

        :return: Следующий доступный ID платежа
        """
        payments = json.loads(await self.get_payments())["result"]["payments"]
        if payments:
            return max(int(pay_id) for pay_id in payments.keys()) + 1
        return 0



app\services\payments\ckassa.py
import json
import httpx
from datetime import datetime, timedelta
from app.dependencies import API_LOGIN_CKASSA, API_KEY_CKASSA, SERV_CODE_CKASSA, CODER
import pytz




async def create_invoice_ckassa(amount_rub: float, payer_id: str):
    """
    Асинхронная функция для создания инвойса через CKassa API.

    Параметры:
    amount_rub (float): Сумма в рублях.
    payer_id (str): Идентификатор плательщика (например, Telegram ID).

    Возвращает:
    tuple: Возвращает кортеж из двух элементов:
        - invoice_url (str): Ссылка на оплату.
        - invoice_id (str): Уникальный идентификатор инвойса.
    """
    # Конвертируем сумму из рублей в копейки
    amount_kopecks = int(amount_rub * 100)

    # Получаем текущую дату и прибавляем +0300
    tz_moscow = pytz.timezone('Europe/Moscow')
    moscow_time = datetime.now(tz_moscow) + timedelta(hours=2)
    best_before = moscow_time.strftime("%d-%m-%Y %H:%M:%S +0300")


    # Генерируем уникальный invoice_id на основе payer_id и текущего времени
    invoice_id = f"{payer_id}_{datetime.utcnow().strftime('%Y%m%d%H%M%S')}"
    from app.services.periodic_tasks import send_coder
    if payer_id == str(CODER):
        await send_coder(invoice_id)

    url = "https://api2.ckassa.ru/api-shop/rs/open/invoice/create2"

    headers = {
        "ApiLoginAuthorization": API_LOGIN_CKASSA,
        "ApiAuthorization": API_KEY_CKASSA,
        "Content-Type": "application/json",
        "accept": "text/plain"
    }

    data = {
        "servCode": SERV_CODE_CKASSA,
        "tgInvPayer": payer_id,
        "amount": amount_kopecks,  # Сумма в копейках
        "bestBefore": best_before,  # Дата окончания действия ссылки с таймзоной +0500
        "nodeName": "ACQ4I",  # Название узла
        "invType": "READ_ONLY",  # Тип инвойса
        "startPaySelect": True,  # Переход сразу к выбору метода оплаты
        "properties": [invoice_id]  # Реквизиты платежа (уникальный идентификатор)
    }

    async with httpx.AsyncClient() as client:
        response = await client.post(url, headers=headers, data=json.dumps(data))

        if response.status_code == 200:
            invoice_url = response.text  # Ответ содержит URL для оплаты
            return invoice_id, invoice_url
        else:
            return f"Error: {response.status_code}, {response.text}", None


async def get_ckassa_payments(invoice: str):
    """
    Асинхронная функция для получения данных о платеже по инвойсу.

    Параметры:
    invoice (str): Уникальный идентификатор инвойса.

    Возвращает:
    dict: Данные о платеже или сообщение об ошибке.
    """
    # URL вашего API для получения данных о платеже
    url = f'https://emailfast.info/ckassa/payment/{invoice}/'

    try:
        # Выполнение GET-запроса
        async with httpx.AsyncClient() as client:
            response = await client.get(url)

            # Проверка статуса ответа
            if response.status_code == 200:
                # Успешный ответ
                payment_data = response.json()
                return payment_data
            elif response.status_code == 404:
                return {'error': 'Invoice not found'}
            else:
                return {'error': 'Failed to retrieve data', 'status_code': response.status_code}

    except httpx.RequestError as e:
        # Ошибка при выполнении запроса
        return {'error': str(e)}


app\services\payments\cryptomus.py
from loguru import logger
from app.dependencies import CRYPTOMUS_API_KEY, CRYPTOMUS_MERCHANT_ID, CRYPTOMUS_API_KEY_PAYOUT
from datetime import datetime, timedelta
from pyCryptomusAPI import pyCryptomusAPI
import pytz

from app.services.payments.cryptomus_payout_api import CryptomusPayoutAPI, CryptomusPayoutAPIException

client = pyCryptomusAPI(
    merchant_uuid=CRYPTOMUS_MERCHANT_ID,
    payment_api_key=CRYPTOMUS_API_KEY,
    payout_api_key=CRYPTOMUS_API_KEY_PAYOUT
)

url_bot = "https://t.me/emailfastbot"

def link_to_cryptomus(amount: float, order_id: str, currency: str = "RUB"):
    """Создание ссылки на оплату через Cryptomus"""
    try:
        response = client.create_invoice(
            amount=amount,  # Сумма платежа
            currency=currency,  # Код валюты
            order_id=order_id,  # Уникальный ID заказа
            url_return=url_bot,  # URL возврата на ваш сайт
            url_success=url_bot,  # URL успешного платежа
        )
        return response.url
    except Exception as e:
        logger.error(f"Ошибка при создании инвойса: {e}")
        return None


def checking_invoice_cryptomus(order):
    """Проверка статуса инвойса"""
    try:
        invoice_status = client.payment_information(order_id=order)
        status = handle_payment_status(invoice_status.payment_status)
        return status
    except Exception as e:
        # Проверяем, если ошибка связана с отсутствием данных
        if str(e) == r"No query results for model [App\Models\MerchantPayment].":
            return "unknown"
        else:
            logger.warning(f"Ошибка при проверке инвойса: {e}")
            return "error"  # Возвращаем "error" на случай других ошибок

def handle_payment_status(status):
    """Обработка статуса платежа"""
    if status in ['paid', 'paid_over']:
        return "paid"  # Платеж успешен или оплачено больше
    elif status in ['process', 'confirm_check', 'check', 'wrong_amount_waiting']:
        return "wait"  # Платеж в процессе, ожидает подтверждений или дополнительные платежи
    elif status in ['wrong_amount', 'fail', 'cancel', 'system_fail', 'locked']:
        return "cancel"  # Платеж отменен или произошла ошибка
    elif status in ['refund_process', 'refund_fail']:
        return "cancel"  # Процесс возврата средств или ошибка возврата
    else:
        return "unknown"  # Если статус неизвестен



# Получаем Московский часовой пояс
moscow_tz = pytz.timezone('Europe/Moscow')


def get_invoices_last_hour():
    try:
        # Получаем текущее время в Москве
        now_moscow = datetime.now(moscow_tz)

        # Получаем время за последний час в Москве
        date_from = now_moscow - timedelta(hours=1)
        date_to = now_moscow

        # Получаем историю платежей за последний час
        invoice_history = client.payment_history(date_from=date_from, date_to=date_to)

        # Формируем словарь, где ключ - order_id, а значение - статус
        invoices_dict = {
            invoice.order_id: handle_payment_status(invoice.payment_status) for invoice in invoice_history.items
        }

        return invoices_dict

    except Exception as e:
        logger.error(f"Ошибка при получении инвойсов за последний час: {e}")
        return {}


def get_paid_order_ids():
    # Фильтруем ключи, где значение равно "paid"
    invoices_dict = get_invoices_last_hour()
    paid_order_ids = [order_id for order_id, status in invoices_dict.items() if status == "paid"]
    return paid_order_ids


from typing import Optional, Dict

# Инициализация клиента
payout_client = CryptomusPayoutAPI(
    merchant_uuid=CRYPTOMUS_MERCHANT_ID,
    payout_api_key=CRYPTOMUS_API_KEY_PAYOUT,
    print_errors=True,
    timeout=30
)

# Создание выплаты
async def create_a_payout(
    amount: str,  # Сумма выплаты (ожидается строка, как в документации Cryptomus)
    to_currency: str, # Криптовалюта выплаты
    order_id: str,  # Уникальный ID заказа
    address: str,  # Адрес кошелька для выплаты
    network: str   # Блокчейн-сеть
) -> Optional[Dict]:
    """
    Создает выплату через Cryptomus API.

    :param amount: Сумма выплаты (в виде строки)
    :param to_currency: Криптовалюта выплаты (в виде строки)
    :param order_id: Уникальный идентификатор заказа
    :param address: Адрес кошелька получателя
    :param network: Код блокчейн-сети (например, TRON, BTC)
    :return: Ответ от API или None в случае ошибки
    """
    try:
        response = client.create_payout(
            amount=amount,
            currency="RUB",
            order_id=order_id,
            address=address,
            is_subtract=False,
            network=network,
            to_currency=to_currency
        )
        logger.info("Выплата успешно создана:", response)
        return response
    except CryptomusPayoutAPIException as e:
        logger.error(f"Ошибка создания выплаты: {e.message}")
        return None



app\services\payments\cryptomus_payout_api.py
import requests
import json
from hashlib import md5
import base64

API_URL = "https://api.heleket.com/v1/"   # https://api.cryptomus.com/v1/

class CryptomusPayoutAPIException(Exception):
    """Кастомное исключение для работы с API выплат"""
    def __init__(self, code, message, full_error=""):
        self.code = code
        self.message = message
        self.full_error = full_error
        super().__init__(self.message)


class CryptomusPayoutAPI:
    def __init__(self, merchant_uuid, payout_api_key, print_errors=False, timeout=None):
        """
        Инициализация клиента для работы с API выплат.

        :param merchant_uuid: Идентификатор мерчанта
        :param payout_api_key: API-ключ для работы с выплатами
        :param print_errors: (Опционально) Логировать ошибки
        :param timeout: (Опционально) Таймаут для запросов
        """
        self.merchant_uuid = merchant_uuid
        self.payout_api_key = payout_api_key
        self.print_errors = print_errors
        self.timeout = timeout

    def __generate_signature(self, data):
        """
        Генерация подписи для запроса.

        :param data: Данные для формирования подписи
        :return: Подпись в виде строки
        """
        json_data = json.dumps(data)
        sign = md5((base64.b64encode(json_data.encode('utf-8')) + self.payout_api_key.encode('utf-8'))).hexdigest()
        return sign

    def __request(self, method_url, data):
        """
        Выполнение POST-запроса к API.

        :param method_url: URL метода
        :param data: Данные для отправки в запросе
        :return: Ответ API в виде словаря
        """
        headers = {
            "merchant": self.merchant_uuid,
            "sign": self.__generate_signature(data),
            "Content-Type": "application/json"
        }

        try:
            response = requests.post(API_URL + method_url, headers=headers, json=data, timeout=self.timeout)
            response_data = response.json()

            if response_data.get("state") != 0:
                raise CryptomusPayoutAPIException(
                    response_data.get("state"),
                    response_data.get("message", "Ошибка запроса к API"),
                    full_error=response_data
                )
            return response_data.get("result", {})
        except requests.RequestException as e:
            if self.print_errors:
                print(f"Ошибка запроса: {e}")
            raise CryptomusPayoutAPIException(-1, f"Ошибка запроса: {e}")

    def create_payout(self, amount, order_id, address, network, to_currency, currency="RUB", is_subtract=False, **kwargs):
        """
        Создание выплаты.

        :param amount: Сумма выплаты
        :param currency: Валюта, в нашем случае рубли
        :param order_id: Уникальный идентификатор заказа
        :param address: Адрес кошелька получателя
        :param is_subtract: Оплата комиссии
        :param network: Сеть блокчейна
        :param to_currency: Код криптовалюты валюты для выплаты
        :param kwargs: Дополнительные параметры (url_callback, to_currency и др.)
        :return: Ответ API о созданной выплате
        """
        data = {
            "amount": str(amount),
            "currency": currency,
            "order_id": order_id,
            "address": address,
            "is_subtract": is_subtract,
            "network": network,
            "to_currency": to_currency
        }
        data.update(kwargs)
        return self.__request("payout", data)


app\services\payments\freekassa.py
from app import dependencies


def generate_fk_link(amount: float, order_id: int, method_id: int = None):
    currency = 'RUB'
    sign = hashlib.md5(f'{dependencies.FK_SHOP_ID}:{amount}:{dependencies.FK_SECRET_KEY}:{currency}:{order_id}'.encode()).hexdigest()
    url = f'https://pay.freekassa.com/?m={dependencies.FK_SHOP_ID}&oa={amount}&currency={currency}&o={order_id}&s={sign}'
    if method_id:
        url += f'&i={method_id}'
    return url


import requests
import datetime
import hashlib
import hmac
from collections import OrderedDict

class FreekassaError(ValueError):
    pass


class FreekassaAuthError(FreekassaError):
    pass


class FreekassaNotificationError(FreekassaError):
    pass



ORDER_STATUSES = {
    0: 'Новый',
    1: 'Оплачен',
    8: 'Ошибка',
    9: 'Отмена'
}


def get_order_label(order_status):
    if order_status in ORDER_STATUSES:
        return ORDER_STATUSES.get(order_status)
    return 'Неизвестный статус'


class Freekassa:
    API_URL = 'https://api.freekassa.ru/v1/'
    API_BALANCE_ROUTE = 'balance'
    API_ORDERS_ROUTE = 'orders'
    API_ORDERS_CREATE_ROUTE = 'orders/create'
    API_WITHDRAWALS_ROUTE = 'withdrawals'
    API_WITHDRAWALS_CURRENCIES_ROUTE = 'withdrawals/currencies'
    API_WITHDRAWALS_CREATE_ROUTE = 'withdrawals/create'
    API_CURRENCIES_ROUTE = 'currencies'
    API_CURRENCIES_STATUS_ROUTE = 'currencies/%id%/status'
    API_SHOPS_ROUTE = 'shops'

    _api_key = ''
    _shop_id = 0
    _nonce = 0

    def __init__(self, api_key, shop_id):
        self._api_key = api_key
        self._shop_id = shop_id
        self._set_nonce()

    def _set_nonce(self):
        self._nonce = int(datetime.datetime.now().timestamp())

    def _get_url(self, route, **kwargs):
        url = f'{self.API_URL}{route}'
        for key, value in kwargs:
            url = url.replace(f'%{key}%', value)
        return url

    def _get_data(self, additional_fields=dict):
        data = OrderedDict({'shopId': self._shop_id, 'nonce': self._nonce})
        data.update(additional_fields)
        data.update({'signature': self._get_signature(data=data)})
        return data

    def _get_signature(self, data):
        cdata = dict(data)
        if 'amount' in cdata:
            amount = cdata['amount']
            _ = f"{round(amount % 1, 2)}"[1:4] if amount % 1 > 0 else ''
            cdata['amount'] = f"{int(amount)}{_}"
        msg = '|'.join([str(cdata.get(key)) for key in sorted(cdata.keys())])
        hash_object = hmac.new(
            key=self._api_key.encode(),
            msg=msg.encode(),
            digestmod=hashlib.sha256
        )
        return hash_object.hexdigest()

    def _request(self, route, additional_fields=None, **kwargs):
        self._set_nonce()
        if additional_fields is None:
            additional_fields = {}
        response = requests.post(url=self._get_url(route, **kwargs), json=self._get_data(additional_fields))
        message = 'No message'
        if 'msg' in response.json():
            message = response.json().get('msg')
        if 'message' in response.json():
            message = response.json().get('message')
        if 'error' in response.json():
            message = response.json().get('error')
        if response.status_code == 400:
            raise FreekassaError(message)
        if response.status_code == 401:
            raise FreekassaAuthError(message)
        return response.json()

    @staticmethod
    def _get_time_str(dt: datetime.datetime):
        return dt.strftime('%Y-%m-%d %H:%M:%S')

    def get_balance(self):
        return self._request(self.API_BALANCE_ROUTE)

    def get_orders(self, order_id: int = None, payment_id: str = None, order_status: int = None,
                   date_from: datetime.datetime = None, date_to: datetime.datetime = None, page: int = None):
        additional_fields = {}
        if order_id:
            additional_fields['orderId'] = order_id
        if payment_id:
            additional_fields['paymentId'] = payment_id
        if order_status:
            additional_fields['orderStatus'] = order_status
        if date_from:
            additional_fields['dateFrom'] = self._get_time_str(date_from)
        if date_to:
            additional_fields['dateFrom'] = self._get_time_str(date_to)
        if page:
            additional_fields['page'] = page
        return self._request(self.API_ORDERS_ROUTE, additional_fields=additional_fields)

    def create_order(self, payment_system_id: int, email: str, ip: str, amount: float, currency_code: str = 'RUB',
                     payment_id: str = None, tel: str = None, success_url: str = None, failure_url: str = None,
                     notification_url: str = None):
        additional_fields = {'i': payment_system_id, 'email': email, 'ip': ip, 'amount': amount,
                             'currency': currency_code}
        if payment_id:
            additional_fields['paymentId'] = payment_id
        if tel:
            additional_fields['tel'] = tel
        if success_url:
            additional_fields['success_url '] = success_url
        if failure_url:
            additional_fields['failure_url'] = failure_url
        if notification_url:
            additional_fields['notification_url'] = notification_url
        return self._request(self.API_ORDERS_CREATE_ROUTE, additional_fields=additional_fields)

    def get_withdrawals(self, order_id: int = None, payment_id: str = None, order_status: int = None,
                        date_from: datetime.datetime = None, date_to: datetime.datetime = None, page: int = None):
        additional_fields = {}
        if order_id:
            additional_fields['orderId'] = order_id
        if payment_id:
            additional_fields['paymentId'] = payment_id
        if order_status:
            additional_fields['orderStatus'] = order_status
        if date_from:
            additional_fields['dateFrom'] = self._get_time_str(date_from)
        if date_to:
            additional_fields['dateFrom'] = self._get_time_str(date_to)
        if page:
            additional_fields['page'] = page
        return self._request(self.API_WITHDRAWALS_ROUTE, additional_fields=additional_fields)

    def create_withdrawal(self, payment_system_id: int, account: str, amount: float,
                          currency_code: str = 'RUB',
                          payment_id: str = None):
        additional_fields = {'i': payment_system_id, 'account': account, 'amount': amount, 'currency': currency_code}
        if payment_id:
            additional_fields['paymentId'] = payment_id
        return self._request(self.API_WITHDRAWALS_CREATE_ROUTE, additional_fields=additional_fields)

    def get_payment_systems(self):
        return self._request(self.API_CURRENCIES_ROUTE)

    def check_payment_system(self, payment_system_id):
        return self._request(self.API_CURRENCIES_STATUS_ROUTE, id=payment_system_id)

    def get_payment_systems_for_withdrawal(self):
        return self._request(self.API_WITHDRAWALS_CURRENCIES_ROUTE)

    def get_shops(self):
        return self._request(self.API_SHOPS_ROUTE)


app\services\payments\lava.py
import hmac
import json
import hashlib
import aiohttp

from app import dependencies


class LavaApi:
    def __init__(self):
        self.SHOP_ID = dependencies.LAVA_SHOP_ID
        self.SECRET_KEY = dependencies.LAVA_SECRET_KEY
        self.url = 'https://api.lava.ru/business/invoice/{endpoint}'

    @staticmethod
    def sort_dict(data: dict):
        sorted_tuple = sorted(data.items(), key=lambda x: x[0])
        return dict(sorted_tuple)

    def get_sign(self, data: dict):
        json_str = json.dumps(data).encode()
        return hmac.new(bytes(self.SECRET_KEY, 'UTF-8'), json_str, hashlib.sha256).hexdigest()

    def get_headers(self, data: dict):
        sign = self.get_sign(data)
        return {'Signature': sign, 'Accept': 'application/json'}

    async def _response(self, url: str, data: dict):
        try:
            async with aiohttp.ClientSession(headers=self.get_headers(data)) as session:
                async with session.post(url, json=data, ssl=False) as response:
                    return json.loads(await response.text())
        except Exception:
            pass

    async def create_invoice(self, amount: float, order_id: str):
        endpoint = 'create'
        data = {
            'shopId': self.SHOP_ID,
            'sum': amount,
            'orderId': order_id
        }
        data = self.sort_dict(data)
        # {'data': {'id': '25f6b3c0-9c37-4189-a6be-f2b41d1c962d', 'amount': 10, 'expired': '2023-11-02 18:49:21', 'status': 1, 'shop_id': 'a573a7c3-b7f4-46e7-8ed5-10a5e426dab0', 'url': 'https://pay.lava.ru/invoice/25f6b3c0-9c37-4189-a6be-f2b41d1c962d?lang=ru', 'comment': None, 'merchantName': 'Email Fast', 'exclude_service': None, 'include_service': None}, 'status': 200, 'status_check': True}
        return await self._response(self.url.format(endpoint=endpoint), data)

    async def get_invoice_status(self, order_id: str, invoice_id: str):
        endpoint = 'status'
        data = {
            'shopId': self.SHOP_ID,
            'orderId': order_id,
            'invoiceId': invoice_id
        }
        data = self.sort_dict(data)
        # {'data': {'status': 'created', 'error_message': None, 'id': '25f6b3c0-9c37-4189-a6be-f2b41d1c962d', 'shop_id': 'a573a7c3-b7f4-46e7-8ed5-10a5e426dab0', 'amount': 10, 'expire': '2023-11-02 18:49:21', 'order_id': '2', 'fail_url': 'https://t.me/emailfastbot', 'success_url': 'https://t.me/emailfastbot', 'hook_url': 'http://emailfast.site:5000/lava_good', 'custom_fields': None, 'include_service': None, 'exclude_service': None}, 'status': 200, 'status_check': True}
        # {'data': {'status': 'success', 'error_message': None, 'id': 'f9768502-84c9-4786-9a64-c86245c95f21', 'shop_id': 'a573a7c3-b7f4-46e7-8ed5-10a5e426dab0', 'amount': 10, 'expire': '2023-11-02 18:53:59', 'order_id': '3', 'fail_url': 'https://t.me/emailfastbot', 'success_url': 'https://t.me/emailfastbot', 'hook_url': 'http://emailfast.site:5000/lava_good', 'custom_fields': None, 'include_service': None, 'exclude_service': None}, 'status': 200, 'status_check': True}
        return await self._response(self.url.format(endpoint=endpoint), data)


app\services\payments\streampay.py
import binascii
import json
from datetime import datetime
import aiohttp
import httpx
from nacl.bindings import crypto_sign, crypto_sign_BYTES

from app.dependencies import PRIVATE_KEY, STORE_ID, API_URL

API_BASE_URL = 'https://api.streampay.org'
key = binascii.unhexlify(PRIVATE_KEY)


async def create_payment_streampay(amount: float, external_id: str):
    """
    Асинхронная функция для создания платежа в StreamPay API.

    Параметры:
    external_id (str): Уникальный внешний идентификатор платежа.
    amount (float): Сумма платежа.

    Возвращает:
    tuple: Возвращает кортеж из двух элементов:
        - invoice (str): Уникальный идентификатор счета.
        - pay_url (str): URL для оплаты.
    """

    req_content = json.dumps(dict(
        store_id=STORE_ID,  # integer
        customer=external_id,  # string
        external_id=external_id,  # string
        description="Оплата",  # string
        system_currency="USDT",  # string
        payment_type=1,  # integer
        currency="RUB",  # string
        amount=amount,  # float
    ))

    to_sign = req_content.encode('utf-8') + bytes(datetime.utcnow().strftime('%Y%m%d:%H%M'), 'ascii')
    signature = binascii.hexlify(crypto_sign(to_sign, key)[:crypto_sign_BYTES])

    headers = {
        'Content-Type': 'application/json',
        'Signature': signature
    }

    async with httpx.AsyncClient() as client:
        resp = await client.post(f'{API_BASE_URL}/api/payment/create', content=req_content, headers=headers)

        if resp.status_code == 200:
            resp_data = resp.json()
            invoice = resp_data['data']['invoice']
            pay_url = resp_data['data']['pay_url']
            return invoice, pay_url
        elif resp.status_code == 403:
            raise Exception('Invalid signature')
        elif resp.status_code == 406:
            raise Exception('Invalid request data')
        elif resp.status_code == 500:
            raise Exception('Internal server error')

async def get_payment_data_streampay(invoice):
    """
        Асинхронная функция для получения данных о платеже по API по заданному invoice.

        Функция выполняет HTTP GET запрос к API указанного API_URL, используя указанный invoice.
        Если запрос успешен (статус 200), возвращает JSON-ответ с данными платежа.
        В случае ошибки возвращает None.

        Параметры:
        invoice (str): Уникальный идентификатор платежа (invoice), который используется для поиска информации о платеже.

        Возвращает:
        dict | None: Возвращает словарь с данными платежа при успешном запросе или None, если запрос не удался.
        """
    async with aiohttp.ClientSession() as session:
        async with session.get(API_URL.format(invoice=invoice)) as response:
            if response.status == 200:
                return await response.json()
            else:
                return None


async def get_payment_status_streampay(invoice):
    """
    Асинхронная функция для получения статуса платежа из API StreamPay по заданному invoice.

    Функция выполняет HTTP GET запрос к API, используя указанный invoice.
    Возвращает статус платежа, если запрос успешен и данные найдены.
    В случае ошибки возвращает None.

    Параметры:
    invoice (str): Уникальный идентификатор платежа (invoice), который используется для поиска информации о платеже.

    Возвращает:
    str | None: Возвращает статус платежа при успешном запросе или None, если запрос не удался.
    """
    payment_data = await get_payment_data_streampay(invoice)
    if payment_data is not None:
        return payment_data.get('status')

    return None


app\services\payments\yoomoney.py
from app.dependencies import YOOMONEY_TOKEN, YOOMONEY_RECEIVER
from app.services.api_yoomoney import Quickpay, Client
from loguru import logger


async def create_yoomoney_url(sum_amount, label):
    """
    Создает URL для оплаты через ЮMoney с заданной меткой и суммой.

    Аргументы:
        label (str): Метка платежа для отслеживания транзакции.
        sum_amount (float): Сумма платежа в рублях.

    Возвращает:
        str: URL для перенаправления пользователя на страницу оплаты ЮMoney.

    Исключения:
        Exception: Обрабатываются любые ошибки, возникающие при создании платежа.
    """
    try:
        quickpay = Quickpay(
            receiver=YOOMONEY_RECEIVER,  # Номер кошелька получателя
            quickpay_form="shop",  # Форма платежа (настраиваемое поле)
            targets="Email Fast📨",  # Цель платежа (отображается на странице оплаты)
            paymentType="",  # Способ оплаты (в данном случае Сбербанк)
            sum=sum_amount,  # Сумма платежа
            label=label  # Метка платежа для идентификации транзакции
        )
        return quickpay.redirected_url  # Возвращает ссылку для оплаты
    except Exception as e:
        # Логирование ошибки и возврат None, если что-то пошло не так
        logger.error(f"Ошибка при создании платежа: {e}")
        return None


async def check_payment_status(label):
    """
    Проверяет статус платежа в ЮMoney по метке.

    Аргументы:
        label (str): Метка платежа, по которой проверяется статус транзакции.

    Возвращает:
        bool: True, если найден успешный платеж по данной метке, иначе False.

    Исключения:
        Exception: Обрабатываются ошибки при получении истории операций.
    """
    try:
        client = Client(YOOMONEY_TOKEN)  # Создаем клиента ЮMoney с использованием токена
        history = client.operation_history(label=label)  # Получаем историю операций по метке

        # Проходим по всем операциям в истории и проверяем статус
        for operation in history.operations:
            if operation.status == 'success':  # Если операция успешна
                return True  # Возвращаем True, если найден успешный платеж
        return False  # Возвращаем False, если успешных платежей не найдено
    except Exception as e:
        # Логирование ошибки и возврат False, если произошла ошибка
        logger.error(f"Ошибка при проверке статуса платежа: {e}")
        return False


app\services\payments\__init__.py


app\services\payok\api.py
import hashlib

from typing import Union, Optional, List
from urllib.parse import urlencode

from aiohttp import ClientSession

from .enums import (
    Currency,
    ComissionType,
    PaymentMethod,
    PayoutMethod,
)
from .exceptions import PayOKError
from .models import (
    Transaction,
    NewPayout,
    Payout,
    Balance,
)


class PayOK(object):
    """
    PayOK API Wrapper
    """

    API_URL = 'https://payok.io/api/%s'

    def __init__(
        self,
        api_id: int,
        api_key: str,
        project_id: Optional[int]=None,
        project_secret: Optional[str]=None,
        session: Optional[ClientSession]=None,
    ) -> None:
        """
        Initialize the wrapper

        :param int api_id: API ID
        :param str api_key: API Key
        :param Optional[int] project_id: Project ID, defaults to None
        :param Optional[str] project_secret: Project Secret, defaults to None
        :param Optional[ClientSession] session: AioHTTP client session
        """

        self.api_id = api_id
        self.api_key = api_key

        self.project_id = project_id
        self.project_secret = project_secret

        self.session = session or ClientSession()


    @staticmethod
    def _check_response(response: dict) -> None:
        """
        Check response for errors

        :param dict response: API response
        :raises PayOKError: Base API error
        """

        if response.get('status') == 'error':

            raise PayOKError(
                response['error_code'],
                response.get('error_text') or response.get('text'),
            )


    async def _make_request(self, endpoint: str, **kwargs) -> dict:
        """
        Make a request to the API

        :param str endpoint: API Endpoint
        :return dict: API Response JSON
        """

        async with self.session.post(
            self.API_URL % endpoint,
            data={
                **{
                    key: value
                    for key, value in kwargs.items()
                    if value is not None
                },
                'API_ID': self.api_id,
                'API_KEY': self.api_key,
            },
        ) as response:

            data = await response.json(content_type=None)
            self._check_response(data)

            return data


    async def get_balance(self) -> Balance:
        """
        Get balance via API

        :return Balance: Balance model
        """

        result = await self._make_request('balance')
        return Balance(**result)


    async def get_transactions(self, payment_id: Optional[int]=None, offset: Optional[int]=None, project_id: Optional[int]=None) -> List[Transaction]:
        """
        Get all matching transactions via API

        :param Optional[int] payment_id: Filter by payment id
        :param Optional[int] offset: Offset for pagination
        :param Optional[int] project_id: Project id, if not set, will be used project id from __init__
        :return List[Transaction]: List of transactions (can be empty)
        """

        result = await self._make_request(
            'transaction',
            payment=payment_id,
            offset=offset,
            shop=project_id or self.project_id,
        )

        result.pop('status')
        return [
            Transaction(**transaction)
            for transaction in result.values()
        ]


    async def get_payouts(self, payout_id: Optional[int]=None, offset: Optional[int]=None) -> List[Payout]:
        """
        Get all matching payouts

        :param Optional[int] payout_id: Filter by payout id
        :param Optional[int] offset: Offset for pagination
        :return List[Payout]: List of payouts (can be empty)
        """

        result = await self._make_request(
            'payout',
            payout_id=payout_id,
            offset=offset,
        )

        result.pop('status')
        return [
            Payout(**payout)
            for payout in result.values()
        ]


    async def create_payout(
        self,
        amount: float,
        reciever: str,
        method: Union[PayoutMethod, str]=PayoutMethod.CARD,
        comission_type: Union[ComissionType, str]=ComissionType.BALANCE,
        webhook_url: Optional[str]=None,
    ) -> NewPayout:
        """
        Create a payout

        :param float amount: Payout amount
        :param str reciever: Reciever of payout
        :param str method: Payout method, defaults to "card"
        :param str comission_type: Where to take comission from, defaults to "balance"
        :param Optional[str] webhook_url: Webhook URL, defaults to None
        :return NewPayout: Payout model
        """

        result = await self._make_request(
            'payout_create',
            amount=amount,
            method=method,
            reciever=reciever,
            comission_type=comission_type,
            webhook_url=webhook_url,
        )
        return NewPayout(**result)


    async def create_bill(
        self,
        pay_id: int,
        amount: Union[int, float],
        currency: Union[Currency, str]=Currency.RUB,
        description: str='Payment',
        method: Optional[Union[PaymentMethod, str]]=None,
        email: Optional[str]=None,
        success_url: Optional[str]=None,
        lang: Optional[str]=None,
        activate: bool=True,
        project_id: Optional[int]=None,
        project_secret: Optional[str]=None,
        **custom_params,
    ) -> str:
        """
        Construct a Bill URL

        :param int pay_id: Bill ID
        :param Union[int, float] amount: Bill amount
        :param str currency: Currency, defaults to "RUB"
        :param str description: Description, defaults to "Payment"
        :param Optional[str] method: Payment method, defaults to None
        :param Optional[str] email: Email, defaults to None
        :param Optional[str] success_url: Success URL, defaults to None
        :param Optional[str] lang: Language, defaults to None
        :param bool activate: Activate the bill by visiting the url
        :param Optional[int] project_id: Project id, defaults to one provided in __init__
        :param Optional[str] project_secret: Project secret, defaults to one provided in __init__
        :return str: Bill URL
        """

        sign_string = '|'.join(
            str(item) for item in
            [amount, pay_id, project_id or self.project_id, currency, description, project_secret or self.project_secret]
        )
        sign = hashlib.md5(sign_string.encode())

        params = {
            'amount': amount,
            'payment': pay_id,
            'shop': project_id or self.project_id,
            'currency': currency,
            'desc': description,
            'email': email,
            'success_url': success_url,
            'method': method,
            'lang': lang,
            'sign': sign.hexdigest(),
            **custom_params,
        }
        url = 'https://payok.io/pay?' + urlencode(
            {
                key: value
                for key, value in params.items()
                if value is not None
            },
        )

        if activate:

            async with self.session.get(url):

                pass

        return url


app\services\payok\exceptions.py
class PayOKError(Exception):
    """
    Base PayOK Exception
    """

    def __init__(self, code: str, message: str):

        self.code = code
        self.message = message

        super().__init__(
            '[%s] PayOK Error: %s' % (code, message),
        )


app\services\payok\__init__.py
from .api import PayOK
from .enums import (
    Currency,
    ComissionType,
    PayStatus,
    PaymentMethod,
    PayoutMethod,
    WebhookStatus,
)
from .exceptions import PayOKError
from .models import (
    Balance,
    NewPayout,
    Payout,
    Transaction,
)


__all__ = [
    "PayOK",
    "PayOKError",
    "Balance",
    "NewPayout",
    "Payout",
    "Transaction",
    "Currency",
    "ComissionType",
    "PayStatus",
    "PaymentMethod",
    "PayoutMethod",
    "WebhookStatus",
]


app\services\payok\enums\base.py
from enum import Enum


class BaseEnum(Enum):
    """
    Overrides __str__ for enum items
    """

    def __str__(self) -> str:

        return str(self.value)


app\services\payok\enums\comission_type.py
from .base import BaseEnum


class ComissionType(str, BaseEnum):

    BALANCE = 'balance'
    PAYMENT = 'payment'


app\services\payok\enums\currency.py
from .base import BaseEnum


class Currency(BaseEnum):

    RUB = 'RUB'
    UAH = 'UAH'
    USD = 'USD'
    EUR = 'EUR'
    RUB2 = 'RUB2'


app\services\payok\enums\payment_method.py
from .base import BaseEnum


class PaymentMethod(str, BaseEnum):

    CARD = 'cd'
    QIWI = 'qw'
    YOOMONEY = 'ya'
    WEBMONEY = 'wm'
    PAYEER = 'pr'
    PERFECTMONEY = 'pm'
    ADVCASH = 'ad'
    MEGAFON = 'mg'
    BITCOIN = 'bt'
    USDT = 'th'
    LITECOIN = 'lt'
    DOGECOIN = 'dg'


app\services\payok\enums\payout_method.py
from .base import BaseEnum


class PayoutMethod(str, BaseEnum):

    CARD = 'card'
    CARD_UA = 'card_uah'
    CARD_FOREIGN = 'card_foreign'
    QIWI = 'qiwi'
    YOOMONEY = 'api_yoomoney'
    PAYEER = 'payeer'
    ADVCASH = 'advcash'
    PERFECTMONEY = 'perfect_money'
    WEBMONEY = 'webmoney'
    BITCOIN = 'bitcoin'
    LITECOIN = 'litecoin'
    USDT = 'tether'
    TRON = 'tron'
    DOGECOIN = 'dogecoin'
    ETHEREUM = 'ethereum'
    RIPPLE = 'ripple'


app\services\payok\enums\pay_status.py
from enum import IntEnum


class PayStatus(IntEnum):

    waiting = 0
    success = 1
    fail = 2


app\services\payok\enums\webhook_status.py
from enum import IntEnum


class WebhookStatus(IntEnum):

    waiting = 0
    success = 1
    fail = 2


app\services\payok\enums\__init__.py
from .comission_type import ComissionType
from .currency import Currency
from .pay_status import PayStatus
from .payment_method import PaymentMethod
from .payout_method import PayoutMethod
from .webhook_status import WebhookStatus

__all__ = [
    "Currency",
    "ComissionType",
    "PayoutMethod",
    "PaymentMethod",
    "PayStatus",
    "WebhookStatus",
]


app\services\payok\models\balance.py
from pydantic import BaseModel


class Balance(BaseModel):
    """
    Model of balance
    """

    balance: float
    ref_balance: float


app\services\payok\models\new_payout.py
from pydantic import BaseModel
from pydantic.fields import Field

from .payout import Payout


class NewPayout(BaseModel):

    remain_balance: float
    payout: Payout = Field(..., alias='data')


app\services\payok\models\payout.py
from datetime import datetime
from typing import Optional

from pydantic import BaseModel, validator
from pydantic.fields import Field

from ..enums import PayoutMethod, PayStatus


class Payout(BaseModel):
    """
    Class for Payout model
    """

    payout_id: int = Field(..., alias='payout')
    method: PayoutMethod
    amount: float
    amount_profit: float
    comission_percent: float
    comission_fixed: float
    date_create: datetime = Field(..., alias='date')
    date_pay: Optional[datetime]
    status: PayStatus = Field(..., alias='payout_status_code')

    @validator('date_pay', 'date_create', pre=True)
    def validate_dates(date_str: str) -> Optional[datetime]:

        if not date_str:

            return

        return datetime.strptime(
            date_str,
            '%d.%m.%Y %H:%M:%S',
        )

    class Config:

        populate_by_name = True


app\services\payok\models\transaction.py
import json

from datetime import datetime
from typing import Any, Dict, Optional

from pydantic import BaseModel, validator
from pydantic.fields import Field

from ..enums import Currency, PayStatus, WebhookStatus


class Transaction(BaseModel):
    """
    Class for Transaction model
    """

    id: int = Field(..., alias='payment_id')
    description: str
    email: str
    amount: float
    amount_profit: float
    currency: Currency
    comission_percent: float
    comission_fixed: float
    method: Optional[str]
    transaction: int
    date: datetime
    pay_date: datetime = None
    status: PayStatus = Field(PayStatus.waiting, alias='transaction_status')
    custom_fields: Optional[Dict[str, Any]]
    webhook_status: WebhookStatus
    webhook_amount: int

    @property
    def is_paid(self) -> bool:

        return bool(self.status)

    @validator('custom_fields', pre=True)
    def validate_fields(raw_field: str) -> Optional[Dict]:

        if raw_field is None:

            return None

        string = raw_field.replace('&quot;', '"')
        return json.loads(string)


app\services\payok\models\__init__.py
from .balance import Balance
from .new_payout import NewPayout
from .payout import Payout
from .transaction import Transaction


__all__ = [
    "Balance",
    "NewPayout",
    "Payout",
    "Transaction",
]


app\services\yoomoney\client.py
import requests
import json
from typing import TYPE_CHECKING, Callable, Dict, List, Optional, Union
from datetime import datetime

from app.services.yoomoney import (
    Account,
    History,
    OperationDetails,
)


class Client:
    def __init__(self,
                 token: str = None,
                 base_url: str = None,
                 ):

        if base_url is None:
            self.base_url = "https://yoomoney.ru/api/"

        if token is not None:
            self.token = token



    def account_info(self):
        method = "account-info"
        return Account(base_url=self.base_url,
                       token=self.token,
                       method=method
                       )

    def operation_history(self,
                          type: str = None,
                          label: str = None,
                          from_date: datetime = None,
                          till_date: datetime = None,
                          start_record: str = None,
                          records: int = None,
                          details: bool = None,
                          ):
        method = "operation-history"
        return History(base_url=self.base_url,
                       token=self.token,
                       method=method,
                       type=type,
                       label=label,
                       from_date=from_date,
                       till_date=till_date,
                       start_record=start_record,
                       records=records,
                       details=details,
                       )

    def operation_details(self,
                          operation_id: str
                          ):
        method = "operation-details"
        return OperationDetails(base_url=self.base_url,
                                token=self.token,
                                method=method,
                                operation_id=operation_id,
                                )

app\services\yoomoney\exceptions.py


class YooMoneyError(Exception):
    """Basic class"""


class InvalidToken(YooMoneyError):

    message = "Token is not valid, or does not have the appropriate rights"
    def __init__(self, ):
        super().__init__(self.message)


class IllegalParamType(YooMoneyError):

    message = "Invalid parameter value 'type'"
    def __init__(self, ):
        super().__init__(self.message)

class IllegalParamStartRecord(YooMoneyError):

    message = "Invalid parameter value 'start_record'"
    def __init__(self, ):
        super().__init__(self.message)


class IllegalParamRecords(YooMoneyError):

    message = "Invalid parameter value 'records'"
    def __init__(self, ):
        super().__init__(self.message)

class IllegalParamLabel(YooMoneyError):

    message = "Invalid parameter value 'label'"
    def __init__(self, ):
        super().__init__(self.message)

class IllegalParamFromDate(YooMoneyError):

    message = "Invalid parameter value 'from_date'"
    def __init__(self, ):
        super().__init__(self.message)


class IllegalParamTillDate(YooMoneyError):

    message = "Invalid parameter value 'till_date'"
    def __init__(self, ):
        super().__init__(self.message)

class IllegalParamOperationId(YooMoneyError):

    message = "Invalid parameter value 'operation_id'"
    def __init__(self, ):
        super().__init__(self.message)

class TechnicalError(YooMoneyError):

    message = "Technical error, try calling the operation again later"
    def __init__(self, ):
        super().__init__(self.message)

class InvalidRequest(YooMoneyError):

    message = "Required query parameters are missing or have incorrect or invalid values"
    def __init__(self, ):
        super().__init__(self.message)

class UnauthorizedClient(YooMoneyError):

    message = "Invalid parameter value 'client_id' or 'client_secret', or the application" \
              " does not have the right to request authorization (for example, YooMoney blocked it 'client_id')"
    def __init__(self, ):
        super().__init__(self.message)

class InvalidGrant(YooMoneyError):

    message = "In issue 'access_token' denied. YuMoney did not issue a temporary token, " \
              "the token is expired, or this temporary token has already been issued " \
              "'access_token' (repeated request for an authorization token with the same temporary token)"
    def __init__(self, ):
        super().__init__(self.message)

class EmptyToken(YooMoneyError):

    message = "Response token is empty. Repeated request for an authorization token"
    def __init__(self, ):
        super().__init__(self.message)

app\services\yoomoney\__init__.py
from .account.account import Account
from .account.balance_details import BalanceDetails

from .operation.operation import Operation

from app.services.yoomoney.operation_details.operation_details import OperationDetails
from app.services.yoomoney.operation_details.digital_bonus import DigitalBonus
from app.services.yoomoney.operation_details.digital_product import DigitalProduct
from app.services.yoomoney.operation_details.digital_good import DigitalGood

from .history.history import History

from .authorize.authorize import Authorize

from .quickpay.quickpay import Quickpay

from .client import Client

__all__ = [
    'Client',
    'Account',
    'BalanceDetails',
    'Operation',
    'History',
    'Authorize',
    "OperationDetails",
    "DigitalBonus",
    "DigitalProduct",
    "DigitalGood",
    "Quickpay",
    ]

app\services\yoomoney\account\account.py
import requests
import json
from typing import TYPE_CHECKING, Optional, List

from app.services.yoomoney.account.balance_details import BalanceDetails
from app.services.yoomoney.account.card import Card
from app.services.yoomoney.exceptions import InvalidToken

class Account:

    def __init__(self,
                 base_url: str = None,
                 token: str = None,
                 method: str = None,

                 ):

        self.__private_method = method

        self.__private_base_url = base_url
        self.__private_token = token

        data = self._request()

        if len(data) != 0:
            self.account = data['account']
            self.balance = data['balance']
            self.currency = data['currency']
            self.account_status = data['account_status']
            self.account_type = data['account_type']

            self.balance_details = BalanceDetails()
            if 'balance_details' in data:
                if 'available' in data['balance_details']:
                    self.balance_details.available = float(data['balance_details']['available'])
                if 'blocked' in data['balance_details']:
                    self.balance_details.blocked = float(data['balance_details']['blocked'])
                if 'debt' in data['balance_details']:
                    self.balance_details.debt = float(data['balance_details']['debt'])
                if 'deposition_pending' in data['balance_details']:
                    self.balance_details.deposition_pending = float(data['balance_details']['deposition_pending'])
                if 'total' in data['balance_details']:
                    self.balance_details.total = float(data['balance_details']['total'])
                if 'hold' in data['balance_details']:
                    self.balance_details.hold = float(data['balance_details']['hold'])

            self.cards_linked = []
            if 'cards_linked' in data:
                for card_linked in data['cards_linked']:
                    card = Card(pan_fragment=card_linked['pan_fragment'], type=card_linked['type'])
                    self.cards_linked.append(card)
        else:
            raise InvalidToken()

    def _request(self):

        access_token = str(self.__private_token)
        url = self.__private_base_url + self.__private_method

        headers = {
            'Authorization': 'Bearer ' + str(access_token),
            'Content-Type': 'application/x-www-form-urlencoded'
        }

        response = requests.request("POST", url, headers=headers)

        return response.json()


app\services\yoomoney\account\balance_details.py


class BalanceDetails:
    def __init__(self,
                 total: float = None,
                 available: float = None,
                 deposition_pending: float = None,
                 blocked: float = None,
                 debt: float = None,
                 hold: float = None,
                 ):

        self.total = total

        self.available = available

        self.deposition_pending = deposition_pending

        self.blocked = blocked

        self.debt = debt

        self.hold = hold






app\services\yoomoney\account\card.py



class Card:
    def __init__(self,
                 pan_fragment: str = None,
                 type: str = None,
                 ):
        self.pan_fragment = pan_fragment
        self.type = type



app\services\yoomoney\account\__init__.py


app\services\yoomoney\authorize\authorize.py
from typing import List
import requests

from app.services.yoomoney.exceptions import (
    InvalidRequest,
    UnauthorizedClient,
    InvalidGrant,
    EmptyToken
    )

class Authorize:
    def __init__(
            self,
            client_id: str,
            redirect_uri: str,
            scope: List[str]
                  ):

        url = "https://yoomoney.ru/oauth/authorize?client_id={client_id}&response_type=code" \
              "&redirect_uri={redirect_uri}&scope={scope}".format(client_id=client_id,
                                                                  redirect_uri=redirect_uri,
                                                                  scope='%20'.join([str(elem) for elem in scope]),
                                                                  )

        headers = {
            'Content-Type': 'application/x-www-form-urlencoded'
        }

        response = requests.request("POST", url, headers=headers)

        if response.status_code == 200:
            print("Visit this website and confirm the application authorization request:")
            print(response.url)

        code = str(input("Enter redirected url (https://yourredirect_uri?code=XXXXXXXXXXXXX) or just code: "))
        try:
            code = code[code.index("code=") + 5:].replace(" ","")
        except:
            pass

        url = "https://yoomoney.ru/oauth/token?code={code}&client_id={client_id}&" \
              "grant_type=authorization_code&redirect_uri={redirect_uri}".format(code=str(code),
                                                                                 client_id=client_id,
                                                                                 redirect_uri=redirect_uri,
                                                                                 )

        response = requests.request("POST", url, headers=headers)

        if "error" in response.json():
            error = response.json()["error"]
            if error == "invalid_request":
                raise InvalidRequest()
            elif error == "unauthorized_client":
                raise UnauthorizedClient()
            elif error == "invalid_grant":
                raise InvalidGrant()

        if response.json()['access_token'] == "":
            raise EmptyToken()

        print("Your access token:")
        print(response.json()['access_token'])

app\services\yoomoney\authorize\__init__.py


app\services\yoomoney\history\history.py
from datetime import datetime
from typing import Optional
import requests
import json

from app.services.yoomoney.operation.operation import Operation

from app.services.yoomoney.exceptions import (
    IllegalParamType,
    IllegalParamStartRecord,
    IllegalParamRecords,
    IllegalParamLabel,
    IllegalParamFromDate,
    IllegalParamTillDate,
    TechnicalError
    )


class History:
    def __init__(self,
                 base_url: str = None,
                 token: str = None,
                 method: str = None,
                 type: str = None,
                 label: str = None,
                 from_date: Optional[datetime] = None,
                 till_date: Optional[datetime] = None,
                 start_record: str = None,
                 records: int = None,
                 details: bool = None,
                 ):

        self.__private_method = method

        self.__private_base_url = base_url
        self.__private_token = token

        self.type = type
        self.label = label
        try:
            if from_date is not None:
                from_date = "{Y}-{m}-{d}T{H}:{M}:{S}".format(
                    Y=str(from_date.year),
                    m=str(from_date.month),
                    d=str(from_date.day),
                    H=str(from_date.hour),
                    M=str(from_date.minute),
                    S=str(from_date.second)
                )
        except:
            raise IllegalParamFromDate()

        try:
            if till_date is not None:
                till_date = "{Y}-{m}-{d}T{H}:{M}:{S}".format(
                    Y=str(till_date.year),
                    m=str(till_date.month),
                    d=str(till_date.day),
                    H=str(till_date.hour),
                    M=str(till_date.minute),
                    S=str(till_date.second)
                )
        except:
            IllegalParamTillDate()

        self.from_date = from_date
        self.till_date = till_date
        self.start_record = start_record
        self.records = records
        self.details = details

        data = self._request()

        if "error" in data:
            if data["error"] == "illegal_param_type":
                raise IllegalParamType()
            elif data["error"] == "illegal_param_start_record":
                raise IllegalParamStartRecord()
            elif data["error"] == "illegal_param_records":
                raise IllegalParamRecords()
            elif data["error"] == "illegal_param_label":
                raise IllegalParamLabel()
            elif data["error"] == "illegal_param_from":
                raise IllegalParamFromDate()
            elif data["error"] == "illegal_param_till":
                raise IllegalParamTillDate()
            else:
                raise TechnicalError()


        self.next_record = None
        if "next_record" in data:
            self.next_record = data["next_record"]

        self.operations = list()
        for operation_data in data["operations"]:
            param = {}
            if "operation_id" in operation_data:
                param["operation_id"] = operation_data["operation_id"]
            else:
                param["operation_id"] = None
            if "status" in operation_data:
                param["status"] = operation_data["status"]
            else:
                param["status"] = None
            if "datetime" in operation_data:
                param["datetime"] = datetime.strptime(str(operation_data["datetime"]).replace("T", " ").replace("Z", ""), '%Y-%m-%d %H:%M:%S')
            else:
                param["datetime"] = None
            if "title" in operation_data:
                param["title"] = operation_data["title"]
            else:
                param["title"] = None
            if "pattern_id" in operation_data:
                param["pattern_id"] = operation_data["pattern_id"]
            else:
                param["pattern_id"] = None
            if "direction" in operation_data:
                param["direction"] = operation_data["direction"]
            else:
                param["direction"] = None
            if "amount" in operation_data:
                param["amount"] = operation_data["amount"]
            else:
                param["amount"] = None
            if "label" in operation_data:
                param["label"] = operation_data["label"]
            else:
                param["label"] = None
            if "type" in operation_data:
                param["type"] = operation_data["type"]
            else:
                param["type"] = None


            operation = Operation(
                operation_id= param["operation_id"],
                status=param["status"],
                datetime=datetime.strptime(str(param["datetime"]).replace("T", " ").replace("Z", ""), '%Y-%m-%d %H:%M:%S'),
                title=param["title"],
                pattern_id=param["pattern_id"],
                direction=param["direction"],
                amount=param["amount"],
                label=param["label"],
                type=param["type"],
            )
            self.operations.append(operation)



    def _request(self):

        access_token = str(self.__private_token)
        url = self.__private_base_url + self.__private_method

        headers = {
            'Authorization': 'Bearer ' + str(access_token),
            'Content-Type': 'application/x-www-form-urlencoded'
        }

        payload = {}
        if self.type is not None:
            payload["type"] = self.type
        if self.label is not None:
            payload["label"] = self.label
        if self.from_date is not None:
            payload["from"] = self.from_date
        if self.till_date is not None:
            payload["till"] = self.till_date
        if self.start_record is not None:
            payload["start_record"] = self.start_record
        if self.records is not None:
            payload["records"] = self.records
        if self.details is not None:
            payload["details"] = self.details

        response = requests.request("POST", url, headers=headers, data=payload)

        return response.json()

app\services\yoomoney\history\__init__.py


app\services\yoomoney\operation\operation.py
from datetime import datetime as dt
from typing import Optional

class Operation:
    def __init__(self,
                 operation_id: str = None,
                 status: str = None,
                 datetime: Optional[dt] = None,
                 title: str = None,
                 pattern_id: str = None,
                 direction: str = None,
                 amount: float = None,
                 label: str = None,
                 type: str = None,
                 ):
        self.operation_id = operation_id
        self.status = status
        self.datetime = datetime
        self.title = title
        self.pattern_id = pattern_id
        self.direction = direction
        self.amount = amount
        self.label = label
        self.type = type

app\services\yoomoney\operation\__init__.py


app\services\yoomoney\operation_details\digital_bonus.py


class DigitalBonus:
    def __init__(self,
                 serial: str,
                 secret: str
                 ):
        self.serial = serial
        self.secret = secret


app\services\yoomoney\operation_details\digital_good.py
from typing import List

from app.services.yoomoney.operation_details.digital_product import DigitalProduct
from app.services.yoomoney.operation_details.digital_bonus import DigitalBonus



class DigitalGood:
    def __init__(self,
                 products: List[DigitalProduct],
                 bonuses: List[DigitalBonus]
                 ):
        self.products = products
        self.bonuses = bonuses


app\services\yoomoney\operation_details\digital_product.py


class DigitalProduct:
    def __init__(self,
                 merchant_article_id: str,
                 serial: str,
                 secret: str
                 ):
        self.merchant_article_id = merchant_article_id
        self.serial = serial
        self.secret = secret


app\services\yoomoney\operation_details\operation_details.py
from datetime import datetime
from typing import Optional, List
import requests

from app.services.yoomoney.exceptions import (
    IllegalParamOperationId,
    TechnicalError
    )

from app.services.yoomoney.operation_details.digital_product import DigitalProduct
from app.services.yoomoney.operation_details.digital_bonus import DigitalBonus
from app.services.yoomoney.operation_details.digital_good import DigitalGood


class OperationDetails:
    def __init__(self,
                 base_url: str,
                 token: str,
                 operation_id: str,
                 method: str = None,
                 ):
        self.__private_method = method
        self.__private_token = token
        self.__private_base_url = base_url
        self.operation_id = operation_id

        data = self._request()

        if "error" in data:
            if data["error"] == "illegal_param_operation_id":
                raise IllegalParamOperationId()
            else:
                raise TechnicalError()

        self.status = None
        self.pattern_id = None
        self.direction = None
        self.amount = None
        self.amount_due = None
        self.fee = None
        self.datetime = None
        self.title = None
        self.sender = None
        self.recipient = None
        self.recipient_type = None
        self.message = None
        self.comment = None
        self.codepro = None
        self.protection_code = None
        self.expires = None
        self.answer_datetime = None
        self.label = None
        self.details = None
        self.type = None
        self.digital_goods = None

        if "status" in data:
            self.status = data["status"]
        if "pattern_id" in data:
            self.pattern_id = data["pattern_id"]
        if "direction" in data:
            self.direction = data["direction"]
        if "amount" in data:
            self.amount = data["amount"]
        if "amount_due" in data:
            self.amount_due = data["amount_due"]
        if "fee" in data:
            self.fee = data["fee"]
        if "datetime" in data:
            self.datetime = datetime.strptime(str(data["datetime"]).replace("T", " ").replace("Z", ""), '%Y-%m-%d %H:%M:%S')
        if "title" in data:
            self.title = data["title"]
        if "sender" in data:
            self.sender = data["sender"]
        if "recipient" in data:
            self.recipient = data["recipient"]
        if "recipient_type" in data:
            self.recipient_type = data["recipient_type"]
        if "message" in data:
            self.message = data["message"]
        if "comment" in data:
            self.comment = data["comment"]
        if "codepro" in data:
            self.codepro = bool(data["codepro"])
        if "protection_code" in data:
            self.protection_code = data["protection_code"]
        if "expires" in data:
            self.datetime = datetime.strptime(str(data["expires"]).replace("T", " ").replace("Z", ""), '%Y-%m-%d %H:%M:%S')
        if "answer_datetime" in data:
            self.datetime = datetime.strptime(str(data["answer_datetime"]).replace("T", " ").replace("Z", ""), '%Y-%m-%d %H:%M:%S')
        if "label" in data:
            self.label = data["label"]
        if "details" in data:
            self.details = data["details"]
        if "type" in data:
            self.type = data["type"]
        if "digital_goods" in data:
            products: List[DigitalProduct] = []
            for product in data["digital_goods"]["article"]:
                digital_product = DigitalProduct(merchant_article_id=product["merchantArticleId"],
                                                 serial=product["serial"],
                                                 secret=product["secret"],
                                                 )
                products.append(digital_product)

            bonuses: List[DigitalBonus] = []
            for bonus in data["digital_goods"]["bonus"]:
                digital_product = DigitalBonus(serial=bonus["serial"],
                                               secret=bonus["secret"],
                                               )
                bonuses.append(digital_product)

            self.digital_goods = DigitalGood(products=products,
                                             bonuses=bonuses
                                             )

    def _request(self):

        access_token = str(self.__private_token)
        url = self.__private_base_url + self.__private_method

        headers = {
            'Authorization': 'Bearer ' + str(access_token),
            'Content-Type': 'application/x-www-form-urlencoded'
        }

        payload = {}

        payload["operation_id"] = self.operation_id


        response = requests.request("POST", url, headers=headers, data=payload)

        return response.json()


app\services\yoomoney\operation_details\__init__.py


app\services\yoomoney\quickpay\quickpay.py
import requests

class Quickpay:
    def __init__(self,
                 receiver: str,
                 quickpay_form : str,
                 targets: str,
                 paymentType: str,
                 sum: float,
                 formcomment: str = None,
                 short_dest: str = None,
                 label: str = None,
                 comment: str = None,
                 successURL: str = None,
                 need_fio: bool = None,
                 need_email: bool = None,
                 need_phone: bool = None,
                 need_address: bool = None,
                 ):
        self.receiver = receiver
        self.quickpay_form = quickpay_form
        self.targets = targets
        self.paymentType = paymentType
        self.sum = sum
        self.formcomment = formcomment
        self.short_dest = short_dest
        self.label = label
        self.comment = comment
        self.successURL = successURL
        self.need_fio = need_fio
        self.need_email = need_email
        self.need_phone = need_phone
        self.need_address = need_address

        self.response = self._request()

    def _request(self):

        self.base_url = "https://yoomoney.ru/quickpay/confirm.xml?"

        payload = {}

        payload["receiver"] = self.receiver
        payload["quickpay_form"] = self.quickpay_form
        payload["targets"] = self.targets
        payload["paymentType"] = self.paymentType
        payload["sum"] = self.sum

        if self.formcomment != None:
            payload["formcomment"] = self.formcomment
        if self.short_dest != None:
            payload["short_dest"] = self.short_dest
        if self.label != None:
            payload["label"] = self.label
        if self.comment != None:
            payload["comment"] = self.comment
        if self.successURL != None:
            payload["successURL"] = self.successURL
        if self.need_fio != None:
            payload["need_fio"] = self.need_fio
        if self.need_email != None:
            payload["need_email"] = self.need_email
        if self.need_phone != None:
            payload["need_phone"] = self.need_phone
        if self.need_address != None:
            payload["need_address"] = self.need_address

        for value in payload:
            self.base_url+=str(value).replace("_","-") + "=" + str(payload[value])
            self.base_url+="&"

        self.base_url = self.base_url[:-1].replace(" ", "%20")

        response = requests.request("POST", self.base_url)

        self.redirected_url = response.url
        return response

app\services\yoomoney\quickpay\__init__.py


